0001                               ************************************************************************
0002                               ;
0003                               ; Microsoft Color Computer Basic
0004                               
0005 a000                          UART      EQU  $A000
0006 a001                          RECEV     EQU  UART+1
0007 a001                          TRANS     EQU  UART+1
0008 a000                          USTAT     EQU  UART
0009 a000                          UCTRL     EQU  UART
0010                               
0011 0008                          BS        EQU  8              ; BACKSPACE
0012 000d                          CR        EQU  $D             ; ENTER KEY
0013 001b                          ESC       EQU  $1B            ; ESCAPE CODE
0014 0020                          SPACE     EQU  $20            ; SPACE (BLANK)
0015 003a                          STKBUF    EQU  58             ; STACK BUFFER ROOM
0016 00fa                          LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
0017 00fa                          MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
0018                               * PSEUDO OPS
0019 0021                          SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
0020 008c                          SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
0021 0086                          SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
0022                               *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
0023                               *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
0024 0015                          RTS_LOW   EQU  $15            ; 6850 ACIA CONTROL REGISTER: RX INT DISABLED, RTS LOW, TX INT DISABLED, 8N1, CLK/16
0025 0000                                    ORG  0
0026 0000                          ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
0027 0001                          CHARAC    RMB  1              ; TERMINATOR FLAG 1
0028 0002                          ENDCHR    RMB  1              ; TERMINATOR FLAG 2
0029 0003                          TMPLOC    RMB  1              ; SCRATCH VARIABLE
0030 0004                          IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
0031 0005                          DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
0032 0006                          VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
0033 0007                          GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
0034 0008                          ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
0035 0009                          INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
0036 000a                          RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
0037 000b                          TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
0038 000d                          LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
0039 000f                          TEMPTR    RMB  2              ; TEMPORARY POINTER
0040 0011                          TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
0041 0013                          FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
0042 0017                          BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
0043 0019                          TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
0044 001b                          VARTAB    RMB  2              ; *PV START OF VARIABLES
0045 001d                          ARYTAB    RMB  2              ; *PV START OF ARRAYS
0046 001f                          ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
0047 0021                          FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
0048 0023                          STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
0049 0025                          FRESPC    RMB  2              ; UTILITY STRING POINTER
0050 0027                          MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
0051 0029                          OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
0052 002b                          BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
0053 002d                          OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
0054 002f                          TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
0055 0031                          DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
0056 0033                          DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
0057 0035                          DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
0058 0037                          VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
0059 0039                          VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
0060 003b                          VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
0061 003d                          RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
0062 003f                          TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
0063                               * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
0064                               * USED AS SCRATCH PAD VARIABLES.
0065                               ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0066 0040                          V40       RMB  1
0067 0041                          V41       RMB  1
0068 0042                          V42       RMB  1
0069 0043                          V43       RMB  1
0070 0044                          V44       RMB  1
0071                               ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0072 0045                          V45       RMB  1
0073 0046                          V46       RMB  1
0074 0047                          V47       RMB  1
0075 0048                          V48       RMB  2
0076                               ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
0077 004a                          V4A       RMB  1
0078 004b                          V4B       RMB  2
0079 004d                          V4D       RMB  2
0080                               ** FLOATING POINT ACCUMULATOR #0
0081 004f                          FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
0082 0050                          FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
0083 0054                          FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
0084 0055                          COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
0085 0056                          STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
0086 005b                          FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
0087                               ** FLOATING POINT ACCUMULATOR #1
0088 005c                          FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
0089 005d                          FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
0090 0061                          FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
0091 0062                          RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
0092 0063                          FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
0093 0064                          COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
0094 0066                          LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
0095 0068                          CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
0096 006a                          DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
0097 006b                          DEVLCF    RMB  1              ; *TV TAB ZONE
0098 006c                          DEVPOS    RMB  1              ; *TV PRINT POSITION
0099 006d                          DEVWID    RMB  1              ; *TV PRINT WIDTH
0100 006e                          RSTFLG    RMB  1              ; *PV WARM START FLAG: $55=WARM, OTHER=COLD
0101 006f                          RSTVEC    RMB  2              ; *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
0102 0071                          TOPRAM    RMB  2              ; *PV TOP OF RAM
0103 0073                          IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
0104 0074                          ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
0105                               * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0106 0076                          LPTCFW    RMB  1              ; 16
0107 0077                          LPTLCF    RMB  1              ; 112
0108 0078                          LPTWID    RMB  1              ; 132
0109 0079                          LPTPOS    RMB  1              ; 0
0110 007a                          EXECJP    RMB  2              ; LB4AA
0111                               
0112                               * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
0113                               * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
0114                               * INTERPRETED IS STORED AT CHARAD.
0115 007c 0c 84              [ 6 ] GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
0116 007e 26 02              [ 3 ]           BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
0117 0080 0c 83              [ 6 ]           INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
0118 0082 b6                       GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
0119 0083                          CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
0120                               *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
0121                               *         *    PROCESSING
0122 0085 7e c1 c2           [ 4 ]           JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
0123                               
0124 0088                          VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
0125 0089                          VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
0126 008a                          VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
0127 008b                          VAE       RMB  1              ; = BY THE RND STATEMENT
0128                               
0129                               * EXTENDED BASIC VARIABLES
0130 008c                          TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
0131 008d                          USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
0132                               
0133                               * EXTENDED BASIC SCRATCH PAD VARIABLES
0134 008f                          VCF       RMB  2
0135 0091                          VD1       RMB  2
0136 0093                          VD3       RMB  2
0137 0095                          VD5       RMB  2
0138 0097                          VD7       RMB  1
0139 0098                          VD8       RMB  1
0140 0099                          VD9       RMB  1
0141 009a                          VDA       RMB  1
0142 009b                          SW3VEC    RMB  3
0143 009e                          SW2VEC    RMB  3
0144 00a1                          SWIVEC    RMB  3
0145 00a4                          NMIVEC    RMB  3
0146 00a7                          IRQVEC    RMB  3
0147 00aa                          FRQVEC    RMB  3
0148 00ad                          USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
0149 00b0                          RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
0150 00b1                                    RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
0151                               
0152                               **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
0153 00b5                          USR0      RMB  2              ; USR 0 VECTOR
0154 00b7                                    RMB  2              ; USR 1
0155 00b9                                    RMB  2              ; USR 2
0156 00bb                                    RMB  2              ; USR 3
0157 00bd                                    RMB  2              ; USR 4
0158 00bf                                    RMB  2              ; USR 5
0159 00c1                                    RMB  2              ; USR 6
0160 00c3                                    RMB  2              ; USR 7
0161 00c5                                    RMB  2              ; USR 8
0162 00c7                                    RMB  2              ; USR 9
0163                               
0164 00c9                          STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
0165 00f1                          LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
0166 00f3                          LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
0167 01ee                          STRBUF    RMB  41             ; STRING BUFFER
0168                               
0169 0217                          PROGST    RMB  1              ; START OF PROGRAM SPACE
0170                               *         INTERRUPT VECTORS
0171                               *          ORG  $FFF2
0172                               *SWI3      RMB  2
0173                               *SWI2      RMB  2
0174                               *FIRQ      RMB  2
0175                               *IRQ       RMB  2
0176                               *SWI       RMB  2
0177                               *NMI       RMB  2
0178                               *RESETV    RMB  2
0179                               
0180 c000                                    ORG  $C000
0181                               
0182                               * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE
0183 c000 7e c0 49           [ 4 ]           JMP   RESVEC
0184                               
0185                               * CONSOLE IN
0186 c003 8d 03              [ 7 ] LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN
0187 c005 27 fc              [ 3 ]           BEQ  LA171          ; LOOP IF NO KEY DOWN
0188 c007 39                 [ 5 ]           RTS
0189                               
0190                               *
0191                               * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
0192                               * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
0193                               *
0194                               *
0195                               LA1C1
0196 c008 b6 a0 00           [ 5 ] KEYIN     LDA  USTAT
0197 c00b 85 01              [ 2 ]           BITA #1
0198 c00d 27 06              [ 3 ]           BEQ  NOCHAR
0199 c00f b6 a0 01           [ 5 ]           LDA  RECEV
0200 c012 84 7f              [ 2 ]           ANDA #$7F
0201 c014 39                 [ 5 ]           RTS
0202 c015 4f                 [ 2 ] NOCHAR    CLRA
0203 c016 39                 [ 5 ]           RTS
0204                               
0205                               
0206                               
0207                               * CONSOLE OUT
0208 c017 8d 24              [ 7 ] PUTCHR    BSR  WAITACIA
0209 c019 34 02              [ 6 ]           PSHS A              ;
0210 c01b 81 0d              [ 2 ]           CMPA #CR            ; IS IT CARRIAGE RETURN?
0211 c01d 27 0b              [ 3 ]           BEQ  NEWLINE        ; YES
0212 c01f b7 a0 01           [ 5 ]           STA  TRANS
0213 c022 0c 79              [ 6 ]           INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
0214 c024 96 79              [ 4 ]           LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
0215 c026 91 78              [ 4 ]           CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
0216 c028 25 10              [ 3 ]           BLO  PUTEND         ; NO
0217 c02a 0f 79              [ 6 ] NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER
0218 c02c 8d 0f              [ 7 ]           BSR  WAITACIA
0219 c02e 86 0d              [ 2 ]           LDA  #13
0220 c030 b7 a0 01           [ 5 ]           STA  TRANS
0221 c033 8d 08              [ 7 ]           BSR  WAITACIA
0222 c035 86 0a              [ 2 ]           LDA  #10            ; DO LINEFEED AFTER CR
0223 c037 b7 a0 01           [ 5 ]           STA  TRANS
0224 c03a 35 02              [ 6 ] PUTEND    PULS A              ;
0225 c03c 39                 [ 5 ]           RTS
0226                               
0227 c03d 34 02              [ 6 ] WAITACIA  PSHS A
0228 c03f b6 a0 00           [ 5 ] WRWAIT    LDA  USTAT
0229 c042 85 02              [ 2 ]           BITA #2
0230 c044 27 f9              [ 3 ]           BEQ  WRWAIT
0231 c046 35 02              [ 6 ]           PULS A              ;
0232 c048 39                 [ 5 ]           RTS
0233                               
0234                               *
0235                               RESVEC
0236 c049 10 ce 01 ee        [ 4 ] LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
0237 c04d 96 6e              [ 4 ]           LDA  RSTFLG         ; GET WARM START FLAG
0238 c04f 81 55              [ 2 ]           CMPA #$55           ; IS IT A WARM START?
0239 c051 26 0a              [ 3 ]           BNE  BACDST         ; NO - D0 A COLD START
0240 c053 9e 6f              [ 5 ]           LDX  RSTVEC         ; WARM START VECTOR
0241 c055 a6 84              [ 4 ]           LDA  ,X             ; GET FIRST BYTE OF WARM START ADDR
0242 c057 81 12              [ 2 ]           CMPA #$12           ; IS IT NOP?
0243 c059 26 02              [ 3 ]           BNE  BACDST         ; NO - DO A COLD START
0244 c05b 6e 84              [ 3 ]           JMP  ,X             ; YES, G0 THERE
0245                               
0246                               * COLD START ENTRY
0247                               
0248 c05d 8e 02 18           [ 3 ] BACDST    LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
0249 c060 6f 83              [ 9 ] LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
0250 c062 30 01              [ 5 ]           LEAX 1,X            ; ADVANCE POINTER ONE
0251 c064 26 fa              [ 3 ]           BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
0252 c066 8e 02 17           [ 3 ]           LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
0253 c069 6f 80              [ 8 ]           CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
0254 c06b 9f 19              [ 5 ]           STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
0255 c06d a6 02              [ 5 ] LA084     LDA  2,X            ; LOOK FOR END OF MEMORY
0256 c06f 43                 [ 2 ]           COMA                ; * COMPLEMENT IT AND PUT IT BACK
0257 c070 a7 02              [ 5 ]           STA  2,X            ; * INTO SYSTEM MEMORY
0258 c072 a1 02              [ 5 ]           CMPA 2,X            ; IS IT RAM?
0259 c074 26 06              [ 3 ]           BNE  LA093          ; BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
0260 c076 30 01              [ 5 ]           LEAX 1,X            ; MOVE POINTER UP ONE
0261 c078 63 01              [ 7 ]           COM  1,X            ; RE-COMPLEMENT TO RESTORE BYTE
0262 c07a 20 f1              [ 3 ]           BRA  LA084          ; KEEP LOOKING FOR END OF RAM
0263 c07c 9f 71              [ 5 ] LA093     STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
0264 c07e 9f 27              [ 5 ]           STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
0265 c080 9f 23              [ 5 ]           STX  STRTAB         ; SAVE START OF STRING VARIABLES
0266 c082 30 89 ff 38        [ 8 ]           LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
0267 c086 9f 21              [ 5 ]           STX  FRETOP         ; SAVE START OF STRING SPACE
0268 c088 1f 14              [ 6 ]           TFR  X,S            ; PUT STACK THERE
0269 c08a 8e c0 d1           [ 3 ]           LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
0270 c08d ce 00 76           [ 3 ]           LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
0271 c090 c6 12              [ 2 ]           LDB  #18            ; MOVE 18 BYTES
0272 c092 bd c1 b1           [ 8 ]           JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
0273 c095 ce 00 a7           [ 3 ]           LDU  #IRQVEC        ; POINT U TO NEXT RAM DESTINATION
0274 c098 c6 04              [ 2 ]           LDB  #4             ; MOVE 4 MORE BYTES
0275 c09a bd c1 b1           [ 8 ]           JSR  LA59A          ; MOVE 4 BYTES FROM ROM TO RAM
0276 c09d 86 39              [ 2 ]           LDA  #$39
0277 c09f 97 f0              [ 4 ]           STA  LINHDR-1       ; PUT RTS IN LINHDR-1
0278 c0a1 bd c4 bd           [ 8 ]           JSR  LAD19          ; G0 DO A 'NEW'
0279                               * EXTENDED BASIC INITIALISATION
0280 c0a4 8e 00 b5           [ 3 ]           LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
0281 c0a7 9f 8d              [ 5 ]           STX  USRADR         ; USR JUMP TABLE
0282                               * INITIALIZE THE USR CALLS TO 'FC ERROR'
0283 c0a9 ce cb d1           [ 3 ]           LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
0284 c0ac c6 0a              [ 2 ]           LDB  #10            ; 10 USR CALLS IN EX BASIC
0285 c0ae ef 81              [ 8 ] L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
0286 c0b0 5a                 [ 2 ]           DECB                ; FINISHED ALL 10?
0287 c0b1 26 fb              [ 3 ]           BNE  L8031          ; NO
0288                               
0289                               * INITIALISE ACIA
0290 c0b3 86 15              [ 2 ]           LDA  #RTS_LOW       ; DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
0291 c0b5 b7 a0 00           [ 5 ]           STA  UCTRL
0292 c0b8 8e c1 06           [ 3 ]           LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
0293 c0bb bd d0 e8           [ 8 ]           JSR  LB99C          ; PRINT 'COLOR BASIC'
0294 c0be 8e c0 c9           [ 3 ]           LDX  #BAWMST        ; WARM START ADDRESS
0295 c0c1 9f 6f              [ 5 ]           STX  RSTVEC         ; SAVE IT
0296 c0c3 86 55              [ 2 ]           LDA  #$55           ; WARM START FLAG
0297 c0c5 97 6e              [ 4 ]           STA  RSTFLG         ; SAVE IT
0298 c0c7 20 04              [ 3 ]           BRA  LA0F3          ; GO TO BASIC'S MAIN LOOP
0299 c0c9 12                 [ 2 ] BAWMST    NOP                 ; NOP REQ'D FOR WARM START
0300 c0ca bd c4 d7           [ 8 ]           JSR  LAD33          ; DO PART OF A NEW
0301 c0cd 7e c4 25           [ 4 ] LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
0302                               *
0303                               * FIRQ SERVICE ROUTINE
0304                               BFRQSV
0305 c0d0 3b                 [15 ]           RTI
0306                               *
0307                               * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
0308 c0d1 10                       LA10D     FCB  16             ; TAB FIELD WIDTH
0309 c0d2 40                                 FCB  64             ; LAST TAB ZONE
0310 c0d3 50                                 FCB  80             ; PRINTER WIDTH
0311 c0d4 00                                 FCB  0              ; LINE PRINTER POSITION
0312 c0d5 cb d1                              FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
0313                               * LINE INPUT ROUTINE
0314 c0d7 0c 84              [ 6 ]           INC  CHARAD+1
0315 c0d9 26 02              [ 3 ]           BNE  LA123
0316 c0db 0c 83              [ 6 ]           INC  CHARAD
0317 c0dd b6 00 00           [ 5 ] LA123     LDA  >0000
0318 c0e0 7e c1 c2           [ 4 ]           JMP  BROMHK
0319                               *
0320                               * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
0321 c0e3 7e c1 c1           [ 4 ]           JMP  BIRQSV         ; IRQ SERVICE
0322 c0e6 7e c0 d0           [ 4 ]           JMP  BFRQSV         ; FIRQ SERVICE
0323 c0e9 7e cb d1           [ 4 ]           JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
0324 c0ec 80                                 FCB  $80            ; *RANDOM SEED
0325 c0ed 4f c7                              FDB  $4FC7          ; *RANDON SEED OF MANTISSA
0326 c0ef 52 59                              FDB  $5259          ; *.811635157
0327                               * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
0328 c0f1 32                       COMVEC    FCB  50             ; 50 BASIC COMMANDS
0329 c0f2 c2 20                              FDB  LAA66          ; POINTS TO RESERVED WORDS
0330 c0f4 c3 2d                              FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
0331 c0f6 1d                                 FCB  29             ; 29 BASIC SECONDARY COMMANDS
0332 c0f7 c2 c0                              FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
0333 c0f9 c1 d1                              FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
0334 c0fb 00 00                              FDB  0              ; NO MORE TABLES (RES WORDS=0)
0335 c0fd 00 00                              FDB  0              ; NO MORE TABLES
0336 c0ff 00 00                              FDB  0              ; NO MORE TABLES
0337 c101 00 00                              FDB  0              ; NO MORE TABLES
0338 c103 00 00                              FDB  0              ; NO MORE TABLES
0339 c105 00 00                              FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
0340                               
0341                               * COPYRIGHT MESSAGES
0342 c107 36 38 30 39 20 45        LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
0343 c11a 0d                                 FCB  CR
0344 c11b 28 43 29 20 31 39                  FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
0345 c130 0d 0d                    LA156     FCB  CR,CR
0346 c132 00                       LA165     FCB  $00
0347                               
0348                               
0349 c133 34 16              [ 9 ] LA35F     PSHS X,B,A          ; SAVE REGISTERS
0350 c135 9e 76              [ 5 ]           LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
0351 c137 dc 78              [ 5 ]           LDD  LPTWID         ; PRINTER WIDTH AND POSITION
0352 c139 9f 6a              [ 5 ] LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
0353 c13b d7 6c              [ 4 ]           STB  DEVPOS         ; SAVE PRINT POSITION
0354 c13d 97 6d              [ 4 ]           STA  DEVWID         ; SAVE PRINT WIDTH
0355 c13f 35 96              [11 ]           PULS A,B,X,PC       ; RESTORE REGISTERS
0356                               
0357                               * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
0358                               * EXIT WITH BREAK KEY: CARRY = 1
0359                               * EXIT WITH ENTER KEY: CARRY = 0
0360                               LA38D
0361 c141 0f 73              [ 6 ] LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
0362 c143 8e 00 f4           [ 3 ]           LDX  #LINBUF+1      ; INPUT LINE BUFFER
0363 c146 c6 01              [ 2 ]           LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
0364                               *         BACKSPACE AS FIRST CHARACTER
0365 c148 bd c0 03           [ 8 ] LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
0366 c14b 81 08              [ 2 ]           CMPA #BS            ; BACKSPACE
0367 c14d 26 07              [ 3 ]           BNE  LA3B4          ; NO
0368 c14f 5a                 [ 2 ]           DECB                ; YES - DECREMENT CHAR COUNTER
0369 c150 27 ef              [ 3 ]           BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
0370 c152 30 1f              [ 5 ]           LEAX -1,X           ; DECREMENT BUFFER POINTER
0371 c154 20 34              [ 3 ]           BRA  LA3E8          ; ECHO CHAR TO SCREEN
0372 c156 81 15              [ 2 ] LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
0373 c158 26 0a              [ 3 ]           BNE  LA3C2          ; NO
0374                               * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
0375 c15a 5a                 [ 2 ] LA3B8     DECB                ; DEC CHAR CTR
0376 c15b 27 e4              [ 3 ]           BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
0377 c15d 86 08              [ 2 ]           LDA  #BS            ; BACKSPACE?
0378 c15f bd c0 17           [ 8 ]           JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
0379 c162 20 f6              [ 3 ]           BRA  LA3B8          ; KEEP GOING
0380 c164 81 03              [ 2 ] LA3C2     CMPA #3             ; BREAK KEY?
0381 c166 1a 01              [ 3 ]           ORCC #1             ; SET CARRY FLAG
0382 c168 27 05              [ 3 ]           BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
0383 c16a 81 0d              [ 2 ] LA3C8     CMPA #CR            ; ENTER KEY?
0384 c16c 26 0d              [ 3 ]           BNE  LA3D9          ; NO
0385 c16e 4f                 [ 2 ] LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
0386 c16f 34 01              [ 6 ] LA3CD     PSHS CC             ; SAVE CARRY FLAG
0387 c171 bd d0 a8           [ 8 ]           JSR  LB958          ; SEND CR TO SCREEN
0388 c174 6f 84              [ 6 ]           CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
0389 c176 8e 00 f3           [ 3 ]           LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
0390 c179 35 81              [ 8 ]           PULS CC,PC          ; RESTORE CARRY FLAG
0391                               
0392                               * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
0393 c17b 81 20              [ 2 ] LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
0394 c17d 25 c9              [ 3 ]           BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
0395 c17f 81 7b              [ 2 ]           CMPA #'z+1          ; *
0396 c181 24 c5              [ 3 ]           BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
0397 c183 c1 fa              [ 2 ]           CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
0398 c185 24 c1              [ 3 ]           BCC  LA39A          ; YES, IGNORE ANY MORE
0399 c187 a7 80              [ 6 ]           STA  ,X+            ; PUT IT IN INPUT BUFFER
0400 c189 5c                 [ 2 ]           INCB                ; INCREMENT CHARACTER COUNTER
0401 c18a bd c0 17           [ 8 ] LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
0402 c18d 20 b9              [ 3 ]           BRA  LA39A          ; GO SET SOME MORE
0403                               
0404                               
0405                               * EXEC
0406 c18f 27 05              [ 3 ] EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
0407 c191 bd ce c4           [ 8 ]           JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
0408 c194 9f 7a              [ 5 ]           STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
0409 c196 6e 9f 00 7a        [ 8 ] LA545     JMP  [EXECJP]       ; GO DO IT
0410                               
0411                               * BREAK CHECK
0412 c19a 7e c5 a6           [ 4 ] LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
0413                               
0414                               * INKEY$
0415 c19d 96 73              [ 4 ] INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
0416 c19f 26 03              [ 3 ]           BNE  LA56B          ; YES
0417 c1a1 bd c0 08           [ 8 ]           JSR  KEYIN          ; GO GET A KEY
0418 c1a4 0f 73              [ 6 ] LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
0419 c1a6 97 53              [ 4 ]           STA  FPA0+3         ; STORE THE KEY IN FPA0
0420 c1a8 10 26 0c 6a        [ 6 ]           LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
0421 c1ac 97 56              [ 4 ]           STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
0422 c1ae 7e ce 22           [ 4 ]           JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
0423                               
0424                               * MOVE ACCB BYTES FROM (X) TO (U)
0425 c1b1 a6 80              [ 6 ] LA59A     LDA  ,X+            ; GET BYTE FROM X
0426 c1b3 a7 c0              [ 6 ]           STA  ,U+            ; STORE IT AT U
0427 c1b5 5a                 [ 2 ]           DECB                ; MOVED ALL BYTES?
0428 c1b6 26 f9              [ 3 ]           BNE  LA59A          ; NO
0429 c1b8 39                 [ 5 ] LA5A1     RTS
0430                               
0431 c1b9 39                 [ 5 ] LA5C4     RTS
0432                               
0433                               ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
0434                               ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
0435                               ** FOLLOWING THE END OF THE NAME
0436 c1ba 9d 82              [ 7 ] LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
0437 c1bc 27 fb              [ 3 ] LA5C9     BEQ  LA5C4          ; RETURN IF END OF LINE
0438 c1be 7e ca 03           [ 4 ]           JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
0439                               * IRQ SERVICE
0440                               BIRQSV
0441 c1c1 3b                 [15 ] LA9C5     RTI                 ; RETURN FROM INTERRUPT
0442                               
0443                               * SET CARRY IF NUMERIC - RETURN WITH
0444                               * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
0445                               * OF BASIC LINE OR SUB LINE
0446 c1c2 81 3a              [ 2 ] BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
0447 c1c4 24 0a              [ 3 ]           BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
0448 c1c6 81 20              [ 2 ]           CMPA #SPACE         ; SPACE?
0449 c1c8 26 02              [ 3 ]           BNE  LAA24          ; NO - SET CARRY IF NUMERIC
0450 c1ca 0e 7c              [ 3 ]           JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
0451 c1cc 80 30              [ 2 ] LAA24     SUBA #'0            ; * SET CARRY IF
0452 c1ce 80 d0              [ 2 ]           SUBA #-'0           ; * CHARACTER > ASCII 0
0453 c1d0 39                 [ 5 ] LAA28     RTS
0454                               
0455                               * DISPATCH TABLE FOR SECONDARY FUNCTIONS
0456                               * TOKENS ARE PRECEEDED BY $FF
0457                               * FIRST SET ALWAYS HAS ONE PARAMETER
0458                               FUNC_TAB
0459 c1d1 d3 c6                    LAA29     FDB  SGN            ; SGN
0460 c1d3 d4 3a                              FDB  INT            ; INT
0461 c1d5 d3 df                              FDB  ABS            ; ABS
0462 c1d7 00 ad                              FDB  USRJMP         ; USR
0463 0083                          TOK_USR   EQU  *-FUNC_TAB/2+$7F
0464 ff83                          TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
0465 c1d9 d6 6b                              FDB  RND            ; RND
0466 c1db d6 c0                              FDB  SIN            ; SIN
0467 c1dd ce d7                              FDB  PEEK           ; PEEK
0468 c1df ce 08                              FDB  LEN            ; LEN
0469 c1e1 cc 84                              FDB  STR            ; STR$
0470 c1e3 ce 9d                              FDB  VAL            ; VAL
0471 c1e5 ce 27                              FDB  ASC            ; ASC
0472 c1e7 ce 13                              FDB  CHR            ; CHR$
0473 c1e9 d7 70                              FDB  ATN            ; ATN
0474 c1eb d7 38                              FDB  COS            ; COS
0475 c1ed d7 41                              FDB  TAN            ; TAN
0476 c1ef d8 b2                              FDB  EXP            ; EXP
0477 c1f1 d8 e4                              FDB  FIX            ; FIX
0478 c1f3 d8 06                              FDB  LOG            ; LOG
0479 c1f5 da 6c                              FDB  POS            ; POS
0480 c1f7 d8 40                              FDB  SQR            ; SQR
0481 c1f9 df 3e                              FDB  HEXDOL         ; HEX$
0482                               * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0483 c1fb ce 32                              FDB  LEFT           ; LEFT$
0484 0095                          TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
0485 c1fd ce 4f                              FDB  RIGHT          ; RIGHT$
0486 c1ff ce 56                              FDB  MID            ; MID$
0487 0097                          TOK_MID   EQU  *-FUNC_TAB/2+$7F
0488                               * REMAINING FUNCTIONS
0489 c201 c1 9d                              FDB  INKEY          ; INKEY$
0490 0098                          TOK_INKEY EQU  *-FUNC_TAB/2+$7F
0491 c203 cc 75                              FDB  MEM            ; MEM
0492 c205 da 74                              FDB  VARPT          ; VARPTR
0493 c207 db 34                              FDB  INSTR          ; INSTR
0494 c209 db 04                              FDB  STRING         ; STRING$
0495 001d                          NUM_SEC_FNS EQU  *-FUNC_TAB/2
0496                               
0497                               * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
0498                               * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
0499                               * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
0500                               * EXPRESSION EVALUATION ROUTINE. THEY ARE:
0501                               * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
0502                               * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
0503                               * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
0504                               *
0505 c20b 79                       LAA51     FCB  $79
0506 c20c d1 11                              FDB  LB9C5          ; +
0507 c20e 79                                 FCB  $79
0508 c20f d1 08                              FDB  LB9BC          ; -
0509 c211 7b                                 FCB  $7B
0510 c212 d2 18                              FDB  LBACC          ; *
0511 c214 7b                                 FCB  $7B
0512 c215 d2 dd                              FDB  LBB91          ; /
0513 c217 7f                                 FCB  $7F
0514 c218 d8 49                              FDB  L8489          ; EXPONENTIATION
0515 c21a 50                                 FCB  $50
0516 c21b ca 5c                              FDB  LB2D5          ; AND
0517 c21d 46                                 FCB  $46
0518 c21e ca 5b                              FDB  LB2D4          ; OR
0519                               
0520                               * THIS IS THE RESERVED WORD TABLE
0521                               * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
0522 c220 46 4f                    LAA66     FCC  "FO"           ; 80
0523 c222 d2                                 FCB  $80+'R
0524 c223 47                                 FCC  "G"            ; 81
0525 c224 cf                                 FCB  $80+'O
0526 0081                          TOK_GO    EQU  $81
0527 c225 52 45                              FCC  "RE"           ; 82
0528 c227 cd                                 FCB  $80+'M
0529 c228 a7                                 FCB  ''+$80         ; 83
0530 c229 45 4c 53                           FCC  "ELS"          ; 84
0531 c22c c5                                 FCB  $80+'E
0532 c22d 49                                 FCC  "I"            ; 85
0533 c22e c6                                 FCB  $80+'F
0534 c22f 44 41 54                           FCC  "DAT"          ; 86
0535 c232 c1                                 FCB  $80+'A
0536 c233 50 52 49 4e                        FCC  "PRIN"         ; 87
0537 c237 d4                                 FCB  $80+'T
0538 c238 4f                                 FCC  "O"            ; 88
0539 c239 ce                                 FCB  $80+'N
0540 c23a 49 4e 50 55                        FCC  "INPU"         ; 89
0541 c23e d4                                 FCB  $80+'T
0542 c23f 45 4e                              FCC  "EN"           ; 8A
0543 c241 c4                                 FCB  $80+'D
0544 c242 4e 45 58                           FCC  "NEX"          ; 8B
0545 c245 d4                                 FCB  $80+'T
0546 c246 44 49                              FCC  "DI"           ; 8C
0547 c248 cd                                 FCB  $80+'M
0548 c249 52 45 41                           FCC  "REA"          ; 8D
0549 c24c c4                                 FCB  $80+'D
0550 c24d 52 55                              FCC  "RU"           ; 8E
0551 c24f ce                                 FCB  $80+'N
0552 c250 52 45 53 54 4f 52                  FCC  "RESTOR"       ; 8F
0553 c256 c5                                 FCB  $80+'E
0554 c257 52 45 54 55 52                     FCC  "RETUR"        ; 90
0555 c25c ce                                 FCB  $80+'N
0556 c25d 53 54 4f                           FCC  "STO"          ; 91
0557 c260 d0                                 FCB  $80+'P
0558 c261 50 4f 4b                           FCC  "POK"          ; 92
0559 c264 c5                                 FCB  $80+'E
0560 c265 43 4f 4e                           FCC  "CON"          ; 93
0561 c268 d4                                 FCB  $80+'T
0562 c269 4c 49 53                           FCC  "LIS"          ; 94
0563 c26c d4                                 FCB  $80+'T
0564 c26d 43 4c 45 41                        FCC  "CLEA"         ; 95
0565 c271 d2                                 FCB  $80+'R
0566 c272 4e 45                              FCC  "NE"           ; 96
0567 c274 d7                                 FCB  $80+'W
0568 c275 45 58 45                           FCC  "EXE"          ; 97
0569 c278 c3                                 FCB  $80+'C
0570 c279 54 52 4f                           FCC  "TRO"          ; 98
0571 c27c ce                                 FCB  $80+'N
0572 c27d 54 52 4f 46                        FCC  "TROF"         ; 99
0573 c281 c6                                 FCB  $80+'F
0574 c282 44 45                              FCC  "DE"           ; 9A
0575 c284 cc                                 FCB  $80+'L
0576 c285 44 45                              FCC  "DE"           ; 9B
0577 c287 c6                                 FCB  $80+'F
0578 c288 4c 49 4e                           FCC  "LIN"          ; 9C
0579 c28b c5                                 FCB  $80+'E
0580 c28c 52 45 4e 55                        FCC  "RENU"         ; 9D
0581 c290 cd                                 FCB  $80+'M
0582 c291 45 44 49                           FCC  "EDI"          ; 9E
0583 c294 d4                                 FCB  $80+'T
0584                               * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
0585 c295 54 41 42                           FCC  "TAB"          ; 9F
0586 c298 a8                                 FCB  $80+'(
0587 009f                          TOK_TAB   EQU  $9F
0588 c299 54                                 FCC  "T"            ; A0
0589 c29a cf                                 FCB  $80+'O
0590 00a0                          TOK_TO    EQU  $A0
0591 c29b 53 55                              FCC  "SU"           ; A1
0592 c29d c2                                 FCB  $80+'B
0593 00a1                          TOK_SUB   EQU  $A1
0594 c29e 54 48 45                           FCC  "THE"          ; A2
0595 c2a1 ce                                 FCB  $80+'N
0596 00a2                          TOK_THEN  EQU  $A2
0597 c2a2 4e 4f                              FCC  "NO"           ; A3
0598 c2a4 d4                                 FCB  $80+'T
0599 00a3                          TOK_NOT   EQU  $A3
0600 c2a5 53 54 45                           FCC  "STE"          ; A4
0601 c2a8 d0                                 FCB  $80+'P
0602 00a4                          TOK_STEP  EQU  $A4
0603 c2a9 4f 46                              FCC  "OF"           ; A5
0604 c2ab c6                                 FCB  $80+'F
0605 c2ac ab                                 FCB  '++$80         ; A6
0606 00a6                          TOK_PLUS  EQU  $A6
0607 c2ad ad                                 FCB  '-+$80         ; A7
0608 00a7                          TOK_MINUS EQU  $A7
0609 c2ae aa                                 FCB  '*+$80         ; A8
0610 c2af af                                 FCB  '/+$80         ; A9
0611 c2b0 de                                 FCB  '^+$80         ; AA
0612 c2b1 41 4e                              FCC  "AN"           ; AB
0613 c2b3 c4                                 FCB  $80+'D
0614 c2b4 4f                                 FCC  "O"            ; AC
0615 c2b5 d2                                 FCB  $80+'R
0616 c2b6 be                                 FCB  '>+$80         ; AD
0617 00ad                          TOK_GREATER EQU  $AD
0618 c2b7 bd                                 FCB  '=+$80         ; AE
0619 00ae                          TOK_EQUALS EQU  $AE
0620 c2b8 bc                                 FCB  '<+$80         ; AF
0621 c2b9 46                                 FCC  "F"            ; B0
0622 c2ba ce                                 FCB  $80+'N
0623 00b0                          TOK_FN    EQU  $B0
0624 c2bb 55 53 49 4e                        FCC  "USIN"         ; B1
0625 c2bf c7                                 FCB  $80+'G
0626 00b1                          TOK_USING EQU  $B1
0627                               *
0628                               
0629                               * FIRST SET ALWAYS HAS ONE PARAMETER
0630 c2c0 53 47                    LAB1A     FCC  "SG"           ; 80
0631 c2c2 ce                                 FCB  $80+'N
0632 c2c3 49 4e                              FCC  "IN"           ; 81
0633 c2c5 d4                                 FCB  $80+'T
0634 c2c6 41 42                              FCC  "AB"           ; 82
0635 c2c8 d3                                 FCB  $80+'S
0636 c2c9 55 53                              FCC  "US"           ; 83
0637 c2cb d2                                 FCB  $80+'R
0638 c2cc 52 4e                              FCC  "RN"           ; 84
0639 c2ce c4                                 FCB  $80+'D
0640 c2cf 53 49                              FCC  "SI"           ; 85
0641 c2d1 ce                                 FCB  $80+'N
0642 c2d2 50 45 45                           FCC  "PEE"          ; 86
0643 c2d5 cb                                 FCB  $80+'K
0644 c2d6 4c 45                              FCC  "LE"           ; 87
0645 c2d8 ce                                 FCB  $80+'N
0646 c2d9 53 54 52                           FCC  "STR"          ; 88
0647 c2dc a4                                 FCB  $80+'$
0648 c2dd 56 41                              FCC  "VA"           ; 89
0649 c2df cc                                 FCB  $80+'L
0650 c2e0 41 53                              FCC  "AS"           ; 8A
0651 c2e2 c3                                 FCB  $80+'C
0652 c2e3 43 48 52                           FCC  "CHR"          ; 8B
0653 c2e6 a4                                 FCB  $80+'$
0654 c2e7 41 54                              FCC  "AT"           ; 8C
0655 c2e9 ce                                 FCB  $80+'N
0656 c2ea 43 4f                              FCC  "CO"           ; 8D
0657 c2ec d3                                 FCB  $80+'S
0658 c2ed 54 41                              FCC  "TA"           ; 8E
0659 c2ef ce                                 FCB  $80+'N
0660 c2f0 45 58                              FCC  "EX"           ; 8F
0661 c2f2 d0                                 FCB  $80+'P
0662 c2f3 46 49                              FCC  "FI"           ; 90
0663 c2f5 d8                                 FCB  $80+'X
0664 c2f6 4c 4f                              FCC  "LO"           ; 91
0665 c2f8 c7                                 FCB  $80+'G
0666 c2f9 50 4f                              FCC  "PO"           ; 92
0667 c2fb d3                                 FCB  $80+'S
0668 c2fc 53 51                              FCC  "SQ"           ; 93
0669 c2fe d2                                 FCB  $80+'R
0670 c2ff 48 45 58                           FCC  "HEX"          ; 94
0671 c302 a4                                 FCB  $80+'$
0672                               * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0673 c303 4c 45 46 54                        FCC  "LEFT"         ; 95
0674 c307 a4                                 FCB  $80+'$
0675 c308 52 49 47 48 54                     FCC  "RIGHT"        ; 96
0676 c30d a4                                 FCB  $80+'$
0677 c30e 4d 49 44                           FCC  "MID"          ; 97
0678 c311 a4                                 FCB  $80+'$
0679                               * REMAINING FUNCTIONS
0680 c312 49 4e 4b 45 59                     FCC  "INKEY"        ; 98
0681 c317 a4                                 FCB  $80+'$
0682 c318 4d 45                              FCC  "ME"           ; 99
0683 c31a cd                                 FCB  $80+'M
0684 c31b 56 41 52 50 54                     FCC  "VARPT"        ; 9A
0685 c320 d2                                 FCB  $80+'R
0686 c321 49 4e 53 54                        FCC  "INST"         ; 9B
0687 c325 d2                                 FCB  $80+'R
0688 c326 53 54 52 49 4e 47                  FCC  "STRING"       ; 9C
0689 c32c a4                                 FCB  $80+'$
0690                               
0691                               *
0692                               * DISPATCH TABLE FOR COMMANDS TOKEN #
0693                               CMD_TAB
0694 c32d c4 eb                    LAB67     FDB  FOR            ; 80
0695 c32f c6 36                              FDB  GO             ; 81
0696 c331 c6 93                              FDB  REM            ; 82
0697 0082                          TOK_REM   EQU  *-CMD_TAB/2+$7F
0698 c333 c6 93                              FDB  REM            ; 83 (')
0699 0083                          TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
0700 c335 c6 93                              FDB  REM            ; 84 (ELSE)
0701 0084                          TOK_ELSE  EQU  *-CMD_TAB/2+$7F
0702 c337 c6 c4                              FDB  IF             ; 85
0703 0085                          TOK_IF    EQU  *-CMD_TAB/2+$7F
0704 c339 c6 90                              FDB  DATA           ; 86
0705 0086                          TOK_DATA  EQU  *-CMD_TAB/2+$7F
0706 c33b d0 6d                              FDB  PRINT          ; 87
0707 0087                          TOK_PRINT EQU  *-CMD_TAB/2+$7F
0708 c33d c6 f2                              FDB  ON             ; 88
0709 c33f c7 9f                              FDB  INPUT          ; 89
0710 0089                          TOK_INPUT EQU  *-CMD_TAB/2+$7F
0711 c341 c5 bd                              FDB  END            ; 8A
0712 c343 c8 84                              FDB  NEXT           ; 8B
0713 c345 ca d5                              FDB  DIM            ; 8C
0714 c347 c7 d9                              FDB  READ           ; 8D
0715 c349 c6 2b                              FDB  RUN            ; 8E
0716 c34b c5 9f                              FDB  RESTOR         ; 8F
0717 c34d c6 70                              FDB  RETURN         ; 90
0718 c34f c5 c1                              FDB  STOP           ; 91
0719 c351 ce de                              FDB  POKE           ; 92
0720 c353 c5 e6                              FDB  CONT           ; 93
0721 c355 ce e5                              FDB  LIST           ; 94
0722 c357 c5 f7                              FDB  CLEAR          ; 95
0723 c359 c4 bb                              FDB  NEW            ; 96
0724 c35b c1 8f                              FDB  EXEC           ; 97
0725 c35d da 67                              FDB  TRON           ; 98
0726 c35f da 68                              FDB  TROFF          ; 99
0727 c361 dc e3                              FDB  DEL            ; 9A
0728 c363 dc 27                              FDB  DEF            ; 9B
0729 c365 e3 d1                              FDB  LINE           ; 9C
0730 c367 dd 6d                              FDB  RENUM          ; 9D
0731 c369 d8 f3                              FDB  EDIT           ; 9E
0732 009e                          TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
0733                               
0734                               * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
0735 c36b 4e 46                    LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
0736 c36d 53 4e                              FCC  "SN"           ; 1 SYNTAX ERROR
0737 c36f 52 47                              FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
0738 c371 4f 44                              FCC  "OD"           ; 3 OUT OF DATA
0739 c373 46 43                              FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
0740 c375 4f 56                              FCC  "OV"           ; 5 OVERFLOW
0741 c377 4f 4d                              FCC  "OM"           ; 6 OUT OF MEMORY
0742 c379 55 4c                              FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
0743 c37b 42 53                              FCC  "BS"           ; 8 BAD SUBSCRIPT
0744 c37d 44 44                              FCC  "DD"           ; 9 REDIMENSIONED ARRAY
0745 c37f 2f 30                              FCC  "/0"           ; 10 DIVISION BY ZERO
0746 c381 49 44                              FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
0747 c383 54 4d                              FCC  "TM"           ; 12 TYPE MISMATCH
0748 c385 4f 53                              FCC  "OS"           ; 13 OUT OF STRING SPACE
0749 c387 4c 53                              FCC  "LS"           ; 14 STRING TOO LONG
0750 c389 53 54                              FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
0751 c38b 43 4e                              FCC  "CN"           ; 16 CAN'T CONTINUE
0752 c38d 46 44                              FCC  "FD"           ; 17 BAD FILE DATA
0753 c38f 41 4f                              FCC  "AO"           ; 18 FILE ALREADY OPEN
0754 c391 44 4e                              FCC  "DN"           ; 19 DEVICE NUMBER ERROR
0755 c393 49 4f                              FCC  "IO"           ; 20 I/O ERROR
0756 c395 46 4d                              FCC  "FM"           ; 21 BAD FILE MODE
0757 c397 4e 4f                              FCC  "NO"           ; 22 FILE NOT OPEN
0758 c399 49 45                              FCC  "IE"           ; 23 INPUT PAST END OF FILE
0759 c39b 44 53                              FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
0760                               * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
0761 c39d 55 46                    L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
0762 c39f 4e 45                    L890D     FCC  "NE"           ; 26 FILE NOT FOUND
0763                               
0764 c3a1 20 45 52 52 4f 52        LABE1     FCC  " ERROR"
0765 c3a7 00                                 FCB  $00
0766 c3a8 20 49 4e 20              LABE8     FCC  " IN "
0767 c3ac 00                                 FCB  $00
0768 c3ad 0d                       LABED     FCB  CR
0769 c3ae 4f 4b                    LABEE     FCC  "OK"
0770 c3b0 0d 00                              FCB  CR,$00
0771 c3b2 0d                       LABF2     FCB  CR
0772 c3b3 42 52 45 41 4b                     FCC  "BREAK"
0773 c3b8 00                                 FCB  $00
0774                               
0775                               * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
0776                               * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
0777                               * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
0778                               * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
0779                               * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
0780                               * IS CONSIDERED 'GOSUB/RETURN'
0781 c3b9 30 64              [ 5 ] LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
0782                               *         FIRST TWO RETURN ADDRESSES ON THE STACK
0783 c3bb c6 12              [ 2 ] LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
0784 c3bd 9f 0f              [ 5 ]           STX  TEMPTR         ; SAVE POINTER
0785 c3bf a6 84              [ 4 ]           LDA  ,X             ; GET 1ST BYTE
0786 c3c1 80 80              [ 2 ]           SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
0787 c3c3 26 15              [ 3 ]           BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
0788 c3c5 ae 01              [ 6 ]           LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
0789 c3c7 9f 11              [ 5 ]           STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
0790 c3c9 9e 3b              [ 5 ]           LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
0791 c3cb 27 09              [ 3 ]           BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
0792                               *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
0793                               *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
0794 c3cd 9c 11              [ 6 ]           CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
0795                               *                             ; BEING SEARCHED FOR?
0796 c3cf 27 09              [ 3 ]           BEQ  LAC1A          ; YES
0797 c3d1 9e 0f              [ 5 ]           LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
0798 c3d3 3a                 [ 3 ]           ABX                 ; * 18 TO IT AND LOOK FOR
0799 c3d4 20 e5              [ 3 ]           BRA  LABFB          ; * NEXT BLOCK OF DATA
0800 c3d6 9e 11              [ 5 ] LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
0801 c3d8 9f 3b              [ 5 ]           STX  VARDES         ; = SAVE AS 'NEXT' INDEX
0802 c3da 9e 0f              [ 5 ] LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
0803 c3dc 4d                 [ 2 ]           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
0804 c3dd 39                 [ 5 ]           RTS
0805                               * CHECK FOR MEMORY SPACE FOR NEW TOP OF
0806                               * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
0807 c3de 8d 17              [ 7 ] LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
0808                               *                             ; ROOM FOR THE STACK?
0809                               * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
0810                               * SAVE FINAL VALUE OF U IN V45
0811 c3e0 de 41              [ 5 ] LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
0812 c3e2 33 41              [ 5 ]           LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
0813 c3e4 9e 43              [ 5 ]           LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
0814 c3e6 30 01              [ 5 ]           LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
0815 c3e8 a6 82              [ 6 ] LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
0816 c3ea 36 02              [ 6 ]           PSHU A              ; MOVE IT TO DESTINATION
0817 c3ec 9c 47              [ 6 ]           CMPX V47            ; DONE?
0818 c3ee 26 f8              [ 3 ]           BNE  LAC28          ; NO - KEEP MOVING BYTES
0819 c3f0 df 45              [ 5 ]           STU  V45            ; SAVE FINAL DESTINATION ADDRESS
0820 c3f2 39                 [ 5 ] LAC32     RTS
0821                               * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
0822                               * BYTES IN FREE RAM - OM ERROR IF NOT
0823 c3f3 4f                 [ 2 ] LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
0824 c3f4 58                 [ 2 ]           ASLB                ; * BYTES TO PUT ON STACK
0825 c3f5 d3 1f              [ 6 ]           ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
0826 c3f7 c3 00 3a           [ 4 ] LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
0827 c3fa 25 08              [ 3 ]           BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
0828 c3fc 10 df 17           [ 6 ]           STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
0829 c3ff 10 93 17           [ 7 ]           CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
0830 c402 25 ee              [ 3 ]           BCS  LAC32          ; YES - NO ERROR
0831 c404 c6 0c              [ 2 ] LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
0832                               
0833                               * ERROR SERVICING ROUTINE
0834 c406 bd c4 d7           [ 8 ] LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
0835 c409 bd d0 ac           [ 8 ]           JSR  LB95C          ; SEND A CR TO SCREEN
0836 c40c bd d0 fb           [ 8 ]           JSR  LB9AF          ; SEND A '?' TO SCREEN
0837 c40f 8e c3 6b           [ 3 ]           LDX  #LABAF         ; POINT TO ERROR TABLE
0838 c412 3a                 [ 3 ] LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
0839 c413 8d 31              [ 7 ]           BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
0840 c415 8d 2f              [ 7 ]           BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
0841 c417 8e c3 a0           [ 3 ]           LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
0842 c41a bd d0 e8           [ 8 ] LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
0843 c41d 96 68              [ 4 ]           LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
0844 c41f 4c                 [ 2 ]           INCA                ; TEST FOR DIRECT MODE
0845 c420 27 03              [ 3 ]           BEQ  LAC73          ; BRANCH IF DIRECT MODE
0846 c422 bd d5 11           [ 8 ]           JSR  LBDC5          ; PRINT 'IN ****'
0847                               
0848                               * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
0849 c425 bd d0 ac           [ 8 ] LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
0850 c428 8e c3 ad           [ 3 ]           LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
0851 c42b bd d0 e8           [ 8 ]           JSR  LB99C          ; PRINT 'OK', CR
0852 c42e bd c1 41           [ 8 ] LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
0853 c431 ce ff ff           [ 3 ]           LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
0854 c434 df 68              [ 5 ]           STU  CURLIN         ; SAVE IT IN CURLIN
0855 c436 25 f6              [ 3 ]           BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
0856 c438 9f 83              [ 5 ]           STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
0857                               *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
0858                               *         LINE JUST ENTERED WILL BE INTERPRETED
0859 c43a 9d 7c              [ 7 ]           JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
0860 c43c 27 f0              [ 3 ]           BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
0861 c43e 25 0b              [ 3 ]           BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
0862                               *         THE  STATEMENT ENTERED, SO THIS STATEMENT
0863                               *         WILL BE MERGED INTO THE BASIC PROGRAM
0864 c440 bd cf 9a           [ 8 ]           JSR  LB821          ; GO CRUNCH LINE
0865 c443 7e c5 74           [ 4 ]           JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
0866                               *
0867 c446 a6 80              [ 6 ] LACA0     LDA  ,X+            ; GET A CHARACTER
0868 c448 7e d0 fd           [ 4 ]           JMP  LB9B1          ; SEND TO CONSOLE OUT
0869                               * TAKE A LINE FROM THE LINE INPUT BUFFER
0870                               * AND INSERT IT INTO THE BASIC PROGRAM
0871 c44b bd c7 17           [ 8 ] LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
0872 c44e 9e 2b              [ 5 ] LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
0873 c450 9f f1              [ 5 ]           STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
0874 c452 bd cf 9a           [ 8 ]           JSR  LB821          ; GO CRUNCH THE LINE
0875 c455 d7 03              [ 4 ]           STB  TMPLOC         ; SAVE LINE LENGTH
0876 c457 8d 4c              [ 7 ]           BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
0877 c459 25 12              [ 3 ]           BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
0878 c45b dc 47              [ 5 ]           LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
0879 c45d a3 84              [ 6 ]           SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
0880 c45f d3 1b              [ 6 ]           ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
0881 c461 dd 1b              [ 5 ]           STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
0882 c463 ee 84              [ 5 ]           LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
0883                               * DELETE OLD LINE FROM BASIC PROGRAM
0884 c465 37 02              [ 6 ] LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
0885 c467 a7 80              [ 6 ]           STA  ,X+            ; MOVE IT DOWN
0886 c469 9c 1b              [ 6 ]           CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
0887 c46b 26 f8              [ 3 ]           BNE  LACC0          ; BRANCH IF NOT AT END
0888 c46d 96 f3              [ 4 ] LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
0889 c46f 27 1c              [ 3 ]           BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
0890 c471 dc 1b              [ 5 ]           LDD  VARTAB         ; = SAVE CURRENT END OF
0891 c473 dd 43              [ 5 ]           STD  V43            ; = PROGRAM IN V43
0892 c475 db 03              [ 4 ]           ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
0893 c477 89 00              [ 2 ]           ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
0894 c479 dd 41              [ 5 ]           STD  V41            ; * OF PROGRAM IN V41
0895 c47b bd c3 de           [ 8 ]           JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
0896                               *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
0897 c47e ce 00 ef           [ 3 ]           LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
0898 c481 37 02              [ 6 ] LACDD     PULU A              ; GET A BYTE FROM NEW LINE
0899 c483 a7 80              [ 6 ]           STA  ,X+            ; INSERT IT IN PROGRAM
0900 c485 9c 45              [ 6 ]           CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
0901 c487 26 f8              [ 3 ]           BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
0902 c489 9e 41              [ 5 ]           LDX  V41            ; = GET AND SAVE
0903 c48b 9f 1b              [ 5 ]           STX  VARTAB         ; = END OF PROGRAM
0904 c48d 8d 36              [ 7 ] LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
0905 c48f 8d 02              [ 7 ]           BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
0906 c491 20 9b              [ 3 ]           BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
0907                               * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
0908 c493 9e 19              [ 5 ] LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
0909 c495 ec 84              [ 5 ] LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
0910 c497 27 21              [ 3 ]           BEQ  LAD16          ; RETURN IF END OF PROGRAM
0911 c499 33 04              [ 5 ]           LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
0912 c49b a6 c0              [ 6 ] LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
0913 c49d 26 fc              [ 3 ]           BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
0914 c49f ef 84              [ 5 ]           STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
0915 c4a1 ae 84              [ 5 ]           LDX  ,X             ; POINT X TO START OF NEXT LINE
0916 c4a3 20 f0              [ 3 ]           BRA  LACF1          ; KEEP GOING
0917                               *
0918                               * FIND A LINE NUMBER IN THE BASIC PROGRAM
0919                               * RETURN WITH CARRY SET IF NO MATCH FOUND
0920 c4a5 dc 2b              [ 5 ] LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
0921 c4a7 9e 19              [ 5 ]           LDX  TXTTAB         ; BEGINNING OF PROGRAM
0922 c4a9 ee 84              [ 5 ] LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
0923 c4ab 27 09              [ 3 ]           BEQ  LAD12          ; BRANCH IF END OF PROG
0924 c4ad 10 a3 02           [ 8 ]           CMPD 2,X            ; IS IT A MATCH?
0925 c4b0 23 06              [ 3 ]           BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
0926 c4b2 ae 84              [ 5 ]           LDX  ,X             ; X = ADDRESS OF NEXT LINE
0927 c4b4 20 f3              [ 3 ]           BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
0928 c4b6 1a 01              [ 3 ] LAD12     ORCC #1             ; SET CARRY FLAG
0929 c4b8 9f 47              [ 5 ] LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
0930                               *                             ; WHERE IT SHOULD HAVE BEEN
0931 c4ba 39                 [ 5 ] LAD16     RTS
0932                               
0933                               * NEW
0934 c4bb 26 fb              [ 3 ] NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
0935 c4bd 9e 19              [ 5 ] LAD19     LDX  TXTTAB         ; GET START OF BASIC
0936 c4bf 6f 80              [ 8 ]           CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
0937 c4c1 6f 80              [ 8 ]           CLR  ,X+            ; * THE BASIC PROGRAM
0938 c4c3 9f 1b              [ 5 ]           STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
0939 c4c5 9e 19              [ 5 ] LAD21     LDX  TXTTAB         ; GET START OF BASIC
0940 c4c7 bd c6 6b           [ 8 ]           JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
0941                               * ERASE ALL VARIABLES
0942 c4ca 9e 27              [ 5 ] LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
0943 c4cc 9f 23              [ 5 ]           STX  STRTAB         ; * TO TOP OF STRING SPACE
0944 c4ce bd c5 9f           [ 8 ]           JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
0945 c4d1 9e 1b              [ 5 ]           LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
0946 c4d3 9f 1d              [ 5 ]           STX  ARYTAB         ; * TO RESET START OF ARRAYS
0947 c4d5 9f 1f              [ 5 ]           STX  ARYEND         ; RESET END OF ARRAYS
0948 c4d7 8e 00 c9           [ 3 ] LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
0949 c4da 9f 0b              [ 5 ]           STX  TEMPPT         ; * BOTTOM OF STRING STACK
0950 c4dc ae e4              [ 5 ]           LDX  ,S             ; GET RETURN ADDRESS OFF STACK
0951 c4de 10 de 21           [ 6 ]           LDS  FRETOP         ; RESTORE STACK POINTER
0952 c4e1 6f e2              [ 8 ]           CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
0953                               *                             ; FOR/NEXT DATA FROM THE STACK
0954 c4e3 0f 2d              [ 6 ]           CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
0955 c4e5 0f 2e              [ 6 ]           CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
0956 c4e7 0f 08              [ 6 ]           CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
0957 c4e9 6e 84              [ 3 ]           JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
0958                               *                             ; SINCE THE STACK WAS RESET
0959                               *
0960                               * FOR
0961                               *
0962                               * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
0963                               * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
0964                               * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
0965                               *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
0966                               *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
0967                               * 9-13=FP VALUE OF 'TO' PARAMETER;
0968                               * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
0969                               *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
0970 c4eb 86 80              [ 2 ] FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
0971 c4ed 97 08              [ 4 ]           STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
0972 c4ef bd c7 39           [ 8 ]           JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
0973 c4f2 bd c3 b9           [ 8 ]           JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
0974 c4f5 32 62              [ 5 ]           LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
0975 c4f7 26 04              [ 3 ]           BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
0976 c4f9 9e 0f              [ 5 ]           LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
0977 c4fb 32 85              [ 5 ]           LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
0978                               * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
0979                               * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
0980                               * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
0981                               * THIS POINT ON THE STACK
0982 c4fd c6 09              [ 2 ] LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
0983 c4ff bd c3 f3           [ 8 ]           JSR  LAC33          ; * IN FREE RAM
0984 c502 bd c6 98           [ 8 ]           JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
0985 c505 dc 68              [ 5 ]           LDD  CURLIN         ; GET CURRENT LINE NUMBER
0986 c507 34 16              [ 9 ]           PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
0987 c509 c6 a0              [ 2 ]           LDB  #TOK_TO        ; TOKEN FOR 'TO'
0988 c50b bd c9 fb           [ 8 ]           JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
0989 c50e bd c8 cf           [ 8 ]           JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
0990 c511 bd c8 cd           [ 8 ]           JSR  LB141          ; EVALUATE EXPRESSION
0991                               *
0992 c514 d6 54              [ 4 ]           LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
0993 c516 ca 7f              [ 2 ]           ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
0994 c518 d4 50              [ 4 ]           ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
0995 c51a d7 50              [ 4 ]           STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
0996 c51c 10 8e c5 23        [ 4 ]           LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
0997 c520 7e c9 76           [ 4 ]           JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
0998 c523 8e d2 11           [ 3 ] LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
0999 c526 bd d3 60           [ 8 ]           JSR  LBC14          ; MOVE (X) TO FPA0
1000 c529 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1001 c52b 81 a4              [ 2 ]           CMPA #TOK_STEP      ; STEP TOKEN
1002 c52d 26 05              [ 3 ]           BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
1003 c52f 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1004 c531 bd c8 cd           [ 8 ]           JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1005 c534 bd d3 b9           [ 8 ] LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
1006 c537 bd c9 72           [ 8 ]           JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
1007 c53a dc 3b              [ 5 ]           LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
1008 c53c 34 06              [ 7 ]           PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
1009 c53e 86 80              [ 2 ]           LDA  #$80           ; = GET THE 'FOR' FLAG AND
1010 c540 34 02              [ 6 ]           PSHS A              ; = SAVE IT ON THE STACK
1011                               *
1012                               * MAIN COMMAND INTERPRETATION LOOP
1013 c542 1c af              [ 3 ] LAD9E     ANDCC #$AF          ; ENABLE IRQ,FIRQ
1014 c544 8d 60              [ 7 ]           BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
1015 c546 9e 83              [ 5 ]           LDX  CHARAD         ; GET BASIC'S INPUT POINTER
1016 c548 9f 2f              [ 5 ]           STX  TINPTR         ; SAVE IT
1017 c54a a6 80              [ 6 ]           LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
1018 c54c 27 07              [ 3 ]           BEQ  LADB4          ; BRANCH IF END OF LINE
1019 c54e 81 3a              [ 2 ]           CMPA #':            ; CHECK FOR LINE SEPARATOR
1020 c550 27 22              [ 3 ]           BEQ  LADC0          ; BRANCH IF COLON
1021 c552 7e ca 03           [ 4 ] LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
1022 c555 a6 81              [ 7 ] LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
1023 c557 97 00              [ 4 ]           STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
1024                               *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
1025                               *                             ; AN END IF ADDRESS > $8000
1026 c559 27 72              [ 3 ]           BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
1027 c55b ec 80              [ 7 ]           LDD  ,X+            ; GET CURRENT LINE NUMBER
1028 c55d dd 68              [ 5 ]           STD  CURLIN         ; SAVE IN CURLIN
1029 c55f 9f 83              [ 5 ]           STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
1030                               * EXTENDED BASIC TRACE
1031 c561 96 8c              [ 4 ]           LDA  TRCFLG         ; TEST THE TRACE FLAG
1032 c563 27 0f              [ 3 ]           BEQ  LADC0          ; BRANCH IF TRACE OFF
1033 c565 86 5b              [ 2 ]           LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
1034 c567 bd c0 17           [ 8 ]           JSR  PUTCHR         ; OUTPUT A CHARACTER
1035 c56a 96 68              [ 4 ]           LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
1036 c56c bd d5 18           [ 8 ]           JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
1037 c56f 86 5d              [ 2 ]           LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
1038 c571 bd c0 17           [ 8 ]           JSR  PUTCHR         ; OUTPUT A CHARACTER
1039                               * END OF EXTENDED BASIC TRACE
1040 c574 9d 7c              [ 7 ] LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1041 c576 8d 02              [ 7 ]           BSR  LADC6          ; GO PROCESS COMMAND
1042 c578 20 c8              [ 3 ]           BRA  LAD9E          ; GO BACK TO MAIN LOOP
1043 c57a 27 29              [ 3 ] LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
1044 c57c 4d                 [ 2 ]           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
1045 c57d 10 2a 01 b8        [ 6 ]           LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
1046                               *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
1047 c581 81 ff              [ 2 ]           CMPA #$FF           ; SECONDARY TOKEN
1048 c583 27 0f              [ 3 ]           BEQ  SECTOK
1049 c585 81 9e              [ 2 ]           CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
1050 c587 22 c9              [ 3 ]           BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
1051 c589 be c0 f4           [ 6 ]           LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
1052 c58c 48                 [ 2 ] LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
1053 c58d 1f 89              [ 6 ]           TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
1054 c58f 3a                 [ 3 ]           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
1055 c590 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHAR
1056                               *
1057                               * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
1058 c592 6e 94              [ 6 ]           JMP  [,X]           ; GO DO A COMMAND
1059                               SECTOK
1060                               * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
1061                               * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
1062 c594 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHAR
1063 c596 81 97              [ 2 ]           CMPA #TOK_MID       ; TOKEN FOR "MID$"
1064 c598 10 27 14 f0        [ 6 ]           LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
1065 c59c 7e ca 03           [ 4 ]           JMP  LB277          ; SYNTAX ERROR
1066                               
1067                               *
1068                               * RESTORE
1069 c59f 9e 19              [ 5 ] RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
1070 c5a1 30 1f              [ 5 ]           LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
1071 c5a3 9f 33              [ 5 ] LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
1072 c5a5 39                 [ 5 ] LADEA     RTS
1073                               *
1074                               * BREAK CHECK
1075 c5a6 bd c0 08           [ 8 ] LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
1076 c5a9 27 0a              [ 3 ]           BEQ  LADFA          ; RETURN IF NO INPUT
1077 c5ab 81 03              [ 2 ] LADF0     CMPA #3             ; CONTROL C? (BREAK)
1078 c5ad 27 12              [ 3 ]           BEQ  STOP           ; YES
1079 c5af 81 13              [ 2 ]           CMPA #$13           ; CONTROL S? (PAUSE)
1080 c5b1 27 03              [ 3 ]           BEQ  LADFB          ; YES
1081 c5b3 97 73              [ 4 ]           STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
1082 c5b5 39                 [ 5 ] LADFA     RTS
1083 c5b6 bd c0 08           [ 8 ] LADFB     JSR  KEYIN          ; GET A KEY
1084 c5b9 27 fb              [ 3 ]           BEQ  LADFB          ; BRANCH IF NO KEY DOWN
1085 c5bb 20 ee              [ 3 ]           BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
1086                               *
1087                               * END
1088 c5bd 9d 82              [ 7 ] END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
1089 c5bf 20 02              [ 3 ]           BRA  LAE0B
1090                               *
1091                               * STOP
1092 c5c1 1a 01              [ 3 ] STOP      ORCC #$01           ; SET CARRY FLAG
1093 c5c3 26 31              [ 3 ] LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
1094 c5c5 9e 83              [ 5 ]           LDX  CHARAD         ; * SAVE CURRENT POSITION OF
1095 c5c7 9f 2f              [ 5 ]           STX  TINPTR         ; * BASIC'S INPUT POINTER
1096 c5c9 06 00              [ 6 ] LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
1097 c5cb 32 62              [ 5 ]           LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
1098 c5cd 9e 68              [ 5 ] LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
1099 c5cf 8c ff ff           [ 4 ]           CMPX #$FFFF         ; DIRECT MODE?
1100 c5d2 27 06              [ 3 ]           BEQ  LAE22          ; YES
1101 c5d4 9f 29              [ 5 ]           STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
1102 c5d6 9e 2f              [ 5 ]           LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
1103 c5d8 9f 2d              [ 5 ]           STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
1104                               LAE22
1105 c5da 8e c3 b1           [ 3 ]           LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
1106 c5dd 0d 00              [ 6 ]           TST  ENDFLG         ; CHECK STOP/END FLAG
1107 c5df 10 2a fe 42        [ 6 ]           LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
1108 c5e3 7e c4 1a           [ 4 ]           JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
1109                               *                             ; BASIC'S MAIN LOOP IF 'STOP'
1110                               
1111                               * CONT
1112 c5e6 26 0e              [ 3 ] CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
1113 c5e8 c6 20              [ 2 ]           LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
1114 c5ea 9e 2d              [ 5 ]           LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
1115 c5ec 10 27 fe 16        [ 6 ]           LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
1116 c5f0 9f 83              [ 5 ]           STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1117 c5f2 9e 29              [ 5 ]           LDX  OLDTXT         ; GET LINE NUMBER
1118 c5f4 9f 68              [ 5 ]           STX  CURLIN         ; RESET CURRENT LINE NUMBER
1119 c5f6 39                 [ 5 ] LAE40     RTS
1120                               *
1121                               * CLEAR
1122 c5f7 27 2c              [ 3 ] CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
1123 c5f9 bd cb 6d           [ 8 ]           JSR  LB3E6          ; EVALUATE ARGUMENT
1124 c5fc 34 06              [ 7 ]           PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
1125 c5fe 9e 27              [ 5 ]           LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
1126 c600 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1127 c602 27 0c              [ 3 ]           BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
1128 c604 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1129 c607 bd ce c4           [ 8 ]           JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
1130 c60a 30 1f              [ 5 ]           LEAX -1,X           ; X = TOP OF CLEARED SPACE
1131 c60c 9c 71              [ 6 ]           CMPX TOPRAM         ; COMPARE TO TOP OF RAM
1132 c60e 22 18              [ 3 ]           BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
1133 c610 1f 10              [ 6 ] LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
1134 c612 a3 e1              [ 9 ]           SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
1135 c614 25 12              [ 3 ]           BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1136 c616 1f 03              [ 6 ]           TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
1137 c618 83 00 3a           [ 4 ]           SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
1138 c61b 25 0b              [ 3 ]           BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1139 c61d 93 1b              [ 6 ]           SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
1140 c61f 25 07              [ 3 ]           BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1141 c621 df 21              [ 5 ]           STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
1142 c623 9f 27              [ 5 ]           STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
1143 c625 7e c4 ca           [ 4 ] LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
1144 c628 7e c4 04           [ 4 ] LAE72     JMP  LAC44          ; 'OM' ERROR
1145                               *
1146                               * RUN
1147 c62b 9d 82              [ 7 ] RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
1148 c62d 10 27 fe 94        [ 6 ]           LBEQ LAD21          ; * IF NO LINE NUMBER
1149 c631 bd c4 ca           [ 8 ]           JSR  LAD26          ; ERASE ALL VARIABLES
1150 c634 20 19              [ 3 ]           BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
1151                               *
1152                               * GO
1153 c636 1f 89              [ 6 ] GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
1154 c638 9d 7c              [ 7 ] LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1155 c63a c1 a0              [ 2 ]           CMPB #TOK_TO        ; 'TO' TOKEN
1156 c63c 27 16              [ 3 ]           BEQ  LAEA4          ; BRANCH IF GOTO
1157 c63e c1 a1              [ 2 ]           CMPB #TOK_SUB       ; 'SUB' TOKEN
1158 c640 26 45              [ 3 ]           BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
1159 c642 c6 03              [ 2 ]           LDB  #3             ; =ROOM FOR 6
1160 c644 bd c3 f3           [ 8 ]           JSR  LAC33          ; =BYTES ON STACK?
1161 c647 de 83              [ 5 ]           LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
1162 c649 9e 68              [ 5 ]           LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
1163 c64b 86 a1              [ 2 ]           LDA  #TOK_SUB       ; *
1164 c64d 34 52              [10 ]           PSHS U,X,A          ; *
1165 c64f 8d 03              [ 7 ] LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
1166 c651 7e c5 42           [ 4 ]           JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
1167                               * GOTO
1168 c654 9d 82              [ 7 ] LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
1169 c656 bd c7 17           [ 8 ]           JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
1170 c659 8d 40              [ 7 ]           BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
1171 c65b 30 01              [ 5 ]           LEAX $01,X          ; POINT TO START OF NEXT LINE
1172 c65d dc 2b              [ 5 ]           LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
1173 c65f 10 93 68           [ 7 ]           CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
1174 c662 22 02              [ 3 ]           BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
1175                               *              ; DON'T START LOOKING FROM
1176                               *              ; START OF PROGRAM
1177 c664 9e 19              [ 5 ]           LDX  TXTTAB         ; BEGINNING OF PROGRAM
1178 c666 bd c4 a9           [ 8 ] LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
1179 c669 25 17              [ 3 ]           BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
1180 c66b 30 1f              [ 5 ] LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
1181 c66d 9f 83              [ 5 ]           STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1182 c66f 39                 [ 5 ] LAEBF     RTS
1183                               *
1184                               * RETURN
1185 c670 26 fd              [ 3 ] RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
1186 c672 86 ff              [ 2 ]           LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
1187 c674 97 3b              [ 4 ]           STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
1188                               *              ; STACK TO BE IGNORED
1189 c676 bd c3 b9           [ 8 ]           JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
1190 c679 1f 14              [ 6 ]           TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
1191                               *              ; FROM THE STACK
1192 c67b 81 21              [ 2 ]           CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
1193 c67d 27 0b              [ 3 ]           BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
1194 c67f c6 04              [ 2 ]           LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
1195 c681 8c                                 FCB  SKP2           ; SKIP TWO BYTES
1196 c682 c6 0e              [ 2 ] LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
1197 c684 7e c4 06           [ 4 ]           JMP  LAC46          ; JUMP TO ERROR HANDLER
1198 c687 7e ca 03           [ 4 ] LAED7     JMP  LB277          ; 'SYNTAX ERROR'
1199 c68a 35 52              [10 ] LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
1200 c68c 9f 68              [ 5 ]           STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
1201 c68e df 83              [ 5 ]           STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
1202                               *
1203                               * DATA
1204 c690 8d 06              [ 7 ] DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
1205 c692 8c                                 FCB  SKP2           ; SKIP 2 BYTES
1206                               
1207                               * REM, ELSE
1208                               ELSE
1209 c693 8d 06              [ 7 ] REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
1210 c695 9f 83              [ 5 ]           STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1211 c697 39                 [ 5 ] LAEE7     RTS
1212                               * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
1213 c698 c6 3a              [ 2 ] LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
1214 c69a 86                       LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
1215                               * ADVANCE BASIC'S INPUT POINTER TO END OF
1216                               * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
1217 c69b 5f                 [ 2 ] LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
1218 c69c d7 01              [ 4 ]           STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
1219 c69e 5f                 [ 2 ]           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
1220 c69f 9e 83              [ 5 ]           LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
1221 c6a1 1f 98              [ 6 ] LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
1222 c6a3 d6 01              [ 4 ]           LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
1223                               *         IN   CHARAC
1224 c6a5 97 01              [ 4 ]           STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
1225 c6a7 a6 84              [ 4 ] LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
1226 c6a9 27 ec              [ 3 ]           BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
1227 c6ab 34 04              [ 6 ]           PSHS B              ; SAVE TERMINATOR ON STACK
1228 c6ad a1 e0              [ 6 ]           CMPA ,S+            ; COMPARE TO INPUT CHARACTER
1229 c6af 27 e6              [ 3 ]           BEQ  LAEE7          ; RETURN IF EQUAL
1230 c6b1 30 01              [ 5 ]           LEAX 1,X            ; MOVE POINTER UP ONE
1231 c6b3 81 22              [ 2 ]           CMPA #'"            ; CHECK FOR DOUBLE QUOTES
1232 c6b5 27 ea              [ 3 ]           BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
1233 c6b7 4c                 [ 2 ]           INCA                ; * CHECK FOR $FF AND BRANCH IF
1234 c6b8 26 02              [ 3 ]           BNE  LAF0C          ; * NOT SECONDARY TOKEN
1235 c6ba 30 01              [ 5 ]           LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
1236 c6bc 81 86              [ 2 ] LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
1237 c6be 26 e7              [ 3 ]           BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
1238 c6c0 0c 04              [ 6 ]           INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
1239                               *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
1240 c6c2 20 e3              [ 3 ]           BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
1241                               
1242                               * IF
1243 c6c4 bd c8 cd           [ 8 ] IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1244 c6c7 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1245 c6c9 81 81              [ 2 ]           CMPA #TOK_GO        ; TOKEN FOR GO
1246 c6cb 27 05              [ 3 ]           BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
1247 c6cd c6 a2              [ 2 ]           LDB  #TOK_THEN      ; TOKEN FOR THEN
1248 c6cf bd c9 fb           [ 8 ]           JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
1249 c6d2 96 4f              [ 4 ] LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
1250 c6d4 26 13              [ 3 ]           BNE  LAF39          ; BRANCH IF CONDITION TRUE
1251 c6d6 0f 04              [ 6 ]           CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
1252                               *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
1253 c6d8 8d b6              [ 7 ] LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
1254 c6da 4d                 [ 2 ]           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
1255 c6db 27 ba              [ 3 ]           BEQ  LAEE7          ; * AND RETURN IF END OF LINE
1256 c6dd 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1257 c6df 81 84              [ 2 ]           CMPA #TOK_ELSE      ; TOKEN FOR ELSE
1258 c6e1 26 f5              [ 3 ]           BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
1259                               *                             ; END OF LINE (ZERO BYTE)
1260 c6e3 0a 04              [ 6 ]           DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
1261 c6e5 2a f1              [ 3 ]           BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
1262 c6e7 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1263 c6e9 9d 82              [ 7 ] LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1264 c6eb 10 25 ff 65        [ 6 ]           LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
1265 c6ef 7e c5 7a           [ 4 ]           JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
1266                               
1267                               * ON
1268 c6f2 bd ce 92           [ 8 ] ON        JSR  LB70B          ; EVALUATE EXPRESSION
1269 c6f5 c6 81              [ 2 ]           LDB  #TOK_GO        ; TOKEN FOR GO
1270 c6f7 bd c9 fb           [ 8 ]           JSR  LB26F          ; SYNTAX CHECK FOR GO
1271 c6fa 34 02              [ 6 ]           PSHS A              ; SAVE NEW TOKEN (TO,SUB)
1272 c6fc 81 a1              [ 2 ]           CMPA #TOK_SUB       ; TOKEN FOR SUB?
1273 c6fe 27 04              [ 3 ]           BEQ  LAF54          ; YES
1274 c700 81 a0              [ 2 ]           CMPA #TOK_TO        ; TOKEN FOR TO?
1275 c702 26 83              [ 3 ] LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
1276 c704 0a 53              [ 6 ] LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
1277                               *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
1278 c706 26 05              [ 3 ]           BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
1279 c708 35 04              [ 6 ]           PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
1280 c70a 7e c6 38           [ 4 ]           JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
1281 c70d 9d 7c              [ 7 ] LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1282 c70f 8d 06              [ 7 ]           BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
1283 c711 81 2c              [ 2 ]           CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
1284 c713 27 ef              [ 3 ]           BEQ  LAF54          ; YES
1285 c715 35 84              [ 8 ]           PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
1286 c717 9e 74              [ 5 ] LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
1287 c719 9f 2b              [ 5 ]           STX  BINVAL         ; SAVE IT IN BINVAL
1288                               *
1289                               * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
1290                               *
1291 c71b 24 61              [ 3 ] LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
1292 c71d 80 30              [ 2 ]           SUBA #'0            ; MASK OFF ASCII
1293 c71f 97 01              [ 4 ]           STA  CHARAC         ; SAVE DIGIT IN VO1
1294 c721 dc 2b              [ 5 ]           LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
1295 c723 81 18              [ 2 ]           CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
1296                               *         (24*256+255)*10+9
1297 c725 22 db              [ 3 ]           BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
1298                               * MULT ACCD X 10
1299 c727 58                 [ 2 ]           ASLB                ; *
1300 c728 49                 [ 2 ]           ROLA                ; * TIMES 2
1301 c729 58                 [ 2 ]           ASLB                ; =
1302 c72a 49                 [ 2 ]           ROLA                ; = TIMES 4
1303 c72b d3 2b              [ 6 ]           ADDD BINVAL         ; ADD 1 = TIMES 5
1304 c72d 58                 [ 2 ]           ASLB                ; *
1305 c72e 49                 [ 2 ]           ROLA                ; * TIMES 10
1306 c72f db 01              [ 4 ]           ADDB CHARAC         ; ADD NEXT DIGIT
1307 c731 89 00              [ 2 ]           ADCA #0             ; PROPAGATE CARRY
1308 c733 dd 2b              [ 5 ]           STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
1309 c735 9d 7c              [ 7 ]           JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1310 c737 20 e2              [ 3 ]           BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
1311                               *
1312                               * LET (EXBAS)
1313                               * EVALUATE A NON-TOKEN EXPRESSION
1314                               * TARGET = REPLACEMENT
1315 c739 bd ca de           [ 8 ] LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
1316 c73c 9f 3b              [ 5 ]           STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
1317 c73e c6 ae              [ 2 ]           LDB  #TOK_EQUALS    ; TOKEN FOR "="
1318 c740 bd c9 fb           [ 8 ]           JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
1319 c743 96 06              [ 4 ]           LDA  VALTYP         ; * GET VARIABLE TYPE AND
1320 c745 34 02              [ 6 ]           PSHS A              ; * SAVE ON THE STACK
1321 c747 bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSION
1322 c74a 35 02              [ 6 ]           PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
1323 c74c 46                 [ 2 ]           RORA                ; * SET CARRY IF STRING
1324 c74d bd c8 d4           [ 8 ]           JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
1325                               *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
1326 c750 10 27 0c 2b        [ 6 ]           LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
1327                               * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
1328                               * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
1329                               * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
1330                               * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
1331                               * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
1332                               * STACK IF IT IS LAST ONE ON THE STACK
1333 c754 9e 52              [ 5 ] LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
1334 c756 dc 21              [ 5 ]           LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
1335 c758 10 a3 02           [ 8 ]           CMPD 2,X            ; IS THE STRING IN STRING SPACE?
1336 c75b 24 11              [ 3 ]           BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
1337 c75d 9c 1b              [ 6 ]           CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
1338 c75f 25 0d              [ 3 ]           BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
1339 c761 e6 84              [ 4 ] LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
1340 c763 bd cc 94           [ 8 ]           JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
1341 c766 9e 4d              [ 5 ]           LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
1342 c768 bd cd ca           [ 8 ]           JSR  LB643          ; MOVE STRING INTO STRING SPACE
1343 c76b 8e 00 56           [ 3 ]           LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
1344 c76e 9f 4d              [ 5 ] LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
1345 c770 bd cd fc           [ 8 ]           JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
1346                               *              ; ON STRING STACK
1347 c773 de 4d              [ 5 ]           LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
1348 c775 9e 3b              [ 5 ]           LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
1349 c777 37 26              [ 9 ]           PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
1350 c779 a7 84              [ 4 ]           STA  ,X             ; * SAVE STRING LENGTH AND START IN
1351 c77b 10 af 02           [ 7 ]           STY  2,X            ; * TARGET DESCRIPTOR LOCATION
1352 c77e 39                 [ 5 ] LAFCE     RTS
1353                               
1354 c77f 3f 52 45 44 4f           LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
1355 c784 0d 00                              FCB  CR,$00
1356                               
1357                               LAFD6
1358 c786 7e c4 06           [ 4 ] LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
1359 c789 96 09              [ 4 ] LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
1360 c78b 27 07              [ 3 ]           BEQ  LAFEA          ; = IF 'INPUT'
1361 c78d 9e 31              [ 5 ]           LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
1362 c78f 9f 68              [ 5 ]           STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
1363 c791 7e ca 03           [ 4 ]           JMP  LB277          ; 'SYNTAX ERROR'
1364 c794 8e c7 7e           [ 3 ] LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
1365 c797 bd d0 e8           [ 8 ]           JSR  LB99C          ; * IT ON THE SCREEN
1366 c79a 9e 2f              [ 5 ]           LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
1367 c79c 9f 83              [ 5 ]           STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
1368 c79e 39                 [ 5 ]           RTS
1369                               *
1370                               * INPUT
1371 c79f c6 16              [ 2 ] INPUT     LDB  #11*2          ; 'ID' ERROR
1372 c7a1 9e 68              [ 5 ]           LDX  CURLIN         ; GET CURRENT LINE NUMBER
1373 c7a3 30 01              [ 5 ]           LEAX 1,X            ; ADD ONE
1374 c7a5 27 df              [ 3 ]           BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
1375 c7a7 8d 01              [ 7 ]           BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
1376 c7a9 39                 [ 5 ]           RTS
1377 c7aa 81 22              [ 2 ] LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
1378 c7ac 26 0b              [ 3 ]           BNE  LB01E          ; BRANCH IF NO PROMPT STRING
1379 c7ae bd c9 d0           [ 8 ]           JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
1380 c7b1 c6 3b              [ 2 ]           LDB  #';            ; *
1381 c7b3 bd c9 fb           [ 8 ]           JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
1382 c7b6 bd d0 eb           [ 8 ]           JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
1383 c7b9 8e 00 f3           [ 3 ] LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
1384 c7bc 6f 84              [ 6 ]           CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
1385                               *              ; IN LINE BUFFER
1386 c7be 8d 06              [ 7 ]           BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
1387 c7c0 c6 2c              [ 2 ]           LDB  #',            ; * INSERT A COMMA AT THE END
1388 c7c2 e7 84              [ 4 ]           STB  ,X             ; * OF THE LINE INPUT BUFFER
1389 c7c4 20 16              [ 3 ]           BRA  LB049
1390                               * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
1391 c7c6 bd d0 fb           [ 8 ] LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
1392 c7c9 bd d0 f8           [ 8 ]           JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
1393 c7cc bd c1 41           [ 8 ] LB035     JSR  LA390          ; GO READ IN A BASIC LINE
1394 c7cf 24 05              [ 3 ]           BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
1395 c7d1 32 64              [ 5 ]           LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
1396 c7d3 7e c5 c9           [ 4 ]           JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
1397 c7d6 c6 2e              [ 2 ] LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
1398 c7d8 39                 [ 5 ]           RTS
1399                               *
1400                               * READ
1401 c7d9 9e 33              [ 5 ] READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
1402 c7db 86                                 FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
1403 c7dc 4f                 [ 2 ] LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
1404 c7dd 97 09              [ 4 ]           STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
1405 c7df 9f 35              [ 5 ]           STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
1406 c7e1 bd ca de           [ 8 ] LB04E     JSR  LB357          ; EVALUATE A VARIABLE
1407 c7e4 9f 3b              [ 5 ]           STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
1408 c7e6 9e 83              [ 5 ]           LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
1409 c7e8 9f 2b              [ 5 ]           STX  BINVAL         ; * AND SAVE IT
1410 c7ea 9e 35              [ 5 ]           LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
1411 c7ec a6 84              [ 4 ]           LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
1412 c7ee 26 09              [ 3 ]           BNE  LB069          ; BRANCH IF NOT END OF LINE
1413 c7f0 96 09              [ 4 ]           LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
1414 c7f2 26 51              [ 3 ]           BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
1415                               * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
1416                               * NOT COMING FROM SCREEN
1417 c7f4 bd d0 fb           [ 8 ]           JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
1418 c7f7 8d cd              [ 7 ]           BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
1419 c7f9 9f 83              [ 5 ] LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1420 c7fb 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1421 c7fd d6 06              [ 4 ]           LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
1422 c7ff 27 23              [ 3 ]           BEQ  LB098          ; * BRANCH IF NUMERIC
1423                               * READ/INPUT A STRING VARIABLE
1424 c801 9e 83              [ 5 ]           LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
1425 c803 97 01              [ 4 ]           STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
1426 c805 81 22              [ 2 ]           CMPA #'"            ; CHECK FOR STRING DELIMITER
1427 c807 27 0e              [ 3 ]           BEQ  LB08B          ; BRANCH IF STRING DELIMITER
1428 c809 30 1f              [ 5 ]           LEAX -1,X           ; BACK UP POINTER
1429 c80b 4f                 [ 2 ]           CLRA                ; * ZERO = END OF LINE CHARACTER
1430 c80c 97 01              [ 4 ]           STA  CHARAC         ; * SAVE AS TERMINATOR
1431 c80e bd c1 33           [ 8 ]           JSR  LA35F          ; SET UP PRINT PARAMETERS
1432 c811 86 3a              [ 2 ]           LDA  #':            ; END OF SUBLINE CHARACTER
1433 c813 97 01              [ 4 ]           STA  CHARAC         ; SAVE AS TERMINATOR I
1434 c815 86 2c              [ 2 ]           LDA  #',            ; COMMA
1435 c817 97 02              [ 4 ] LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
1436 c819 bd cc a5           [ 8 ]           JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
1437 c81c bd c9 d5           [ 8 ]           JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
1438 c81f bd c7 54           [ 8 ]           JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
1439 c822 20 06              [ 3 ]           BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
1440                               * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
1441 c824 bd d4 5e           [ 8 ] LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
1442 c827 bd d3 7f           [ 8 ]           JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
1443                               *                             ; INPUT OR READ DATA ITEM
1444 c82a 9d 82              [ 7 ] LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1445 c82c 27 06              [ 3 ]           BEQ  LB0A8          ; BRANCH IF END OF LINE
1446 c82e 81 2c              [ 2 ]           CMPA #',            ; CHECK FOR A COMMA
1447 c830 10 26 ff 52        [ 6 ]           LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
1448 c834 9e 83              [ 5 ] LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
1449 c836 9f 35              [ 5 ]           STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
1450 c838 9e 2b              [ 5 ]           LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
1451 c83a 9f 83              [ 5 ]           STX  CHARAD         ; * READ STATEMENT
1452 c83c 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
1453 c83e 27 21              [ 3 ]           BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
1454 c840 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1455 c843 20 9c              [ 3 ]           BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
1456                               * SEARCH FROM ADDRESS IN X FOR
1457                               * 1ST OCCURENCE OF THE TOKEN FOR DATA
1458 c845 9f 83              [ 5 ] LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1459 c847 bd c6 98           [ 8 ]           JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
1460 c84a 30 01              [ 5 ]           LEAX 1,X            ; MOVE X ONE PAST END OF LINE
1461 c84c 4d                 [ 2 ]           TSTA                ; CHECK FOR END OF LINE
1462 c84d 26 0a              [ 3 ]           BNE  LB0CD          ; BRANCH IF END OF SUBLINE
1463 c84f c6 06              [ 2 ]           LDB  #2*3           ; 'OUT OF DATA' ERROR
1464 c851 ee 81              [ 8 ]           LDU  ,X++           ; GET NEXT 2 CHARACTERS
1465 c853 27 41              [ 3 ]           BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
1466 c855 ec 81              [ 8 ]           LDD  ,X++           ; GET BASIC LINE NUMBER AND
1467 c857 dd 31              [ 5 ]           STD  DATTXT         ; SAVE IT IN DATTXT
1468 c859 a6 84              [ 4 ] LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
1469 c85b 81 86              [ 2 ]           CMPA #TOK_DATA      ; DATA TOKEN?
1470 c85d 26 e6              [ 3 ]           BNE  LB0B9          ; NO - KEEP LOOKING
1471 c85f 20 98              [ 3 ]           BRA  LB069          ; YES
1472                               * EXIT READ AND INPUT COMMANDS
1473 c861 9e 35              [ 5 ] LB0D5     LDX  DATTMP         ; GET DATA POINTER
1474 c863 d6 09              [ 4 ]           LDB  INPFLG         ; * CHECK INPUT FLAG
1475 c865 10 26 fd 3a        [ 6 ]           LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
1476 c869 a6 84              [ 4 ]           LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
1477 c86b 27 06              [ 3 ]           BEQ  LB0E7          ; =
1478 c86d 8e c8 73           [ 3 ]           LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
1479 c870 7e d0 e8           [ 4 ]           JMP  LB99C          ; PRINT THE MESSAGE
1480 c873 39                 [ 5 ] LB0E7     RTS
1481                               
1482 c874 3f 45 58 54 52 41        LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
1483                               
1484                               
1485 c882 0d 00                              FCB  CR,$00
1486                               
1487                               * NEXT
1488 c884 26 04              [ 3 ] NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
1489 c886 9e 74              [ 5 ]           LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
1490 c888 20 03              [ 3 ]           BRA  LB101
1491 c88a bd ca de           [ 8 ] LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
1492 c88d 9f 3b              [ 5 ] LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
1493 c88f bd c3 b9           [ 8 ]           JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
1494 c892 27 04              [ 3 ]           BEQ  LB10C          ; BRANCH IF DATA FOUND
1495 c894 c6 00              [ 2 ]           LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
1496 c896 20 47              [ 3 ] LB10A     BRA  LB153          ; PROCESS ERROR
1497 c898 1f 14              [ 6 ] LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
1498 c89a 30 03              [ 5 ]           LEAX 3,X            ; POINT X TO FP VALUE OF STEP
1499 c89c bd d3 60           [ 8 ]           JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1500 c89f a6 68              [ 5 ]           LDA  8,S            ; GET THE DIRECTION OF STEP
1501 c8a1 97 54              [ 4 ]           STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
1502 c8a3 9e 3b              [ 5 ]           LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
1503 c8a5 bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
1504 c8a8 bd d3 7f           [ 8 ]           JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
1505                               *                             ; CONTAINED IN VARDES
1506 c8ab 30 69              [ 5 ]           LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
1507 c8ad bd d3 e2           [ 8 ]           JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
1508 c8b0 e0 68              [ 5 ]           SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
1509                               *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
1510                               *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
1511 c8b2 27 0c              [ 3 ]           BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
1512 c8b4 ae 6e              [ 6 ]           LDX  14,S           ; * GET LINE NUMBER AND
1513 c8b6 9f 68              [ 5 ]           STX  CURLIN         ; * BASIC POINTER OF
1514 c8b8 ae e8 10           [ 6 ]           LDX  16,S           ; * STATEMENT FOLLOWING THE
1515 c8bb 9f 83              [ 5 ]           STX  CHARAD         ; * PROPER FOR STATEMENT
1516 c8bd 7e c5 42           [ 4 ] LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
1517 c8c0 32 e8 12           [ 5 ] LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
1518 c8c3 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1519 c8c5 81 2c              [ 2 ]           CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
1520 c8c7 26 f4              [ 3 ]           BNE  LB131          ; RETURN IF NONE
1521 c8c9 9d 7c              [ 7 ]           JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1522 c8cb 8d bd              [ 7 ]           BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
1523                               
1524                               
1525 c8cd 8d 13              [ 7 ] LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
1526 c8cf 1c fe              [ 3 ] LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
1527 c8d1 7d                       LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
1528                               *              ; NOT CHANGE CARRY FLAG)
1529 c8d2 1a 01              [ 3 ] LB146     ORCC #1             ; SET CARRY
1530                               
1531                               * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
1532                               * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
1533                               * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
1534                               * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
1535                               * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
1536 c8d4 0d 06              [ 6 ] LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
1537 c8d6 25 03              [ 3 ]           BCS  LB14F          ; BRANCH IF STRING
1538 c8d8 2a 99              [ 3 ]           BPL  LB0E7          ; RETURN ON PLUS
1539 c8da 8c                                 FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
1540 c8db 2b 96              [ 3 ] LB14F     BMI  LB0E7          ; RETURN ON MINUS
1541 c8dd c6 18              [ 2 ]           LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
1542 c8df 7e c4 06           [ 4 ] LB153     JMP  LAC46          ; PROCESS ERROR
1543                               * EVALUATE EXPRESSION
1544 c8e2 8d 6e              [ 7 ] LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
1545 c8e4 4f                 [ 2 ] LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
1546 c8e5 8c                                 FCB  SKP2           ; SKIP TWO BYTES
1547 c8e6 34 04              [ 6 ] LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
1548 c8e8 34 02              [ 6 ]           PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
1549 c8ea c6 01              [ 2 ]           LDB  #1             ; *
1550 c8ec bd c3 f3           [ 8 ]           JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
1551 c8ef bd c9 af           [ 8 ]           JSR  LB223          ; GO EVALUATE AN EXPRESSION
1552 c8f2 0f 3f              [ 6 ]           CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
1553 c8f4 9d 82              [ 7 ] LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1554                               * CHECK FOR RELATIONAL OPERATORS
1555 c8f6 80 ad              [ 2 ] LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
1556 c8f8 25 13              [ 3 ]           BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
1557 c8fa 81 03              [ 2 ]           CMPA #3             ; *
1558 c8fc 24 0f              [ 3 ]           BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
1559 c8fe 81 01              [ 2 ]           CMPA #1             ; SET CARRY IF '>'
1560 c900 49                 [ 2 ]           ROLA                ; CARRY TO BIT 0
1561 c901 98 3f              [ 4 ]           EORA TRELFL         ; * CARRY SET IF
1562 c903 91 3f              [ 4 ]           CMPA TRELFL         ; * TRELFL = ACCA
1563 c905 25 64              [ 3 ]           BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
1564 c907 97 3f              [ 4 ]           STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
1565 c909 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHARACTER
1566 c90b 20 e9              [ 3 ]           BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
1567                               *
1568 c90d d6 3f              [ 4 ] LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
1569 c90f 26 33              [ 3 ]           BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
1570 c911 10 24 00 6b        [ 6 ]           LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
1571 c915 8b 07              [ 2 ]           ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
1572 c917 24 67              [ 3 ]           BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
1573 c919 99 06              [ 4 ]           ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
1574 c91b 10 27 04 77        [ 6 ]           LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
1575                               *                             ; CONCATENATE TWO STRINGS
1576 c91f 89 ff              [ 2 ]           ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
1577 c921 34 02              [ 6 ]           PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
1578 c923 48                 [ 2 ]           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
1579 c924 ab e0              [ 6 ]           ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
1580 c926 8e c2 0b           [ 3 ]           LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
1581 c929 30 86              [ 5 ]           LEAX A,X            ; POINT X TO PROPER TABLE
1582 c92b 35 02              [ 6 ] LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
1583 c92d a1 84              [ 4 ]           CMPA ,X             ; COMPARE TO CURRENT OPERATOR
1584 c92f 24 55              [ 3 ]           BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
1585 c931 8d 9c              [ 7 ]           BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1586                               
1587                               * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
1588 c933 34 02              [ 6 ] LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
1589 c935 8d 29              [ 7 ]           BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
1590 c937 9e 3d              [ 5 ]           LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
1591                               *                             ; LAST CALCULATED OPERATION
1592 c939 35 02              [ 6 ]           PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
1593 c93b 26 1d              [ 3 ]           BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
1594 c93d 4d                 [ 2 ]           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
1595 c93e 10 27 00 6a        [ 6 ]           LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
1596 c942 20 4b              [ 3 ]           BRA  LB203          ; EVALUATE AN OPERATION
1597                               
1598 c944 08 06              [ 6 ] LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
1599 c946 59                 [ 2 ]           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
1600 c947 8d 09              [ 7 ]           BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
1601 c949 8e c9 57           [ 3 ]           LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
1602 c94c d7 3f              [ 4 ]           STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
1603 c94e 0f 06              [ 6 ]           CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1604 c950 20 d9              [ 3 ]           BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
1605                               
1606 c952 9e 83              [ 5 ] LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
1607 c954 7e c6 6b           [ 4 ]           JMP  LAEBB          ; * MOVE IT BACK ONE
1608                               * RELATIONAL COMPARISON JUMP TABLE
1609 c957 64                       LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
1610 c958 ca 7b                    LB1CC     FDB  LB2F4          ; JUMP ADDRESS
1611                               
1612 c95a a1 84              [ 4 ] LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
1613                               *         NEXT TO BE DONE OPERATION
1614 c95c 24 31              [ 3 ]           BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
1615 c95e 20 d3              [ 3 ]           BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
1616                               
1617                               * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
1618 c960 ec 01              [ 6 ] LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
1619 c962 34 06              [ 7 ]           PSHS B,A            ; SAVE IT ON THE STACK
1620 c964 8d 08              [ 7 ]           BSR  LB1E2          ; PUSH FPA0 ONTO STACK
1621 c966 d6 3f              [ 4 ]           LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
1622 c968 16 ff 7b           [ 5 ]           LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
1623 c96b 7e ca 03           [ 4 ] LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
1624                               * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
1625                               * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
1626                               * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
1627 c96e d6 54              [ 4 ] LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
1628 c970 a6 84              [ 4 ]           LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
1629 c972 35 20              [ 7 ] LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
1630 c974 34 04              [ 6 ]           PSHS B              ; SAVE ACCB ON STACK
1631 c976 d6 4f              [ 4 ] LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
1632 c978 9e 50              [ 5 ]           LDX  FPA0           ; *
1633 c97a de 52              [ 5 ]           LDU  FPA0+2         ; *
1634 c97c 34 54              [10 ]           PSHS U,X,B          ; *
1635 c97e 6e a4              [ 3 ]           JMP  ,Y             ; JUMP TO ADDRESS IN Y
1636                               
1637                               * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
1638 c980 9e 74              [ 5 ] LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
1639 c982 a6 e0              [ 6 ]           LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
1640 c984 27 26              [ 3 ]           BEQ  LB220          ; BRANCH IF END OF EXPRESSION
1641 c986 81 64              [ 2 ] LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
1642 c988 27 03              [ 3 ]           BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
1643 c98a bd c8 cf           [ 8 ]           JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1644 c98d 9f 3d              [ 5 ] LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
1645 c98f 35 04              [ 6 ] LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
1646 c991 81 5a              [ 2 ]           CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
1647 c993 27 19              [ 3 ]           BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
1648 c995 81 7d              [ 2 ]           CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
1649 c997 27 15              [ 3 ]           BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
1650                               
1651                               * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
1652                               * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
1653                               * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
1654                               * TO EVALUATING ROUTINE.
1655 c999 54                 [ 2 ]           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
1656 c99a d7 0a              [ 4 ]           STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
1657 c99c 35 52              [10 ]           PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
1658 c99e 97 5c              [ 4 ]           STA  FP1EXP         ; * AND SAVE IT IN FPA1
1659 c9a0 9f 5d              [ 5 ]           STX  FPA1           ; *
1660 c9a2 df 5f              [ 5 ]           STU  FPA1+2         ; *
1661 c9a4 35 04              [ 6 ]           PULS B              ; = GET MANTISSA SIGN AND
1662 c9a6 d7 61              [ 4 ]           STB  FP1SGN         ; = SAVE IT IN FPA1
1663 c9a8 d8 54              [ 4 ]           EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
1664 c9aa d7 62              [ 4 ]           STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
1665 c9ac d6 4f              [ 4 ] LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
1666 c9ae 39                 [ 5 ] LB222     RTS
1667                               
1668 c9af bd db fc           [ 8 ] LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
1669 c9b2 0f 06              [ 6 ]           CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
1670 c9b4 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHAR
1671 c9b6 24 03              [ 3 ]           BCC  LB22F          ; BRANCH IF NOT NUMERIC
1672 c9b8 7e d4 5e           [ 4 ] LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
1673                               *         RETURN RESULT IN FPA0
1674                               * PROCESS A NON NUMERIC FIRST CHARACTER
1675 c9bb bd cb 29           [ 8 ] LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
1676 c9be 24 50              [ 3 ]           BCC  LB284          ; BRANCH IF ALPHA CHARACTER
1677 c9c0 81 2e              [ 2 ]           CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
1678 c9c2 27 f4              [ 3 ]           BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
1679 c9c4 81 a7              [ 2 ]           CMPA #TOK_MINUS     ; MINUS TOKEN
1680 c9c6 27 40              [ 3 ]           BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
1681 c9c8 81 a6              [ 2 ]           CMPA #TOK_PLUS      ; PLUS TOKEN
1682 c9ca 27 e3              [ 3 ]           BEQ  LB223          ; YES - GET ANOTHER CHARACTER
1683 c9cc 81 22              [ 2 ]           CMPA #'"            ; STRING DELIMITER?
1684 c9ce 26 0a              [ 3 ]           BNE  LB24E          ; NO
1685 c9d0 9e 83              [ 5 ] LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
1686 c9d2 bd cc 9f           [ 8 ]           JSR  LB518          ; SAVE STRING ON STRING STACK
1687 c9d5 9e 64              [ 5 ] LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
1688 c9d7 9f 83              [ 5 ]           STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
1689 c9d9 39                 [ 5 ]           RTS
1690 c9da 81 a3              [ 2 ] LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
1691 c9dc 26 0d              [ 3 ]           BNE  LB25F          ; NO
1692                               * PROCESS THE NOT OPERATOR
1693 c9de 86 5a              [ 2 ]           LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
1694 c9e0 bd c8 e6           [ 8 ]           JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
1695 c9e3 bd cb 74           [ 8 ]           JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
1696 c9e6 43                 [ 2 ]           COMA                ; * 'NOT' THE INTEGER
1697 c9e7 53                 [ 2 ]           COMB                ; *
1698 c9e8 7e cc 7b           [ 4 ]           JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
1699 c9eb 4c                 [ 2 ] LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
1700 c9ec 27 2e              [ 3 ]           BEQ  LB290          ; IT WAS PRECEEDED BY $FF
1701 c9ee 8d 06              [ 7 ] LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
1702 c9f0 bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
1703                               *         HIGHEST PRECEDENCE
1704 c9f3 c6 29              [ 2 ] LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
1705 c9f5 8c                                 FCB  SKP2           ; SKIP 2 BYTES
1706 c9f6 c6 28              [ 2 ] LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
1707 c9f8 8c                                 FCB  SKP2           ; SKIP 2 BYTES
1708 c9f9 c6 2c              [ 2 ] LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
1709 c9fb e1 9f 00 83        [ 9 ] LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
1710 c9ff 26 02              [ 3 ]           BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
1711 ca01 0e 7c              [ 3 ]           JMP  GETNCH         ; GET A CHARACTER FROM BASIC
1712 ca03 c6 02              [ 2 ] LB277     LDB  #2*1           ; SYNTAX ERROR
1713 ca05 7e c4 06           [ 4 ]           JMP  LAC46          ; JUMP TO ERROR HANDLER
1714                               
1715                               * PROCESS THE MINUS (UNARY) OPERATOR
1716 ca08 86 7d              [ 2 ] LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
1717 ca0a bd c8 e6           [ 8 ]           JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
1718 ca0d 7e d6 35           [ 4 ]           JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
1719                               
1720                               * EVALUATE ALPHA EXPRESSION
1721 ca10 bd ca de           [ 8 ] LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
1722 ca13 9f 52              [ 5 ] LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
1723 ca15 96 06              [ 4 ]           LDA  VALTYP         ; TEST VARIABLE TYPE
1724 ca17 26 95              [ 3 ]           BNE  LB222          ; RETURN IF STRING
1725 ca19 7e d3 60           [ 4 ]           JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1726                               
1727                               * EVALUATING A SECONDARY TOKEN
1728 ca1c 9d 7c              [ 7 ] LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
1729 ca1e 1f 89              [ 6 ]           TFR  A,B            ; SAVE IT IN ACCB
1730 ca20 58                 [ 2 ]           ASLB                ; X2 & BET RID OF BIT 7
1731 ca21 9d 7c              [ 7 ]           JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
1732 ca23 c1 38              [ 2 ]           CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
1733 ca25 23 03              [ 3 ]           BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
1734 ca27 7e ca 03           [ 4 ]           JMP  LB277          ; SYNTAX ERROR
1735 ca2a 34 04              [ 6 ] LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
1736 ca2c c1 2a              [ 2 ]           CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
1737 ca2e 25 1e              [ 3 ]           BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
1738 ca30 c1 30              [ 2 ]           CMPB #TOK_INKEY-$80*2 ; *
1739 ca32 24 1c              [ 3 ]           BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
1740 ca34 8d c0              [ 7 ]           BSR  LB26A          ; SYNTAX CHECK FOR A '('
1741 ca36 a6 e4              [ 4 ]           LDA  ,S             ; GET TOKEN NUMBER
1742                               * DO SECONDARIES (LEFT$, RIGHT$, MID$)
1743 ca38 bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
1744 ca3b 8d bc              [ 7 ]           BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
1745 ca3d bd c8 d2           [ 8 ]           JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
1746 ca40 35 02              [ 6 ]           PULS A              ; GET TOKEN OFFSET FROM STACK
1747 ca42 de 52              [ 5 ]           LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
1748 ca44 34 42              [ 8 ]           PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
1749 ca46 bd ce 92           [ 8 ]           JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
1750 ca49 35 02              [ 6 ]           PULS A              ; GET TOKEN OFFSET FROM STACK
1751 ca4b 34 06              [ 7 ]           PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
1752 ca4d 8e                                 FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
1753 ca4e 8d 9e              [ 7 ] LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
1754 ca50 35 04              [ 6 ] LB2C9     PULS B              ; GET TOKEN OFFSET
1755 ca52 be c0 f9           [ 6 ]           LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
1756 ca55 3a                 [ 3 ] LB2CE     ABX                 ; ADD IN COMMAND OFFSET
1757                               *
1758                               * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
1759 ca56 ad 94              [10 ]           JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
1760 ca58 7e c8 cf           [ 4 ]           JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1761                               
1762                               * LOGICAL OPERATOR 'OR' JUMPS HERE
1763 ca5b 86                       LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
1764                               
1765                               * LOGICAL OPERATOR 'AND' JUMPS HERE
1766 ca5c 4f                 [ 2 ] LB2D5     CLRA                ; AND FLAG = 0
1767 ca5d 97 03              [ 4 ]           STA  TMPLOC         ; AND/OR FLAG
1768 ca5f bd cb 74           [ 8 ]           JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1769 ca62 dd 01              [ 5 ]           STD  CHARAC         ; TEMP SAVE ACCD
1770 ca64 bd d3 96           [ 8 ]           JSR  LBC4A          ; MOVE FPA1 TO FPA0
1771 ca67 bd cb 74           [ 8 ]           JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1772 ca6a 0d 03              [ 6 ]           TST  TMPLOC         ; CHECK AND/OR FLAG
1773 ca6c 26 06              [ 3 ]           BNE  LB2ED          ; BRANCH IF OR
1774 ca6e 94 01              [ 4 ]           ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
1775 ca70 d4 02              [ 4 ]           ANDB ENDCHR         ; * STORED IN ENDCHR
1776 ca72 20 04              [ 3 ]           BRA  LB2F1          ; CONVERT TO FP
1777 ca74 9a 01              [ 4 ] LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
1778 ca76 da 02              [ 4 ]           ORB  ENDCHR         ; * STORED IN CHARAC
1779 ca78 7e cc 7b           [ 4 ] LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
1780                               
1781                               * RELATIONAL COMPARISON PROCESS HANDLER
1782 ca7b bd c8 d4           [ 8 ] LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
1783 ca7e 26 10              [ 3 ]           BNE  LB309          ; BRANCH IF STRING VARIABLE
1784 ca80 96 61              [ 4 ]           LDA  FP1SGN         ; * 'PACK' THE MANTISSA
1785 ca82 8a 7f              [ 2 ]           ORA  #$7F           ; * SIGN OF FPA1 INTO
1786 ca84 94 5d              [ 4 ]           ANDA FPA1           ; * BIT 7 OF THE
1787 ca86 97 5d              [ 4 ]           STA  FPA1           ; * MANTISSA MS BYTE
1788 ca88 8e 00 5c           [ 3 ]           LDX  #FP1EXP        ; POINT X TO FPA1
1789 ca8b bd d3 e2           [ 8 ]           JSR  LBC96          ; COMPARE FPA0 TO FPA1
1790 ca8e 20 36              [ 3 ]           BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1791                               
1792                               * RELATIONAL COMPARISON OF STRINGS
1793 ca90 0f 06              [ 6 ] LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1794 ca92 0a 3f              [ 6 ]           DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
1795                               *                             ; DESIRED RELATIONAL COMPARISON DATA
1796 ca94 bd cd de           [ 8 ]           JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
1797                               *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
1798 ca97 d7 56              [ 4 ]           STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
1799 ca99 9f 58              [ 5 ]           STX  STRDES+2       ; * DESCRIPTOR (STRING B)
1800 ca9b 9e 5f              [ 5 ]           LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
1801 ca9d bd cd e0           [ 8 ]           JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
1802 caa0 96 56              [ 4 ]           LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
1803 caa2 34 04              [ 6 ]           PSHS B              ; SAVE LENGTH A ON STACK
1804 caa4 a0 e0              [ 6 ]           SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
1805 caa6 27 07              [ 3 ]           BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
1806 caa8 86 01              [ 2 ]           LDA  #1             ; ; TRUE FLAG
1807 caaa 24 03              [ 3 ]           BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
1808 caac d6 56              [ 4 ]           LDB  STRDES         ; LOAD ACCB WITH LENGTH B
1809 caae 40                 [ 2 ]           NEGA                ; SET FLAG = FALSE (1FF)
1810 caaf 97 54              [ 4 ] LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
1811 cab1 de 58              [ 5 ]           LDU  STRDES+2       ; POINT U TO START OF STRING
1812 cab3 5c                 [ 2 ]           INCB                ; COMPENSATE FOR THE DECB BELOW
1813                               * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
1814 cab4 5a                 [ 2 ] LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
1815 cab5 26 04              [ 3 ]           BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
1816 cab7 d6 54              [ 4 ]           LDB  FP0SGN         ; GET TRUE/FALSE FLAB
1817 cab9 20 0b              [ 3 ]           BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1818 cabb a6 80              [ 6 ] LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
1819 cabd a1 c0              [ 6 ]           CMPA ,U+            ; COMPARE TO STRING B
1820 cabf 27 f3              [ 3 ]           BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
1821 cac1 c6 ff              [ 2 ]           LDB  #$FF           ; FALSE FLAG IF STRING A > B
1822 cac3 24 01              [ 3 ]           BCC  LB33F          ; BRANCH IF STRING A > STRING B
1823 cac5 50                 [ 2 ]           NEGB                ; SET FLAG = TRUE
1824                               
1825                               * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
1826 cac6 cb 01              [ 2 ] LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
1827 cac8 59                 [ 2 ]           ROLB                ; NOW IT'S 1,2,4 FOR > = <
1828 cac9 d4 0a              [ 4 ]           ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
1829                               COMPARISON
1830 cacb 27 02              [ 3 ]           BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
1831 cacd c6 ff              [ 2 ]           LDB  #$FF           ; TRUE FLAG
1832 cacf 7e d3 c8           [ 4 ] LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
1833                               
1834                               * DIM
1835 cad2 bd c9 f9           [ 8 ] LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1836 cad5 c6 01              [ 2 ] DIM       LDB  #1             ; DIMENSION FLAG
1837 cad7 8d 08              [ 7 ]           BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
1838 cad9 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1839 cadb 26 f5              [ 3 ]           BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
1840 cadd 39                 [ 5 ]           RTS
1841                               * EVALUATE A VARIABLE - RETURN X AND
1842                               * VARPTR POINTING TO VARIABLE DESCRIPTOR
1843                               * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
1844                               * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
1845                               * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
1846                               * FIRST BYTE OF VARlABLE NAME IS SET, THE
1847                               * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
1848                               * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
1849                               * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
1850                               * IS NUMERIC.
1851                               * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
1852                               * INSERTED INTO THE VARIABLE SPACE
1853 cade 5f                 [ 2 ] LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
1854 cadf 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1855 cae1 d7 05              [ 4 ] LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
1856                               * ENTRY POINT FOR DEF FN VARIABLE SEARCH
1857 cae3 97 37              [ 4 ] LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
1858 cae5 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1859 cae7 8d 40              [ 7 ]           BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1860 cae9 10 25 ff 16        [ 6 ]           LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
1861 caed 5f                 [ 2 ]           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
1862 caee d7 06              [ 4 ]           STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1863 caf0 9d 7c              [ 7 ]           JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
1864 caf2 25 04              [ 3 ]           BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
1865                               *                             ; VARIABLE MAY BE NUMERIC)
1866 caf4 8d 33              [ 7 ]           BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1867 caf6 25 0a              [ 3 ]           BCS  LB37B          ; BRANCH IF NOT ALPHA
1868 caf8 1f 89              [ 6 ] LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
1869                               * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
1870                               * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
1871                               * IN VARIABLE NAME AFTER THE 1ST TWO
1872 cafa 9d 7c              [ 7 ] LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
1873 cafc 25 fc              [ 3 ]           BCS  LB373          ; BRANCH IF NUMERIC
1874 cafe 8d 29              [ 7 ]           BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1875 cb00 24 f8              [ 3 ]           BCC  LB373          ; BRANCH IF ALPHA
1876 cb02 81 24              [ 2 ] LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
1877 cb04 26 06              [ 3 ]           BNE  LB385          ; BRANCH IF IT IS NOT A STRING
1878 cb06 03 06              [ 6 ]           COM  VALTYP         ; SET VARIABLE TYPE TO STRING
1879 cb08 cb 80              [ 2 ]           ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
1880 cb0a 9d 7c              [ 7 ]           JSR  GETNCH         ; GET AN INPUT CHARACTER
1881 cb0c d7 38              [ 4 ] LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
1882 cb0e 9a 08              [ 4 ]           ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
1883                               *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
1884 cb10 80 28              [ 2 ]           SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
1885 cb12 10 27 00 75        [ 6 ]           LBEQ LB404          ; BRANCH IF IT IS
1886 cb16 0f 08              [ 6 ]           CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
1887 cb18 9e 1b              [ 5 ]           LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
1888 cb1a dc 37              [ 5 ]           LDD  VARNAM         ; GET VARIABLE IN QUESTION
1889 cb1c 9c 1d              [ 6 ] LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
1890 cb1e 27 12              [ 3 ]           BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
1891 cb20 10 a3 81           [10 ]           CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
1892 cb23 27 3e              [ 3 ]           BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
1893 cb25 30 05              [ 5 ]           LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
1894 cb27 20 f3              [ 3 ]           BRA  LB395          ; = KEEP LOOKING
1895                               
1896                               * SET CARRY IF NOT UPPER CASE ALPHA
1897 cb29 81 41              [ 2 ] LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
1898 cb2b 25 04              [ 3 ]           BCS  LB3AA          ; *
1899 cb2d 80 5b              [ 2 ]           SUBA #'Z+1          ; =
1900                               *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
1901 cb2f 80 a5                              FCB  $80,$A5
1902 cb31 39                 [ 5 ] LB3AA     RTS
1903                               * PUT A NEW VARIABLE IN TABLE OF VARIABLES
1904 cb32 8e 00 74           [ 3 ] LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
1905 cb35 ee e4              [ 5 ]           LDU  ,S             ; GET CURRENT RETURN ADDRESS
1906 cb37 11 83 ca 13        [ 5 ]           CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
1907 cb3b 27 28              [ 3 ]           BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
1908 cb3d dc 1f              [ 5 ]           LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
1909 cb3f dd 43              [ 5 ]           STD  V43            ; * SAVE IT AT V43
1910 cb41 c3 00 07           [ 4 ]           ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
1911 cb44 dd 41              [ 5 ]           STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
1912 cb46 9e 1d              [ 5 ]           LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
1913 cb48 9f 47              [ 5 ]           STX  V47            ; *
1914 cb4a bd c3 de           [ 8 ]           JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
1915                               *         TOP  OF VARIABLES
1916 cb4d 9e 41              [ 5 ]           LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
1917 cb4f 9f 1f              [ 5 ]           STX  ARYEND         ; =
1918 cb51 9e 45              [ 5 ]           LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
1919 cb53 9f 1d              [ 5 ]           STX  ARYTAB         ; *
1920 cb55 9e 47              [ 5 ]           LDX  V47            ; GET OLD END OF VARIABLES
1921 cb57 dc 37              [ 5 ]           LDD  VARNAM         ; GET NEW VARIABLE NAME
1922 cb59 ed 81              [ 8 ]           STD  ,X++           ; SAVE VARIABLE NAME
1923 cb5b 4f                 [ 2 ]           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
1924 cb5c 5f                 [ 2 ]           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
1925 cb5d ed 84              [ 5 ]           STD  ,X             ; * OF A STRING VARIABLE
1926 cb5f ed 02              [ 6 ]           STD  2,X            ; *
1927 cb61 a7 04              [ 5 ]           STA  4,X            ; *
1928 cb63 9f 39              [ 5 ] LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
1929 cb65 39                 [ 5 ] LB3DE     RTS
1930                               *
1931 cb66 90 80 00 00 00           LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
1932                               *                             ; SMALLEST SIGNED TWO BYTE INTEGER
1933                               *
1934 cb6b 9d 7c              [ 7 ] LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1935 cb6d bd c8 cd           [ 8 ] LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
1936 cb70 96 54              [ 4 ] LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
1937 cb72 2b 5d              [ 3 ]           BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
1938                               
1939                               
1940 cb74 bd c8 cf           [ 8 ] INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
1941 cb77 96 4f              [ 4 ]           LDA  FP0EXP         ; GET FPA0 EXPONENT
1942 cb79 81 90              [ 2 ]           CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
1943 cb7b 25 08              [ 3 ]           BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
1944 cb7d 8e cb 66           [ 3 ]           LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
1945 cb80 bd d3 e2           [ 8 ]           JSR  LBC96          ; COMPARE -32768 TO FPA0
1946 cb83 26 4c              [ 3 ]           BNE  LB44A          ; 'FC' ERROR IF NOT =
1947 cb85 bd d4 14           [ 8 ] LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
1948 cb88 dc 52              [ 5 ]           LDD  FPA0+2         ; GET THE INTEGER
1949 cb8a 39                 [ 5 ]           RTS
1950                               * EVALUATE AN ARRAY VARIABLE
1951 cb8b dc 05              [ 5 ] LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
1952 cb8d 34 06              [ 7 ]           PSHS B,A            ; SAVE THEM ON STACK
1953 cb8f 12                 [ 2 ]           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
1954 cb90 5f                 [ 2 ]           CLRB                ; RESET DIMENSION COUNTER
1955 cb91 9e 37              [ 5 ] LB40A     LDX  VARNAM         ; GET VARIABLE NAME
1956 cb93 34 14              [ 8 ]           PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
1957 cb95 8d d4              [ 7 ]           BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
1958 cb97 35 34              [10 ]           PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
1959                               *                             ; ARRAY FLAG
1960 cb99 9f 37              [ 5 ]           STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
1961 cb9b de 52              [ 5 ]           LDU  FPA0+2         ; GET DIMENSION LENGTH
1962 cb9d 34 60              [ 9 ]           PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
1963 cb9f 5c                 [ 2 ]           INCB                ; INCREASE DIMENSION COUNTER
1964 cba0 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1965 cba2 81 2c              [ 2 ]           CMPA #',            ; CHECK FOR ANOTHER DIMENSION
1966 cba4 27 eb              [ 3 ]           BEQ  LB40A          ; BRANCH IF MORE
1967 cba6 d7 03              [ 4 ]           STB  TMPLOC         ; SAVE DIMENSION COUNTER
1968 cba8 bd c9 f3           [ 8 ]           JSR  LB267          ; SYNTAX CHECK FOR A ')'
1969 cbab 35 06              [ 7 ]           PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
1970 cbad dd 05              [ 5 ]           STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
1971 cbaf 9e 1d              [ 5 ]           LDX  ARYTAB         ; GET START OF ARRAYS
1972 cbb1 9c 1f              [ 6 ] LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
1973 cbb3 27 21              [ 3 ]           BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
1974 cbb5 dc 37              [ 5 ]           LDD  VARNAM         ; GET VARIABLE IN QUESTION
1975 cbb7 10 a3 84           [ 7 ]           CMPD ,X             ; COMPARE TO CURRENT VARIABLE
1976 cbba 27 06              [ 3 ]           BEQ  LB43B          ; BRANCH IF =
1977 cbbc ec 02              [ 6 ]           LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
1978 cbbe 30 8b              [ 8 ]           LEAX D,X            ; ADD TO CURRENT POINTER
1979 cbc0 20 ef              [ 3 ]           BRA  LB42A          ; KEEP SEARCHING
1980 cbc2 c6 12              [ 2 ] LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
1981 cbc4 96 05              [ 4 ]           LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
1982 cbc6 26 0b              [ 3 ]           BNE  LB44C          ; * TO REDIMENSION AN ARRAY
1983 cbc8 d6 03              [ 4 ]           LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
1984 cbca e1 04              [ 5 ]           CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
1985 cbcc 27 59              [ 3 ]           BEQ  LB4A0          ; BRANCH IF =
1986 cbce c6 10              [ 2 ] LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
1987 cbd0 8c                                 FCB  SKP2           ; SKIP TWO BYTES
1988 cbd1 c6 08              [ 2 ] LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
1989 cbd3 7e c4 06           [ 4 ] LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
1990                               
1991                               * INSERT A NEW ARRAY INTO ARRAY VARIABLES
1992                               * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
1993                               * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
1994                               * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
1995                               * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
1996                               * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
1997                               * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
1998                               * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
1999                               
2000 cbd6 cc 00 05           [ 3 ] LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
2001 cbd9 dd 64              [ 5 ]           STD  COEFPT         ; *
2002 cbdb dc 37              [ 5 ]           LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
2003 cbdd ed 84              [ 5 ]           STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
2004 cbdf d6 03              [ 4 ]           LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
2005 cbe1 e7 04              [ 5 ]           STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
2006 cbe3 bd c3 f3           [ 8 ]           JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
2007 cbe6 9f 41              [ 5 ]           STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
2008 cbe8 c6 0b              [ 2 ] LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
2009 cbea 4f                 [ 2 ]           CLRA                ; *
2010 cbeb 0d 05              [ 6 ]           TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
2011 cbed 27 05              [ 3 ]           BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
2012 cbef 35 06              [ 7 ]           PULS A,B            ; GET DIMENSION LENGTH
2013 cbf1 c3 00 01           [ 4 ]           ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
2014 cbf4 ed 05              [ 6 ] LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
2015 cbf6 8d 5d              [ 7 ]           BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
2016                               *                             ; OF NEW DIMENSION
2017 cbf8 dd 64              [ 5 ]           STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
2018 cbfa 30 02              [ 5 ]           LEAX 2,X            ; BUMP POINTER UP TWO
2019 cbfc 0a 03              [ 6 ]           DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
2020 cbfe 26 e8              [ 3 ]           BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
2021 cc00 9f 0f              [ 5 ]           STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
2022 cc02 d3 0f              [ 6 ]           ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
2023 cc04 10 25 f7 fc        [ 6 ]           LBCS LAC44          ; 'OM' ERROR IF > $FFFF
2024 cc08 1f 01              [ 6 ]           TFR  D,X            ; SAVE END OF ARRAY IN X
2025 cc0a bd c3 f7           [ 8 ]           JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
2026 cc0d 83 00 35           [ 4 ]           SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
2027 cc10 dd 1f              [ 5 ]           STD  ARYEND         ; SAVE NEW END OF ARRAYS
2028 cc12 4f                 [ 2 ]           CLRA                ; ZERO = TERMINATOR BYTE
2029 cc13 30 1f              [ 5 ] LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
2030 cc15 a7 05              [ 5 ]           STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
2031 cc17 9c 0f              [ 6 ]           CMPX TEMPTR         ; *
2032 cc19 26 f8              [ 3 ]           BNE  LB48C          ; *
2033 cc1b 9e 41              [ 5 ]           LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
2034 cc1d 96 1f              [ 4 ]           LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
2035 cc1f 93 41              [ 6 ]           SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
2036 cc21 ed 02              [ 6 ]           STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
2037 cc23 96 05              [ 4 ]           LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
2038 cc25 26 2d              [ 3 ]           BNE  LB4CD          ; * BACK IF DIMENSIONING
2039                               * CALCULATE POINTER TO CORRECT ELEMENT
2040 cc27 e6 04              [ 5 ] LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
2041 cc29 d7 03              [ 4 ]           STB  TMPLOC         ; TEMPORARILY SAVE
2042 cc2b 4f                 [ 2 ]           CLRA                ; * INITIALIZE POINTER
2043 cc2c 5f                 [ 2 ]           CLRB                ; * TO ZERO
2044 cc2d dd 64              [ 5 ] LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
2045 cc2f 35 06              [ 7 ]           PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
2046 cc31 dd 52              [ 5 ]           STD  FPA0+2         ; * STACK AND SAVE IT
2047 cc33 10 a3 05           [ 8 ]           CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
2048 cc36 24 3a              [ 3 ]           BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
2049 cc38 de 64              [ 5 ]           LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
2050 cc3a 27 04              [ 3 ]           BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
2051 cc3c 8d 17              [ 7 ]           BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
2052 cc3e d3 52              [ 6 ]           ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
2053 cc40 30 02              [ 5 ] LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
2054 cc42 0a 03              [ 6 ]           DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
2055 cc44 26 e7              [ 3 ]           BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
2056                               * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
2057 cc46 ed e3              [ 8 ]           STD  ,--S
2058 cc48 58                 [ 2 ]           ASLB
2059 cc49 49                 [ 2 ]           ROLA                ; TIMES 2
2060 cc4a 58                 [ 2 ]           ASLB
2061 cc4b 49                 [ 2 ]           ROLA                ; TIMES 4
2062 cc4c e3 e1              [ 9 ]           ADDD ,S++           ; TIMES 5
2063 cc4e 30 8b              [ 8 ]           LEAX D,X            ; ADD OFFSET TO START OF ARRAY
2064 cc50 30 05              [ 5 ]           LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
2065 cc52 9f 39              [ 5 ]           STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
2066 cc54 39                 [ 5 ] LB4CD     RTS
2067                               * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
2068                               * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
2069 cc55 86 10              [ 2 ] LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
2070 cc57 97 45              [ 4 ]           STA  V45            ; SHIFT COUNTER
2071 cc59 ec 05              [ 6 ]           LDD  5,X            ; * GET SIZE OF DIMENSION
2072 cc5b dd 17              [ 5 ]           STD  BOTSTK         ; * AND SAVE IT
2073 cc5d 4f                 [ 2 ]           CLRA                ; * ZERO
2074 cc5e 5f                 [ 2 ]           CLRB                ; * ACCD
2075 cc5f 58                 [ 2 ] LB4D8     ASLB                ; = SHIFT ACCB LEFT
2076 cc60 49                 [ 2 ]           ROLA                ; = ONE BIT
2077 cc61 25 0f              [ 3 ]           BCS  LB4EB          ; 'BS' ERROR IF CARRY
2078 cc63 08 65              [ 6 ]           ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
2079 cc65 09 64              [ 6 ]           ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
2080 cc67 24 04              [ 3 ]           BCC  LB4E6          ; * IF CARRY <> 0
2081 cc69 d3 17              [ 6 ]           ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
2082 cc6b 25 05              [ 3 ]           BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
2083 cc6d 0a 45              [ 6 ] LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
2084 cc6f 26 ee              [ 3 ]           BNE  LB4D8          ; * IF NOT DONE
2085 cc71 39                 [ 5 ]           RTS
2086 cc72 7e cb ce           [ 4 ] LB4EB     JMP  LB447          ; 'BS' ERROR
2087                               *
2088                               * MEM
2089                               * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
2090                               * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
2091                               * FOR WHICH MEM DOES NOT ALLOW.
2092                               *
2093 cc75 1f 40              [ 6 ] MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
2094 cc77 93 1f              [ 6 ]           SUBD ARYEND         ; SUBTRACT END OF ARRAYS
2095 cc79 21                                 FCB  SKP1           ; SKIP ONE BYTE
2096                               *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
2097 cc7a 4f                 [ 2 ] LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
2098                               * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
2099 cc7b 0f 06              [ 6 ] GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2100 cc7d dd 50              [ 5 ]           STD  FPA0           ; SAVE ACCD IN TOP OF FACA
2101 cc7f c6 90              [ 2 ]           LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
2102                               *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
2103 cc81 7e d3 ce           [ 4 ]           JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
2104                               
2105                               * STR$
2106 cc84 bd c8 cf           [ 8 ] STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
2107 cc87 ce 01 f0           [ 3 ]           LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
2108 cc8a bd d5 28           [ 8 ]           JSR  LBDDC          ; *THE STRING BUFFER
2109 cc8d 32 62              [ 5 ]           LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
2110 cc8f 8e 01 ef           [ 3 ]           LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
2111 cc92 20 0b              [ 3 ]           BRA  LB518          ; *THE STRING IN THE STRING SPACE
2112                               * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
2113                               * ADDRESS IN (X) AND FRESPC
2114 cc94 9f 4d              [ 5 ] LB50D     STX  V4D            ; SAVE X IN V4D
2115 cc96 8d 5c              [ 7 ] LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
2116 cc98 9f 58              [ 5 ] LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
2117 cc9a d7 56              [ 4 ]           STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
2118 cc9c 39                 [ 5 ]           RTS
2119 cc9d 30 1f              [ 5 ] LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
2120                               * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
2121                               * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
2122                               * THE RESULTING STRING IS STORED IN THE STRING SPACE
2123                               * ONLY IF THE START OF THE STRING IS <= STRBUF+2
2124 cc9f 86 22              [ 2 ] LB518     LDA  #'"            ; * INITIALIZE
2125 cca1 97 01              [ 4 ]           STA  CHARAC         ; * TERMINATORS
2126 cca3 97 02              [ 4 ] LB51A     STA  ENDCHR         ; * TO "
2127 cca5 30 01              [ 5 ] LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
2128 cca7 9f 62              [ 5 ]           STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
2129 cca9 9f 58              [ 5 ]           STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
2130 ccab c6 ff              [ 2 ]           LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
2131 ccad 5c                 [ 2 ] LB526     INCB                ; INCREMENT CHARACTER COUNTER
2132 ccae a6 80              [ 6 ]           LDA  ,X+            ; GET CHARACTER
2133 ccb0 27 0c              [ 3 ]           BEQ  LB537          ; BRANCH IF END OF LINE
2134 ccb2 91 01              [ 4 ]           CMPA CHARAC         ; * CHECK FOR TERMINATORS
2135 ccb4 27 04              [ 3 ]           BEQ  LB533          ; * IN CHARAC AND ENDCHR
2136 ccb6 91 02              [ 4 ]           CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
2137 ccb8 26 f3              [ 3 ]           BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
2138 ccba 81 22              [ 2 ] LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
2139 ccbc 27 02              [ 3 ]           BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
2140 ccbe 30 1f              [ 5 ] LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
2141 ccc0 9f 64              [ 5 ] LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
2142 ccc2 d7 56              [ 4 ]           STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
2143 ccc4 de 62              [ 5 ]           LDU  RESSGN         ; GET INITlAL STRING START
2144 ccc6 11 83 01 f0        [ 5 ]           CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
2145 ccca 22 07              [ 3 ] LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
2146 cccc 8d c6              [ 7 ]           BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
2147 ccce 9e 62              [ 5 ]           LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
2148 ccd0 bd cd cc           [ 8 ]           JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
2149                               *                             [FRESPC] - MOVE STRING DATA
2150                               * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
2151                               * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
2152 ccd3 9e 0b              [ 5 ] LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
2153 ccd5 8c 00 f1           [ 4 ]           CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
2154 ccd8 26 05              [ 3 ]           BNE  LB558          ; FORMULA O.K.
2155 ccda c6 1e              [ 2 ]           LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
2156 ccdc 7e c4 06           [ 4 ] LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2157 ccdf 96 56              [ 4 ] LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
2158                               *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
2159 cce1 a7 00                              FCB  $A7,$00
2160 cce3 dc 58              [ 5 ]           LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
2161 cce5 ed 02              [ 6 ]           STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
2162 cce7 86 ff              [ 2 ]           LDA  #$FF           ; * VARIABLE TYPE = STRING
2163 cce9 97 06              [ 4 ]           STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
2164 cceb 9f 0d              [ 5 ]           STX  LASTPT         ; = SAVE START OF DESCRIPTOR
2165 cced 9f 52              [ 5 ]           STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
2166 ccef 30 05              [ 5 ]           LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
2167 ccf1 9f 0b              [ 5 ]           STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
2168 ccf3 39                 [ 5 ]           RTS
2169                               * RESERVE ACCB BYTES IN STRING STORAGE SPACE
2170                               * RETURN WITH THE STARTING ADDRESS OF THE
2171                               * RESERVED STRING SPACE IN (X) AND FRESPC
2172 ccf4 0f 07              [ 6 ] LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
2173 ccf6 4f                 [ 2 ] LB56F     CLRA                ; * PUSH THE LENGTH OF THE
2174 ccf7 34 06              [ 7 ]           PSHS B,A            ; * STRING ONTO THE STACK
2175 ccf9 dc 23              [ 5 ]           LDD  STRTAB         ; GET START OF STRING VARIABLES
2176 ccfb a3 e0              [ 8 ]           SUBD ,S+            ; SUBTRACT STRING LENGTH
2177 ccfd 10 93 21           [ 7 ]           CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
2178 cd00 25 0a              [ 3 ]           BCS  LB585          ; IF BELOW START, THEN REORGANIZE
2179 cd02 dd 23              [ 5 ]           STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
2180 cd04 9e 23              [ 5 ]           LDX  STRTAB         ; GET START OF STRING VARIABLES
2181 cd06 30 01              [ 5 ]           LEAX 1,X            ; ADD ONE
2182 cd08 9f 25              [ 5 ]           STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
2183 cd0a 35 84              [ 8 ]           PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
2184 cd0c c6 1a              [ 2 ] LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
2185 cd0e 03 07              [ 6 ]           COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
2186 cd10 27 ca              [ 3 ]           BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
2187 cd12 8d 04              [ 7 ]           BSR  LB591          ; GO REORGANIZE STRING SPACE
2188 cd14 35 04              [ 6 ]           PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
2189 cd16 20 de              [ 3 ]           BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
2190                               * REORGANIZE THE STRING SPACE
2191 cd18 9e 27              [ 5 ] LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
2192 cd1a 9f 23              [ 5 ] LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
2193 cd1c 4f                 [ 2 ]           CLRA                ; * ZERO OUT ACCD
2194 cd1d 5f                 [ 2 ]           CLRB                ; * AND RESET VARIABLE
2195 cd1e dd 4b              [ 5 ]           STD  V4B            ; * POINTER TO 0
2196 cd20 9e 21              [ 5 ]           LDX  FRETOP         ; POINT X TO START OF STRING SPACE
2197 cd22 9f 47              [ 5 ]           STX  V47            ; SAVE POINTER IN V47
2198 cd24 8e 00 c9           [ 3 ]           LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
2199 cd27 9c 0b              [ 6 ] LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
2200 cd29 27 04              [ 3 ]           BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
2201 cd2b 8d 32              [ 7 ]           BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2202 cd2d 20 f8              [ 3 ]           BRA  LB5A0          ; KEEP CHECKING
2203 cd2f 9e 1b              [ 5 ] LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
2204 cd31 9c 1d              [ 6 ] LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
2205 cd33 27 04              [ 3 ]           BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
2206 cd35 8d 22              [ 7 ]           BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2207 cd37 20 f8              [ 3 ]           BRA  LB5AA          ; KEEP CHECKING VARIABLES
2208 cd39 9f 41              [ 5 ] LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
2209 cd3b 9e 41              [ 5 ] LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
2210 cd3d 9c 1f              [ 6 ] LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
2211 cd3f 27 35              [ 3 ]           BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
2212 cd41 ec 02              [ 6 ]           LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
2213 cd43 d3 41              [ 6 ]           ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
2214 cd45 dd 41              [ 5 ]           STD  V41            ; * AND SAVE IT
2215 cd47 a6 01              [ 5 ]           LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
2216 cd49 2a f0              [ 3 ]           BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
2217 cd4b e6 04              [ 5 ]           LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
2218 cd4d 58                 [ 2 ]           ASLB                ; MULTIPLY BY 2
2219 cd4e cb 05              [ 2 ]           ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
2220                               *                             ; LENGTH, NUMBER DIMENSIONS)
2221 cd50 3a                 [ 3 ]           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
2222 cd51 9c 41              [ 6 ] LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
2223 cd53 27 e8              [ 3 ]           BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
2224 cd55 8d 08              [ 7 ]           BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
2225                               *                             ; UNORGANIZED STRING SPACE
2226 cd57 20 f8              [ 3 ]           BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
2227 cd59 a6 01              [ 5 ] LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
2228 cd5b 30 02              [ 5 ]           LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
2229 cd5d 2a 14              [ 3 ]           BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
2230                               * SEARCH FOR STRING - ENTER WITH X POINTING TO
2231                               * THE STRING DESCRIPTOR. IF STRING IS STORED
2232                               * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
2233                               * IN V4B AND RESET V47 TO STRING ADDRESS
2234 cd5f e6 84              [ 4 ] LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
2235 cd61 27 10              [ 3 ]           BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
2236 cd63 ec 02              [ 6 ]           LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
2237 cd65 10 93 23           [ 7 ]           CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
2238 cd68 22 09              [ 3 ]           BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
2239                               *              ; THE STRING VARIABLES
2240 cd6a 10 93 47           [ 7 ]           CMPD V47            ; COMPARE TO START OF STRING SPACE
2241 cd6d 23 04              [ 3 ]           BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
2242 cd6f 9f 4b              [ 5 ]           STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
2243 cd71 dd 47              [ 5 ]           STD  V47            ; SAVE STRING STARTING ADDRESS
2244 cd73 30 05              [ 5 ] LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
2245 cd75 39                 [ 5 ] LB5EE     RTS
2246 cd76 9e 4b              [ 5 ] LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
2247                               *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
2248                               *              ; THE UNORGANIZED STRING SPACE
2249 cd78 27 fb              [ 3 ]           BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
2250 cd7a 4f                 [ 2 ]           CLRA                ; CLEAR MS BYTE OF LENGTH
2251 cd7b e6 84              [ 4 ]           LDB  ,X             ; GET LENGTH OF STRING
2252 cd7d 5a                 [ 2 ]           DECB                ; SUBTRACT ONE
2253 cd7e d3 47              [ 6 ]           ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
2254 cd80 dd 43              [ 5 ]           STD  V43            ; SAVE AS MOVE STARTING ADDRESS
2255 cd82 9e 23              [ 5 ]           LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
2256 cd84 9f 41              [ 5 ]           STX  V41            ; SAVE AS MOVE ENDING ADDRESS
2257 cd86 bd c3 e0           [ 8 ]           JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
2258                               *              ; TOP OF UNORGANIZED STRING SPACE
2259 cd89 9e 4b              [ 5 ]           LDX  V4B            ; POINT X TO STRING DESCRIPTOR
2260 cd8b dc 45              [ 5 ]           LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
2261 cd8d ed 02              [ 6 ]           STD  2,X            ; * SAVE IT IN DESCRIPTOR
2262 cd8f 9e 45              [ 5 ]           LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
2263 cd91 30 1f              [ 5 ]           LEAX -1,X           ; MOVE POINTER BACK ONE
2264 cd93 7e cd 1a           [ 4 ]           JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
2265                               
2266                               
2267 cd96 dc 52              [ 5 ] LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
2268 cd98 34 06              [ 7 ]           PSHS B,A            ; * AND SAVE IT ON THE STACK
2269 cd9a bd c9 af           [ 8 ]           JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
2270 cd9d bd c8 d2           [ 8 ]           JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
2271 cda0 35 10              [ 7 ]           PULS X              ; * POINT X TO STRING A DESCRIPTOR
2272 cda2 9f 62              [ 5 ]           STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
2273 cda4 e6 84              [ 4 ]           LDB  ,X             ; GET LENGTH OF STRING A
2274 cda6 9e 52              [ 5 ]           LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
2275 cda8 eb 84              [ 4 ]           ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
2276 cdaa 24 05              [ 3 ]           BCC  LB62A          ; BRANCH IF LENGTH < 256
2277 cdac c6 1c              [ 2 ]           LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
2278 cdae 7e c4 06           [ 4 ]           JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2279 cdb1 bd cc 94           [ 8 ] LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
2280 cdb4 9e 62              [ 5 ]           LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
2281 cdb6 e6 84              [ 4 ]           LDB  ,X             ; GET LENGTH OF STRING A
2282 cdb8 8d 10              [ 7 ]           BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
2283 cdba 9e 4d              [ 5 ]           LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
2284 cdbc 8d 22              [ 7 ]           BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
2285 cdbe 8d 0c              [ 7 ]           BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
2286 cdc0 9e 62              [ 5 ]           LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
2287 cdc2 8d 1c              [ 7 ]           BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
2288 cdc4 bd cc d3           [ 8 ]           JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
2289 cdc7 7e c8 f4           [ 4 ]           JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
2290                               
2291                               * MOVE (B) BYTES FROM 2,X TO FRESPC
2292 cdca ae 02              [ 6 ] LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
2293 cdcc de 25              [ 5 ] LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
2294 cdce 5c                 [ 2 ]           INCB                ; COMPENSATION FOR THE DECB BELOW
2295 cdcf 20 04              [ 3 ]           BRA  LB64E          ; GO MOVE THE BYTES
2296                               * MOVE B BYTES FROM (X) TO (U)
2297 cdd1 a6 80              [ 6 ] LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
2298 cdd3 a7 c0              [ 6 ]           STA  ,U+            ; * TO THE DESTINATION
2299 cdd5 5a                 [ 2 ] LB64E     DECB                ; DECREMENT BYTE COUNTER
2300 cdd6 26 f9              [ 3 ]           BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
2301 cdd8 df 25              [ 5 ]           STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
2302 cdda 39                 [ 5 ]           RTS
2303                               * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
2304                               * STRING WHOSE DESCRIPTOR IS IN FPA0+2
2305                               * DELETE THE STRING IF IT IS THE LAST ONE
2306                               * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
2307                               * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
2308 cddb bd c8 d2           [ 8 ] LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
2309 cdde 9e 52              [ 5 ] LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
2310 cde0 e6 84              [ 4 ] LB659     LDB  ,X             ; GET LENGTH OF STRING
2311 cde2 8d 18              [ 7 ]           BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
2312 cde4 26 13              [ 3 ]           BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
2313                               *                             ; * BRANCH IF NOT
2314 cde6 ae 07              [ 6 ]           LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
2315 cde8 30 1f              [ 5 ]           LEAX -1,X           ; MOVE POINTER DOWN ONE
2316 cdea 9c 23              [ 6 ]           CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
2317 cdec 26 08              [ 3 ]           BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
2318                               *                             ; OF STRING VARIABLES
2319 cdee 34 04              [ 6 ]           PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
2320 cdf0 d3 23              [ 6 ]           ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
2321 cdf2 dd 23              [ 5 ]           STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
2322                               *                             ; * REMOVE THE STRING FROM THE STRING SPACE
2323 cdf4 35 04              [ 6 ]           PULS B              ; RESTORE LENGTH
2324 cdf6 30 01              [ 5 ] LB66F     LEAX 1,X            ; ADD ONE TO POINTER
2325 cdf8 39                 [ 5 ]           RTS
2326 cdf9 ae 02              [ 6 ] LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
2327 cdfb 39                 [ 5 ]           RTS                 ; *ON THE STRING STACK
2328                               * REMOVE STRING FROM STRING STACK. ENTER WITH X
2329                               * POINTING TO A STRING DESCRIPTOR - DELETE THE
2330                               * STRING FROM STACK IF IT IS ON TOP OF THE
2331                               * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
2332 cdfc 9c 0d              [ 6 ] LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
2333 cdfe 26 07              [ 3 ]           BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
2334                               *                             ; *ADDRESS NOT ON THE STRING STACK
2335 ce00 9f 0b              [ 5 ]           STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
2336 ce02 30 1b              [ 5 ]           LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
2337 ce04 9f 0d              [ 5 ]           STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
2338 ce06 4f                 [ 2 ]           CLRA                ; SET ZERO FLAG
2339 ce07 39                 [ 5 ] LB680     RTS
2340                               
2341                               * LEN
2342 ce08 8d 03              [ 7 ] LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
2343 ce0a 7e cc 7a           [ 4 ] LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
2344                               * POINT X TO STRING ADDRESS LOAD LENGTH INTO
2345                               * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
2346                               * BOTTOM TWO BYTES OF FPA0
2347 ce0d 8d cc              [ 7 ] LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
2348 ce0f 0f 06              [ 6 ]           CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2349 ce11 5d                 [ 2 ]           TSTB                ; SET FLAGS ACCORDING TO LENGTH
2350 ce12 39                 [ 5 ]           RTS
2351                               
2352                               * CHR$
2353 ce13 bd ce 95           [ 8 ] CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
2354 ce16 c6 01              [ 2 ] LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
2355 ce18 bd cc f4           [ 8 ]           JSR  LB56D          ; * THE STRING SPACE
2356 ce1b 96 53              [ 4 ]           LDA  FPA0+3         ; GET ASCII STRING VALUE
2357 ce1d bd cc 98           [ 8 ]           JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
2358 ce20 a7 84              [ 4 ]           STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
2359 ce22 32 62              [ 5 ] LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
2360 ce24 7e cc d3           [ 4 ] LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
2361                               
2362                               
2363 ce27 8d 02              [ 7 ] ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
2364 ce29 20 df              [ 3 ]           BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
2365 ce2b 8d e0              [ 7 ] LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
2366 ce2d 27 5e              [ 3 ]           BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2367 ce2f e6 84              [ 4 ]           LDB  ,X             ; GET FIRST BYTE OF STRING
2368 ce31 39                 [ 5 ]           RTS
2369                               
2370                               
2371 ce32 8d 48              [ 7 ] LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2372 ce34 4f                 [ 2 ] LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
2373 ce35 e1 84              [ 4 ] LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
2374 ce37 23 03              [ 3 ]           BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
2375                               *                             ; >= LENGTH PARAMETER
2376 ce39 e6 84              [ 4 ]           LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
2377 ce3b 4f                 [ 2 ]           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
2378 ce3c 34 06              [ 7 ] LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
2379 ce3e bd cc 96           [ 8 ]           JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
2380 ce41 9e 4d              [ 5 ]           LDX  V4D            ; POINT X TO STRING DESCRIPTOR
2381 ce43 8d 9b              [ 7 ]           BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
2382 ce45 35 04              [ 6 ]           PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
2383 ce47 3a                 [ 3 ]           ABX                 ; * AND ADD IT TO STRING ADDRESS
2384 ce48 35 04              [ 6 ]           PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
2385 ce4a bd cd cc           [ 8 ]           JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
2386 ce4d 20 d5              [ 3 ]           BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
2387                               
2388                               * RIGHT$
2389 ce4f 8d 2b              [ 7 ] RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2390 ce51 a0 84              [ 4 ]           SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
2391 ce53 40                 [ 2 ]           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
2392 ce54 20 df              [ 3 ]           BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
2393                               
2394                               * MID$
2395 ce56 c6 ff              [ 2 ] MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
2396 ce58 d7 53              [ 4 ]           STB  FPA0+3         ; * SAVE IT IN FPA0
2397 ce5a 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2398 ce5c 81 29              [ 2 ]           CMPA #')            ; ARGUMENT DELIMITER?
2399 ce5e 27 05              [ 3 ]           BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
2400 ce60 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
2401 ce63 8d 2d              [ 7 ]           BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
2402 ce65 8d 15              [ 7 ] LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2403 ce67 27 24              [ 3 ]           BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2404 ce69 5f                 [ 2 ]           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
2405 ce6a 4a                 [ 2 ]           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
2406 ce6b a1 84              [ 4 ]           CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
2407                               *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
2408 ce6d 24 cd              [ 3 ]           BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
2409                               *                             ; STRING WILL BE A NULL STRING
2410 ce6f 1f 89              [ 6 ]           TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
2411 ce71 e0 84              [ 4 ]           SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
2412 ce73 50                 [ 2 ]           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
2413 ce74 d1 53              [ 4 ]           CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
2414 ce76 23 c4              [ 3 ]           BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
2415                               * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
2416                               * INSTEAD OF THE LENGTH PARAMETER
2417 ce78 d6 53              [ 4 ]           LDB  FPA0+3         ; GET LENGTH OF NEW STRING
2418 ce7a 20 c0              [ 3 ]           BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
2419                               * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
2420                               * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
2421 ce7c bd c9 f3           [ 8 ] LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
2422 ce7f ee e4              [ 5 ]           LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
2423 ce81 ae 65              [ 6 ]           LDX  5,S            ; * GET ADDRESS OF STRING AND
2424 ce83 9f 4d              [ 5 ]           STX  V4D            ; * SAVE IT IN V4D
2425 ce85 a6 64              [ 5 ]           LDA  4,S            ; = PUT LENGTH OF STRING IN
2426 ce87 e6 64              [ 5 ]           LDB  4,S            ; = BOTH ACCA AND ACCB
2427 ce89 32 67              [ 5 ]           LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
2428 ce8b 1f 35              [ 6 ]           TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
2429 ce8d 7e cb d1           [ 4 ] LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
2430                               * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
2431                               * ACCB - 'FC' ERROR IF EXPRESSION > 255
2432 ce90 9d 7c              [ 7 ] LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
2433 ce92 bd c8 cd           [ 8 ] LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
2434 ce95 bd cb 70           [ 8 ] LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
2435 ce98 4d                 [ 2 ]           TSTA                ; TEST MS BYTE OF INTEGER
2436 ce99 26 f2              [ 3 ]           BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
2437 ce9b 0e 82              [ 3 ]           JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
2438                               
2439                               * VAL
2440 ce9d bd ce 0d           [ 8 ] VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
2441 cea0 10 27 02 e1        [ 6 ]           LBEQ LBA39          ; IF NULL STRING SET FPA0
2442 cea4 de 83              [ 5 ]           LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
2443 cea6 9f 83              [ 5 ]           STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
2444 cea8 3a                 [ 3 ]           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
2445 cea9 a6 84              [ 4 ]           LDA  ,X             ; GET LAST BYTE OF STRING
2446 ceab 34 52              [10 ]           PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
2447                               *         ADDRESS AND CHARACTER
2448 cead 6f 84              [ 6 ]           CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
2449 ceaf 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2450 ceb1 bd d4 5e           [ 8 ]           JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
2451 ceb4 35 52              [10 ]           PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
2452 ceb6 a7 84              [ 4 ]           STA  ,X             ; REPLACE STRING TERMINATOR
2453 ceb8 df 83              [ 5 ]           STU  CHARAD         ; RESTORE INPUT CHARACTER
2454 ceba 39                 [ 5 ]           RTS
2455                               
2456 cebb 8d 07              [ 7 ] LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
2457 cebd 9f 2b              [ 5 ]           STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
2458 cebf bd c9 f9           [ 8 ] LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
2459 cec2 20 ce              [ 3 ]           BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
2460                               * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
2461                               
2462 cec4 bd c8 cd           [ 8 ] LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
2463 cec7 96 54              [ 4 ] LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
2464 cec9 2b c2              [ 3 ]           BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
2465 cecb 96 4f              [ 4 ]           LDA  FP0EXP         ; GET EXPONENT OF FPA0
2466 cecd 81 90              [ 2 ]           CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
2467 cecf 22 bc              [ 3 ]           BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
2468 ced1 bd d4 14           [ 8 ]           JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
2469 ced4 9e 52              [ 5 ]           LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
2470 ced6 39                 [ 5 ]           RTS
2471                               
2472                               * PEEK
2473 ced7 8d ee              [ 7 ] PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
2474 ced9 e6 84              [ 4 ]           LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
2475 cedb 7e cc 7a           [ 4 ]           JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
2476                               
2477                               * POKE
2478 cede 8d db              [ 7 ] POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
2479 cee0 9e 2b              [ 5 ]           LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
2480 cee2 e7 84              [ 4 ]           STB  ,X             ; STORE THE DATA IN THAT ADDRESS
2481 cee4 39                 [ 5 ]           RTS
2482                               
2483                               
2484                               * LIST
2485 cee5 34 01              [ 6 ] LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
2486 cee7 bd c7 17           [ 8 ]           JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
2487 ceea bd c4 a5           [ 8 ]           JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
2488 ceed 9f 66              [ 5 ]           STX  LSTTXT         ; * SAVE IT IN LSTTXT
2489 ceef 35 01              [ 6 ]           PULS CC             ; GET ZERO FLAG FROM STACK
2490 cef1 27 12              [ 3 ]           BEQ  LB784          ; BRANCH IF END OF LINE
2491 cef3 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2492 cef5 27 13              [ 3 ]           BEQ  LB789          ; BRANCH IF END OF LINE
2493 cef7 81 a7              [ 2 ]           CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
2494 cef9 26 09              [ 3 ]           BNE  LB783          ; NO - RETURN
2495 cefb 9d 7c              [ 7 ]           JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2496 cefd 27 06              [ 3 ]           BEQ  LB784          ; BRANCH IF END OF LINE
2497 ceff bd c7 17           [ 8 ]           JSR  LAF67          ; GET ENDING LINE NUMBER
2498 cf02 27 06              [ 3 ]           BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
2499 cf04 39                 [ 5 ] LB783 RTS
2500                               * LIST THE ENTIRE PROGRAM
2501 cf05 ce ff ff           [ 3 ] LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
2502 cf08 df 2b              [ 5 ]           STU  BINVAL         ; * TO $FFFF
2503 cf0a 32 62              [ 5 ] LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
2504 cf0c 9e 66              [ 5 ]           LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
2505 cf0e bd d0 ac           [ 8 ] LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
2506 cf11 bd c1 9a           [ 8 ]           JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
2507 cf14 ec 84              [ 5 ]           LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
2508 cf16 26 03              [ 3 ]           BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
2509                               LB797
2510 cf18 7e c4 25           [ 4 ]           JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
2511 cf1b 9f 66              [ 5 ] LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
2512 cf1d ec 02              [ 6 ]           LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
2513 cf1f 10 93 2b           [ 7 ]           CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
2514 cf22 22 f4              [ 3 ]           BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
2515 cf24 bd d5 18           [ 8 ]           JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
2516 cf27 bd d0 f8           [ 8 ]           JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2517 cf2a 9e 66              [ 5 ]           LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
2518 cf2c 8d 10              [ 7 ]           BSR  LB7C2          ; UNCRUNCH A LINE
2519 cf2e ae 9f 00 66        [10 ]           LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
2520 cf32 ce 00 f4           [ 3 ]           LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
2521 cf35 a6 c0              [ 6 ] LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
2522 cf37 27 d5              [ 3 ]           BEQ  LB78D          ; BRANCH IF END OF BUFFER
2523 cf39 bd d0 fd           [ 8 ]           JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
2524 cf3c 20 f7              [ 3 ]           BRA  LB7B9          ; GET ANOTHER CHARACTER
2525                               
2526                               * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
2527 cf3e 30 04              [ 5 ] LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
2528 cf40 10 8e 00 f4        [ 4 ]           LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
2529 cf44 a6 80              [ 6 ] LB7CB     LDA  ,X+            ; GET A CHARACTER
2530 cf46 27 51              [ 3 ]           BEQ  LB820          ; BRANCH IF END OF LINE
2531 cf48 2b 15              [ 3 ]           BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
2532 cf4a 81 3a              [ 2 ]           CMPA #':            ; CHECK FOR END OF SUB LINE
2533 cf4c 26 0d              [ 3 ]           BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
2534 cf4e e6 84              [ 4 ]           LDB  ,X             ; GET CHARACTER FOLLOWING COLON
2535 cf50 c1 84              [ 2 ]           CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
2536 cf52 27 f0              [ 3 ]           BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2537 cf54 c1 83              [ 2 ]           CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
2538 cf56 27 ec              [ 3 ]           BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2539 cf58 8c                                 FCB  SKP2           ; SKIP TWO BYTES
2540 cf59 86 21              [ 2 ] LB7E0     LDA  #'!            ; EXCLAMATION POINT
2541 cf5b 8d 30              [ 7 ] LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
2542 cf5d 20 e5              [ 3 ]           BRA  LB7CB          ; GET ANOTHER CHARACTER
2543                               
2544 cf5f ce c0 e7           [ 3 ] LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
2545 cf62 81 ff              [ 2 ]           CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
2546 cf64 26 04              [ 3 ]           BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
2547 cf66 a6 80              [ 6 ]           LDA  ,X+            ; GET SECONDARY TOKEN
2548 cf68 33 45              [ 5 ]           LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
2549 cf6a 84 7f              [ 2 ] LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
2550 cf6c 33 4a              [ 5 ] LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
2551 cf6e 6d c4              [ 6 ]           TST  ,U             ; IS THIS TABLE ENABLED?
2552 cf70 27 e7              [ 3 ]           BEQ  LB7E0          ; NO - ILLEGAL TOKEN
2553 cf72 a0 c4              [ 4 ]           SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
2554 cf74 2a f6              [ 3 ]           BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
2555 cf76 ab c4              [ 4 ]           ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
2556 cf78 ee 41              [ 6 ]           LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
2557 cf7a 4a                 [ 2 ] LB801     DECA                ; DECREMENT TOKEN NUMBER
2558 cf7b 2b 06              [ 3 ]           BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
2559                               * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
2560 cf7d 6d c0              [ 8 ] LB804     TST  ,U+            ; GRAB A BYTE
2561 cf7f 2a fc              [ 3 ]           BPL  LB804          ; BRANCH IF BIT 7 NOT SET
2562 cf81 20 f7              [ 3 ]           BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
2563 cf83 a6 c4              [ 4 ] LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
2564 cf85 8d 06              [ 7 ]           BSR  LB814          ; PUT CHARACTER IN BUFFER
2565 cf87 6d c0              [ 8 ]           TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
2566 cf89 2a f8              [ 3 ]           BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
2567 cf8b 20 b7              [ 3 ]           BRA  LB7CB          ; GO GET ANOTHER CHARACTER
2568 cf8d 10 8c 01 ed        [ 5 ] LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
2569 cf91 24 06              [ 3 ]           BCC  LB820          ; BRANCH IF AT END OF BUFFER
2570 cf93 84 7f              [ 2 ]           ANDA #$7F           ; MASK OFF BIT 7
2571 cf95 a7 a0              [ 6 ]           STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
2572 cf97 6f a4              [ 6 ]           CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
2573 cf99 39                 [ 5 ] LB820     RTS
2574                               *
2575                               * CRUNCH THE LINE THAT THE INPUT POINTER IS
2576                               * POINTING TO INTO THE LINE INPUT BUFFER
2577                               * RETURN LENGTH OF CRUNCHED LINE IN ACCD
2578                               *
2579 cf9a 9e 83              [ 5 ] LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
2580 cf9c ce 00 f3           [ 3 ]           LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
2581 cf9f 0f 43              [ 6 ] LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2582 cfa1 0f 44              [ 6 ]           CLR  V44            ; CLEAR DATA FLAG
2583 cfa3 a6 80              [ 6 ] LB82D     LDA  ,X+            ; GET INPUT CHAR
2584 cfa5 27 21              [ 3 ]           BEQ  LB852          ; BRANCH IF END OF LINE
2585 cfa7 0d 43              [ 6 ]           TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
2586 cfa9 27 0f              [ 3 ]           BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
2587 cfab bd cb 29           [ 8 ]           JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
2588 cfae 24 18              [ 3 ]           BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
2589 cfb0 81 30              [ 2 ]           CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
2590 cfb2 25 04              [ 3 ]           BLO  LB842          ; * BRANCH IF NOT NUMERIC
2591 cfb4 81 39              [ 2 ]           CMPA #'9            ; *
2592 cfb6 23 10              [ 3 ]           BLS  LB852          ; * BRANCH IF NUMERIC
2593                               * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
2594 cfb8 0f 43              [ 6 ] LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2595 cfba 81 20              [ 2 ] LB844     CMPA #SPACE         ; SPACE?
2596 cfbc 27 0a              [ 3 ]           BEQ  LB852          ; DO NOT REMOVE SPACES
2597 cfbe 97 42              [ 4 ]           STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
2598 cfc0 81 22              [ 2 ]           CMPA #'"            ; CHECK FOR STRING DELIMITER
2599 cfc2 27 38              [ 3 ]           BEQ  LB886          ; BRANCH IF STRING
2600 cfc4 0d 44              [ 6 ]           TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
2601 cfc6 27 19              [ 3 ]           BEQ  LB86B          ; * DO NOT CRUNCH DATA
2602 cfc8 a7 c0              [ 6 ] LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
2603 cfca 27 06              [ 3 ]           BEQ  LB85C          ; BRANCH IF END OF LINE
2604 cfcc 81 3a              [ 2 ]           CMPA #':            ; * CHECK FOR END OF SUBLINE
2605 cfce 27 cf              [ 3 ]           BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
2606 cfd0 20 d1              [ 3 ] LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
2607 cfd2 6f c0              [ 8 ] LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
2608 cfd4 6f c0              [ 8 ]           CLR  ,U+            ; *
2609 cfd6 1f 30              [ 6 ]           TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
2610 cfd8 83 00 f1           [ 4 ]           SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
2611 cfdb 8e 00 f2           [ 3 ]           LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
2612 cfde 9f 83              [ 5 ]           STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
2613 cfe0 39                 [ 5 ]           RTS                 ; EXIT 'CRUNCH'
2614 cfe1 81 3f              [ 2 ] LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
2615 cfe3 26 04              [ 3 ]           BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
2616 cfe5 86 87              [ 2 ]           LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
2617 cfe7 20 df              [ 3 ]           BRA  LB852          ; * IN BUFFER
2618 cfe9 81 27              [ 2 ] LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
2619 cfeb 26 13              [ 3 ]           BNE  LB88A          ; BRANCH IF NOT REMARK
2620 cfed cc 3a 83           [ 3 ]           LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
2621 cff0 ed c1              [ 8 ]           STD  ,U++           ; SAVE IN BUFFER
2622 cff2 0f 42              [ 6 ] LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
2623 cff4 a6 80              [ 6 ] LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
2624 cff6 27 d0              [ 3 ]           BEQ  LB852          ; BRANCH IF END OF LINE
2625 cff8 91 42              [ 4 ]           CMPA V42            ; DELIMITER?
2626 cffa 27 cc              [ 3 ]           BEQ  LB852          ; BRANCH OUT IF SO
2627 cffc a7 c0              [ 6 ] LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
2628 cffe 20 f4              [ 3 ]           BRA  LB87E          ; GO GET MORE STRING OR REMARK
2629 d000 81 30              [ 2 ] LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
2630 d002 25 04              [ 3 ]           BCS  LB892          ; * BRANCH IF SO
2631 d004 81 3c              [ 2 ]           CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
2632 d006 25 c0              [ 3 ]           BCS  LB852          ; = AND INSERT IN BUFFER IF SO
2633 d008 30 1f              [ 5 ] LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
2634 d00a 34 50              [ 9 ]           PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
2635 d00c 0f 41              [ 6 ]           CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
2636 d00e ce c0 e7           [ 3 ]           LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
2637                               *                             ; TABLE FOR BASIC - 10
2638 d011 0f 42              [ 6 ] LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
2639 d013 33 4a              [ 5 ] LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
2640 d015 a6 c4              [ 4 ]           LDA  ,U             ; GET NUMBER OF COMMANDS
2641 d017 27 31              [ 3 ]           BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
2642 d019 10 ae 41           [ 7 ]           LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
2643 d01c ae e4              [ 5 ] LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
2644 d01e e6 a0              [ 6 ] LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
2645 d020 e0 80              [ 6 ]           SUBB ,X+            ; SUBTRACT INPUT CHARACTER
2646 d022 27 fa              [ 3 ]           BEQ  LB8A8          ; LOOP IF SAME
2647 d024 c1 80              [ 2 ]           CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
2648                               *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
2649                               *                             ; THEN IT IS A GOOD COMPARE
2650 d026 26 38              [ 3 ]           BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
2651 d028 32 62              [ 5 ]           LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
2652 d02a 35 40              [ 7 ]           PULS U              ; GET POINTER TO OUTPUT STRING
2653 d02c da 42              [ 4 ]           ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
2654                               *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
2655 d02e 96 41              [ 4 ]           LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
2656 d030 26 06              [ 3 ]           BNE  LB8C2          ; * IF SECONDARY
2657 d032 c1 84              [ 2 ]           CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
2658 d034 26 06              [ 3 ]           BNE  LB8C6          ; NO
2659 d036 86 3a              [ 2 ]           LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
2660 d038 ed c1              [ 8 ] LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
2661 d03a 20 94              [ 3 ]           BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2662 d03c e7 c0              [ 6 ] LB8C6     STB  ,U+            ; SAVE THIS TOKEN
2663 d03e c1 86              [ 2 ]           CMPB #TOK_DATA      ; DATA TOKEN?
2664 d040 26 02              [ 3 ]           BNE  LB8CE          ; NO
2665 d042 0c 44              [ 6 ]           INC  V44            ; SET DATA FLAG
2666 d044 c1 82              [ 2 ] LB8CE     CMPB #TOK_REM       ; REM TOKEN?
2667 d046 27 aa              [ 3 ]           BEQ  LB87C          ; YES
2668 d048 20 86              [ 3 ] LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2669                               * CHECK FOR A SECONDARY TOKEN
2670 d04a ce c0 ec           [ 3 ] LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
2671 d04d 03 41              [ 6 ]           COM  V41            ; TOGGLE THE TOKEN FLAG
2672 d04f 26 c0              [ 3 ]           BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
2673                               
2674                               * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
2675                               * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
2676 d051 35 50              [ 9 ]           PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
2677 d053 a6 80              [ 6 ]           LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
2678 d055 a7 c0              [ 6 ]           STA  ,U+            ; * ILLEGAL TOKEN
2679 d057 bd cb 29           [ 8 ]           JSR  LB3A2          ; SET CARRY IF NOT ALPHA
2680 d05a 25 ec              [ 3 ]           BCS  LB8D2          ; BRANCH IF NOT ALPHA
2681 d05c 03 43              [ 6 ]           COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
2682 d05e 20 e8              [ 3 ]           BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
2683 d060 0c 42              [ 6 ] LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
2684 d062 4a                 [ 2 ]           DECA                ; DECR COMMAND COUNTER
2685 d063 27 ae              [ 3 ]           BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
2686 d065 31 3f              [ 5 ]           LEAY -1,Y           ; MOVE POINTER BACK ONE
2687 d067 e6 a0              [ 6 ] LB8F1     LDB  ,Y+            ; * GET TO NEXT
2688 d069 2a fc              [ 3 ]           BPL  LB8F1          ; * RESERVED WORD
2689 d06b 20 af              [ 3 ]           BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
2690                               
2691                               * PRINT
2692 d06d 27 39              [ 3 ] PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
2693 d06f 8d 01              [ 7 ]           BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
2694 d071 39                 [ 5 ]           RTS
2695                               LB8FE
2696 d072 bd df d2           [ 8 ] LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
2697 d075 27 3e              [ 3 ] LB91B     BEQ  LB965          ; RETURN IF END OF LINE
2698 d077 81 9f              [ 2 ] LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
2699 d079 27 53              [ 3 ]           BEQ  LB97E          ; YES
2700 d07b 81 2c              [ 2 ]           CMPA #',            ; COMMA?
2701 d07d 27 37              [ 3 ]           BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
2702 d07f 81 3b              [ 2 ]           CMPA #';            ; SEMICOLON?
2703 d081 27 60              [ 3 ]           BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
2704 d083 bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSION
2705 d086 96 06              [ 4 ]           LDA  VALTYP         ; * GET VARIABLE TYPE AND
2706 d088 34 02              [ 6 ]           PSHS A              ; * SAVE IT ON THE STACK
2707 d08a 26 06              [ 3 ]           BNE  LB938          ; BRANCH IF STRING VARIABLE
2708 d08c bd d5 25           [ 8 ]           JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
2709 d08f bd cc 9d           [ 8 ]           JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
2710                               *                             ; DESCRIPTOR ON STRING STACK
2711 d092 8d 57              [ 7 ] LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
2712 d094 35 04              [ 6 ]           PULS B              ; GET VARIABLE TYPE BACK
2713 d096 bd c1 33           [ 8 ]           JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
2714 d099 5d                 [ 2 ] LB949     TSTB                ; CHECK CURRENT PRINT POSITION
2715 d09a 26 08              [ 3 ]           BNE  LB954          ; BRANCH IF NOT AT START OF LINE
2716 d09c 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2717 d09e 81 2c              [ 2 ]           CMPA #',            ; COMMA?
2718 d0a0 27 14              [ 3 ]           BEQ  LB966          ; SKIP TO NEXT TAB FIELD
2719 d0a2 8d 54              [ 7 ]           BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2720 d0a4 9d 82              [ 7 ] LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2721 d0a6 26 cf              [ 3 ]           BNE  LB91D          ; BRANCH IF NOT END OF LINE
2722 d0a8 86 0d              [ 2 ] LB958     LDA  #CR            ; * SEND A CR TO
2723 d0aa 20 51              [ 3 ]           BRA  LB9B1          ; * CONSOLE OUT
2724 d0ac bd c1 33           [ 8 ] LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2725 d0af 27 f7              [ 3 ]           BEQ  LB958          ; BRANCH IF WIDTH = ZERO
2726 d0b1 96 6c              [ 4 ]           LDA  DEVPOS         ; GET PRINT POSITION
2727 d0b3 26 f3              [ 3 ]           BNE  LB958          ; BRANCH IF NOT AT START OF LINE
2728 d0b5 39                 [ 5 ] LB965     RTS
2729                               * SKIP TO NEXT TAB FIELD
2730 d0b6 bd c1 33           [ 8 ] LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2731 d0b9 27 0a              [ 3 ]           BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
2732 d0bb d6 6c              [ 4 ]           LDB  DEVPOS         ; GET CURRENT POSITION
2733 d0bd d1 6b              [ 4 ]           CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
2734 d0bf 25 06              [ 3 ]           BCS  LB977          ; BRANCH IF < LAST TAB ZONE
2735 d0c1 8d e5              [ 7 ]           BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
2736 d0c3 20 1e              [ 3 ]           BRA  LB997          ; GET MORE DATA
2737 d0c5 d6 6c              [ 4 ] LB975     LDB  DEVPOS         ; *
2738 d0c7 d0 6a              [ 4 ] LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
2739 d0c9 24 fc              [ 3 ]           BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
2740 d0cb 50                 [ 2 ]           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
2741                               *              ; * TAB ZONE IN ACCB
2742 d0cc 20 10              [ 3 ]           BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
2743                               
2744                               * PRINT TAB(
2745 d0ce bd ce 90           [ 8 ] LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
2746 d0d1 81 29              [ 2 ]           CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
2747 d0d3 10 26 f9 2c        [ 6 ]           LBNE LB277          ; *
2748 d0d7 bd c1 33           [ 8 ]           JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2749 d0da d0 6c              [ 4 ]           SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
2750 d0dc 23 05              [ 3 ]           BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
2751                               LB98E
2752 d0de 8d 18              [ 7 ] LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2753 d0e0 5a                 [ 2 ]           DECB                ; DECREMENT DIFFERENCE COUNT
2754 d0e1 26 fb              [ 3 ]           BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
2755 d0e3 9d 7c              [ 7 ] LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2756 d0e5 7e d0 75           [ 4 ]           JMP  LB91B          ; LOOK FOR MORE PRINT DATA
2757                               * COPY A STRING FROM (X) TO CONSOLE OUT
2758 d0e8 bd cc 9f           [ 8 ] LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
2759                               *         DESCRIPTOR ON STRING STACK
2760 d0eb bd cd de           [ 8 ] LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
2761                               *         DESCRIPTOR FROM STRING STACK
2762 d0ee 5c                 [ 2 ]           INCB                ; COMPENSATE FOR DECB BELOW
2763 d0ef 5a                 [ 2 ] LB9A3     DECB                ; DECREMENT COUNTER
2764 d0f0 27 c3              [ 3 ]           BEQ  LB965          ; EXIT ROUTINE
2765 d0f2 a6 80              [ 6 ]           LDA  ,X+            ; GET A CHARACTER FROM X
2766 d0f4 8d 07              [ 7 ]           BSR  LB9B1          ; SEND TO CONSOLE OUT
2767 d0f6 20 f7              [ 3 ]           BRA  LB9A3          ; KEEP LOOPING
2768 d0f8 86 20              [ 2 ] LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
2769 d0fa 8c                                 FCB  SKP2           ; SKIP NEXT TWO BYTES
2770 d0fb 86 3f              [ 2 ] LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
2771 d0fd 7e c0 17           [ 4 ] LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
2772                               
2773                               * FLOATING POINT MATH PACKAGE
2774                               
2775                               * ADD .5 TO FPA0
2776 d100 8e d6 0c           [ 3 ] LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
2777 d103 20 09              [ 3 ]           BRA  LB9C2          ; ADD .5 TO FPA0
2778                               * SUBTRACT FPA0 FROM FP NUMBER POINTED
2779                               * TO BY (X), LEAVE RESULT IN FPA0
2780 d105 bd d2 7b           [ 8 ] LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
2781                               
2782                               * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
2783                               * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
2784 d108 03 54              [ 6 ] LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
2785 d10a 03 62              [ 6 ]           COM  RESSGN         ; REVERSE RESULT SIGN FLAG
2786 d10c 20 03              [ 3 ]           BRA  LB9C5          ; GO ADD FPA1 AND FPA0
2787                               * ADD FP NUMBER POINTED TO BY
2788                               * (X) TO FPA0 - LEAVE RESULT IN FPA0
2789 d10e bd d2 7b           [ 8 ] LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
2790                               *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
2791                               
2792                               * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
2793                               
2794 d111 5d                 [ 2 ] LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
2795 d112 10 27 02 80        [ 6 ]           LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
2796 d116 8e 00 5c           [ 3 ]           LDX  #FP1EXP        ; POINT X TO FPA1
2797 d119 1f 89              [ 6 ] LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
2798 d11b 5d                 [ 2 ]           TSTB                ; CHECK EXPONENT
2799 d11c 27 6c              [ 3 ]           BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
2800 d11e d0 4f              [ 4 ]           SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
2801 d120 27 69              [ 3 ]           BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
2802 d122 25 0a              [ 3 ]           BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
2803 d124 97 4f              [ 4 ]           STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
2804 d126 96 61              [ 4 ]           LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
2805 d128 97 54              [ 4 ]           STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
2806 d12a 8e 00 4f           [ 3 ]           LDX  #FP0EXP        ; POINT X TO FPA0
2807 d12d 50                 [ 2 ]           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
2808 d12e c1 f8              [ 2 ] LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
2809 d130 2f 59              [ 3 ]           BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
2810 d132 4f                 [ 2 ]           CLRA                ; CLEAR OVERFLOW BYTE
2811 d133 64 01              [ 7 ]           LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
2812 d135 bd d2 06           [ 8 ]           JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
2813 d138 d6 62              [ 4 ] LB9EC     LDB  RESSGN         ; GET SIGN FLAG
2814 d13a 2a 0b              [ 3 ]           BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
2815 d13c 63 01              [ 7 ]           COM  1,X            ; * COMPLEMENT MANTISSA POINTED
2816 d13e 63 02              [ 7 ]           COM  2,X            ; * TO BY (X) THE
2817 d140 63 03              [ 7 ]           COM  3,X            ; * ADCA BELOW WILL
2818 d142 63 04              [ 7 ]           COM  4,X            ; * CONVERT THIS OPERATION
2819 d144 43                 [ 2 ]           COMA                ; * INTO A NEG (MANTISSA)
2820 d145 89 00              [ 2 ]           ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
2821                               * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
2822                               *
2823                               * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
2824 d147 97 63              [ 4 ] LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
2825 d149 96 53              [ 4 ]           LDA  FPA0+3         ; * ADD LS BYTE
2826 d14b 99 60              [ 4 ]           ADCA FPA1+3         ; * OF MANTISSA
2827 d14d 97 53              [ 4 ]           STA  FPA0+3         ; SAVE IN FPA0 LSB
2828 d14f 96 52              [ 4 ]           LDA  FPA0+2         ; * ADD NEXT BYTE
2829 d151 99 5f              [ 4 ]           ADCA FPA1+2         ; * OF MANTISSA
2830 d153 97 52              [ 4 ]           STA  FPA0+2         ; SAVE IN FPA0
2831 d155 96 51              [ 4 ]           LDA  FPA0+1         ; * ADD NEXT BYTE
2832 d157 99 5e              [ 4 ]           ADCA FPA1+1         ; * OF MANTISSA
2833 d159 97 51              [ 4 ]           STA  FPA0+1         ; SAVE IN FPA0
2834 d15b 96 50              [ 4 ]           LDA  FPA0           ; * ADD MS BYTE
2835 d15d 99 5d              [ 4 ]           ADCA FPA1           ; * OF MANTISSA
2836 d15f 97 50              [ 4 ]           STA  FPA0           ; SAVE IN FPA0
2837 d161 5d                 [ 2 ]           TSTB                ; TEST SIGN FLAG
2838 d162 2a 44              [ 3 ]           BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
2839 d164 25 02              [ 3 ] LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
2840 d166 8d 5d              [ 7 ]           BSR  LBA79          ; NEGATE FPA0 MANTISSA
2841                               
2842                               * NORMALIZE FPA0
2843 d168 5f                 [ 2 ] LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
2844 d169 96 50              [ 4 ] LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
2845 d16b 26 2e              [ 3 ]           BNE  LBA4F          ; BRANCH IF <> 0
2846 d16d 96 51              [ 4 ]           LDA  FPA0+1         ; * IF THE MSB IS
2847 d16f 97 50              [ 4 ]           STA  FPA0           ; * 0, THEN SHIFT THE
2848 d171 96 52              [ 4 ]           LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
2849 d173 97 51              [ 4 ]           STA  FPA0+1         ; * AT A TIME. THIS
2850 d175 96 53              [ 4 ]           LDA  FPA0+3         ; * IS FASTER THAN ONE
2851 d177 97 52              [ 4 ]           STA  FPA0+2         ; * BIT AT A TIME
2852 d179 96 63              [ 4 ]           LDA  FPSBYT         ; * BUT USES MORE MEMORY.
2853 d17b 97 53              [ 4 ]           STA  FPA0+3         ; * FPSBYT, THE CARRY IN
2854 d17d 0f 63              [ 6 ]           CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
2855 d17f cb 08              [ 2 ]           ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
2856 d181 c1 28              [ 2 ]           CMPB #5*8           ; CHECK FOR 5 SHIFTS
2857 d183 2d e4              [ 3 ]           BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
2858 d185 4f                 [ 2 ] LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
2859 d186 97 4f              [ 4 ] LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
2860 d188 97 54              [ 4 ]           STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
2861 d18a 39                 [ 5 ] LBA3E     RTS
2862 d18b 8d 6d              [ 7 ] LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
2863 d18d 5f                 [ 2 ]           CLRB                ; CLEAR CARRY FLAG
2864 d18e 20 a8              [ 3 ]           BRA  LB9EC
2865                               * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
2866                               * OF MATISSA MS BYTE = 1
2867 d190 5c                 [ 2 ] LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
2868 d191 08 63              [ 6 ]           ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
2869 d193 09 53              [ 6 ]           ROL  FPA0+3         ; SHIFT LS BYTE
2870 d195 09 52              [ 6 ]           ROL  FPA0+2         ; SHIFT NS BYTE
2871 d197 09 51              [ 6 ]           ROL  FPA0+1         ; SHIFT NS BYTE
2872 d199 09 50              [ 6 ]           ROL  FPA0           ; SHIFT MS BYTE
2873 d19b 2a f3              [ 3 ] LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
2874 d19d 96 4f              [ 4 ]           LDA  FP0EXP         ; GET CURRENT EXPONENT
2875 d19f 34 04              [ 6 ]           PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
2876 d1a1 a0 e0              [ 6 ]           SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
2877 d1a3 97 4f              [ 4 ]           STA  FP0EXP         ; SAVE AS NEW EXPONENT
2878 d1a5 23 de              [ 3 ]           BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
2879                               *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
2880                               *         SIZE OF THE EXPONENT
2881 d1a7 8c                                 FCB  SKP2           ; SKIP 2 BYTES
2882 d1a8 25 08              [ 3 ] LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
2883 d1aa 08 63              [ 6 ]           ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
2884                               *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
2885 d1ac 86 00              [ 2 ]           LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
2886 d1ae 97 63              [ 4 ]           STA  FPSBYT         ; CLEAR THE SUB BYTE
2887 d1b0 20 0c              [ 3 ]           BRA  LBA72          ; GO ROUND-OFF RESULT
2888 d1b2 0c 4f              [ 6 ] LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
2889 d1b4 27 28              [ 3 ]           BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
2890 d1b6 06 50              [ 6 ]           ROR  FPA0           ; * SHIFT MANTISSA
2891 d1b8 06 51              [ 6 ]           ROR  FPA0+1         ; * ONE TO
2892 d1ba 06 52              [ 6 ]           ROR  FPA0+2         ; * THE RIGHT -
2893 d1bc 06 53              [ 6 ]           ROR  FPA0+3         ; * DIVIDE BY TWO
2894 d1be 24 04              [ 3 ] LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
2895 d1c0 8d 0d              [ 7 ]           BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
2896 d1c2 27 ee              [ 3 ]           BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
2897 d1c4 39                 [ 5 ] LBA78     RTS
2898                               * NEGATE FPA0 MANTISSA
2899 d1c5 03 54              [ 6 ] LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
2900 d1c7 03 50              [ 6 ] LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
2901 d1c9 03 51              [ 6 ]           COM  FPA0+1         ; *
2902 d1cb 03 52              [ 6 ]           COM  FPA0+2         ; *
2903 d1cd 03 53              [ 6 ]           COM  FPA0+3         ; *
2904                               * ADD ONE TO FPA0 MANTISSA
2905 d1cf 9e 52              [ 5 ] LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
2906 d1d1 30 01              [ 5 ]           LEAX 1,X            ; * BYTES, ADD ONE TO
2907 d1d3 9f 52              [ 5 ]           STX  FPA0+2         ; * THEM AND SAVE THEM
2908 d1d5 26 06              [ 3 ]           BNE  LBA91          ; BRANCH IF NO OVERFLOW
2909 d1d7 9e 50              [ 5 ]           LDX  FPA0           ; * IF OVERFLOW ADD ONE
2910 d1d9 30 01              [ 5 ]           LEAX 1,X            ; * TO TOP 2 MANTISSA
2911 d1db 9f 50              [ 5 ]           STX  FPA0           ; * BYTES AND SAVE THEM
2912 d1dd 39                 [ 5 ] LBA91     RTS
2913 d1de c6 0a              [ 2 ] LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
2914 d1e0 7e c4 06           [ 4 ]           JMP  LAC46          ; PROCESS AN ERROR
2915 d1e3 8e 00 12           [ 3 ] LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
2916                               * SHIFT FPA POINTED TO BY (X) TO
2917                               * THE RIGHT -(B) TIMES. EXIT WITH
2918                               * ACCA CONTAINING DATA SHIFTED OUT
2919                               * TO THE RIGHT (SUB BYTE) AND THE DATA
2920                               * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
2921 d1e6 a6 04              [ 5 ] LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
2922 d1e8 97 63              [ 4 ]           STA  FPSBYT         ; SAVE IN FPA SUB BYTE
2923 d1ea a6 03              [ 5 ]           LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
2924 d1ec a7 04              [ 5 ]           STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
2925 d1ee a6 02              [ 5 ]           LDA  2,X            ; *
2926 d1f0 a7 03              [ 5 ]           STA  3,X            ; *
2927 d1f2 a6 01              [ 5 ]           LDA  1,X            ; *
2928 d1f4 a7 02              [ 5 ]           STA  2,X            ; *
2929 d1f6 96 5b              [ 4 ]           LDA  FPCARY         ; GET THE CARRY IN BYTE
2930 d1f8 a7 01              [ 5 ]           STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
2931 d1fa cb 08              [ 2 ] LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
2932 d1fc 2f e8              [ 3 ]           BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
2933 d1fe 96 63              [ 4 ]           LDA  FPSBYT         ; GET FPA SUB BYTE
2934 d200 c0 08              [ 2 ]           SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
2935 d202 27 0c              [ 3 ]           BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
2936                               
2937                               
2938 d204 67 01              [ 7 ] LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
2939 d206 66 02              [ 7 ] LBABA     ROR  2,X            ; *
2940 d208 66 03              [ 7 ]           ROR  3,X            ; *
2941 d20a 66 04              [ 7 ]           ROR  4,X            ; *
2942 d20c 46                 [ 2 ]           RORA                ; *
2943 d20d 5c                 [ 2 ]           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
2944 d20e 26 f4              [ 3 ]           BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
2945 d210 39                 [ 5 ] LBAC4     RTS
2946 d211 81 00 00 00 00           LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
2947                               
2948                               * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
2949                               * FPA0 BY (X) - RETURN PRODUCT IN FPA0
2950 d216 8d 63              [ 7 ] LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
2951 d218 27 60              [ 3 ] LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
2952 d21a 8d 78              [ 7 ]           BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
2953                               * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
2954                               * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
2955                               * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
2956                               * BE STORED IN VAB-VAE.
2957 d21c 86 00              [ 2 ] LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
2958 d21e 97 13              [ 4 ]           STA  FPA2           ; *
2959 d220 97 14              [ 4 ]           STA  FPA2+1         ; *
2960 d222 97 15              [ 4 ]           STA  FPA2+2         ; *
2961 d224 97 16              [ 4 ]           STA  FPA2+3         ; *
2962 d226 d6 53              [ 4 ]           LDB  FPA0+3         ; GET LS BYTE OF FPA0
2963 d228 8d 22              [ 7 ]           BSR  LBB00          ; MULTIPLY BY FPA1
2964 d22a d6 63              [ 4 ]           LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
2965 d22c d7 8b              [ 4 ]           STB  VAE            ; *
2966 d22e d6 52              [ 4 ]           LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
2967 d230 8d 1a              [ 7 ]           BSR  LBB00          ; MULTIPLY BY FPA1
2968 d232 d6 63              [ 4 ]           LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
2969 d234 d7 8a              [ 4 ]           STB  VAD            ; *
2970 d236 d6 51              [ 4 ]           LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
2971 d238 8d 12              [ 7 ]           BSR  LBB00          ; MULTIPLY BY FPA1
2972 d23a d6 63              [ 4 ]           LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
2973 d23c d7 89              [ 4 ]           STB  VAC            ; *
2974 d23e d6 50              [ 4 ]           LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
2975 d240 8d 0c              [ 7 ]           BSR  LBB02          ; MULTIPLY BY FPA1
2976 d242 d6 63              [ 4 ]           LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
2977 d244 d7 88              [ 4 ]           STB  VAB            ; *
2978 d246 bd d3 57           [ 8 ]           JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
2979 d249 7e d1 68           [ 4 ]           JMP  LBA1C          ; NORMALIZE FPA0
2980 d24c 27 95              [ 3 ] LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
2981 d24e 43                 [ 2 ] LBB02     COMA                ; SET CARRY FLAG
2982                               * MULTIPLY FPA1 MANTISSA BY ACCB AND
2983                               * ADD PRODUCT TO FPA2 MANTISSA
2984 d24f 96 13              [ 4 ] LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
2985 d251 56                 [ 2 ]           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
2986                               *         DATA BIT INTO CARRY
2987 d252 27 26              [ 3 ]           BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
2988 d254 24 16              [ 3 ]           BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
2989 d256 96 16              [ 4 ]           LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
2990 d258 9b 60              [ 4 ]           ADDA FPA1+3         ; *
2991 d25a 97 16              [ 4 ]           STA  FPA2+3         ; *
2992 d25c 96 15              [ 4 ]           LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
2993 d25e 99 5f              [ 4 ]           ADCA FPA1+2         ; =
2994 d260 97 15              [ 4 ]           STA  FPA2+2         ; =
2995 d262 96 14              [ 4 ]           LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
2996 d264 99 5e              [ 4 ]           ADCA FPA1+1         ; *
2997 d266 97 14              [ 4 ]           STA  FPA2+1         ; *
2998 d268 96 13              [ 4 ]           LDA  FPA2           ; = ADD MANTISSA MS BYTE
2999 d26a 99 5d              [ 4 ]           ADCA FPA1           ; =
3000 d26c 46                 [ 2 ] LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
3001 d26d 97 13              [ 4 ]           STA  FPA2           ; *
3002 d26f 06 14              [ 6 ]           ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
3003 d271 06 15              [ 6 ]           ROR  FPA2+2         ; =
3004 d273 06 16              [ 6 ]           ROR  FPA2+3         ; =
3005 d275 06 63              [ 6 ]           ROR  FPSBYT         ; =
3006 d277 4f                 [ 2 ]           CLRA                ; CLEAR CARRY FLAG
3007 d278 20 d5              [ 3 ]           BRA  LBB03          ; KEEP LOOPING
3008 d27a 39                 [ 5 ] LBB2E     RTS
3009                               * UNPACK A FP NUMBER FROM (X) TO FPA1
3010 d27b ec 01              [ 6 ] LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
3011                               *         FPA  POINTED TO BY X
3012 d27d 97 61              [ 4 ]           STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
3013 d27f 8a 80              [ 2 ]           ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
3014 d281 dd 5d              [ 5 ]           STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
3015 d283 d6 61              [ 4 ]           LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
3016 d285 d8 54              [ 4 ]           EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
3017 d287 d7 62              [ 4 ]           STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
3018                               *                             ; * MANTISSA SIGN BYTE
3019 d289 ec 03              [ 6 ]           LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
3020 d28b dd 5f              [ 5 ]           STD  FPA1+2         ; = AND PUT IN FPA1
3021 d28d a6 84              [ 4 ]           LDA  ,X             ; * GET EXPONENT FROM (X) AND
3022 d28f 97 5c              [ 4 ]           STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
3023 d291 d6 4f              [ 4 ]           LDB  FP0EXP         ; GET EXPONENT OF FPA0
3024 d293 39                 [ 5 ]           RTS
3025                               * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
3026                               * ENTER WITH EXPONENT OF FPA1 IN ACCA
3027 d294 4d                 [ 2 ] LBB48     TSTA                ; TEST EXPONENT OF FPA1
3028 d295 27 16              [ 3 ]           BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
3029 d297 9b 4f              [ 4 ]           ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
3030 d299 46                 [ 2 ]           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
3031 d29a 49                 [ 2 ]           ROLA                ; SET OVERFLOW FLAG
3032 d29b 28 10              [ 3 ]           BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
3033 d29d 8b 80              [ 2 ]           ADDA #$80           ; ADD $80 BIAS TO EXPONENT
3034 d29f 97 4f              [ 4 ]           STA  FP0EXP         ; SAVE NEW EXPONENT
3035 d2a1 27 0c              [ 3 ]           BEQ  LBB63          ; SET FPA0
3036 d2a3 96 62              [ 4 ]           LDA  RESSGN         ; GET MANTISSA SIGN
3037 d2a5 97 54              [ 4 ]           STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
3038 d2a7 39                 [ 5 ]           RTS
3039                               * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
3040                               * = IS NEGATIVE THEN FPA0 = 0
3041 d2a8 96 54              [ 4 ] LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3042 d2aa 43                 [ 2 ]           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
3043 d2ab 20 02              [ 3 ]           BRA  LBB63
3044 d2ad 32 62              [ 5 ] LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
3045 d2af 10 2a fe d2        [ 6 ] LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
3046 d2b3 7e d1 de           [ 4 ] LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
3047                               * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
3048 d2b6 bd d3 ab           [ 8 ] LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
3049 d2b9 27 0d              [ 3 ]           BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
3050 d2bb 8b 02              [ 2 ]           ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
3051 d2bd 25 f4              [ 3 ]           BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3052 d2bf 0f 62              [ 6 ]           CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
3053 d2c1 bd d1 19           [ 8 ]           JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
3054 d2c4 0c 4f              [ 6 ]           INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
3055 d2c6 27 eb              [ 3 ]           BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3056 d2c8 39                 [ 5 ] LBB7C     RTS
3057 d2c9 84 20 00 00 00           LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
3058                               * DIVIDE FPA0 BY 10
3059 d2ce bd d3 ab           [ 8 ] LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
3060 d2d1 8e d2 c9           [ 3 ]           LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
3061 d2d4 5f                 [ 2 ]           CLRB                ; ZERO MANTISSA SIGN BYTE
3062 d2d5 d7 62              [ 4 ] LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
3063 d2d7 bd d3 60           [ 8 ]           JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
3064 d2da 8c                                 FCB  SKP2           ; SKIP TWO BYTES
3065                               * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
3066 d2db 8d 9e              [ 7 ] LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
3067                               
3068                               * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
3069                               * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
3070                               
3071                               * DIVIDE FPA1 BY FPA0
3072 d2dd 27 73              [ 3 ] LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
3073 d2df 00 4f              [ 6 ]           NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
3074 d2e1 8d b1              [ 7 ]           BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
3075 d2e3 0c 4f              [ 6 ]           INC  FP0EXP         ; INCREMENT EXPONENT
3076 d2e5 27 cc              [ 3 ]           BEQ  LBB67          ; 'OV' OVERFLOW ERROR
3077 d2e7 8e 00 13           [ 3 ]           LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
3078                               *                             ; TEMPORARY QUOTIENT IN FPA2
3079 d2ea c6 04              [ 2 ]           LDB  #4             ; 5 BYTE DIVIDE
3080 d2ec d7 03              [ 4 ]           STB  TMPLOC         ; SAVE BYTE COUNTER
3081 d2ee c6 01              [ 2 ]           LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
3082                               * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
3083                               * SET CARRY FLAG IF FPA1 >= FPA0
3084 d2f0 96 50              [ 4 ] LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
3085 d2f2 91 5d              [ 4 ]           CMPA FPA1           ; * OF FPA0 AND FPA1 AND
3086 d2f4 26 13              [ 3 ]           BNE  LBBBD          ; * BRANCH IF <>
3087 d2f6 96 51              [ 4 ]           LDA  FPA0+1         ; = COMPARE THE NUMBER 2
3088 d2f8 91 5e              [ 4 ]           CMPA FPA1+1         ; = BYTES AND
3089 d2fa 26 0d              [ 3 ]           BNE  LBBBD          ; = BRANCH IF <>
3090 d2fc 96 52              [ 4 ]           LDA  FPA0+2         ; * COMPARE THE NUMBER 3
3091 d2fe 91 5f              [ 4 ]           CMPA FPA1+2         ; * BYTES AND
3092 d300 26 07              [ 3 ]           BNE  LBBBD          ; * BRANCH IF <>
3093 d302 96 53              [ 4 ]           LDA  FPA0+3         ; = COMPARE THE LS BYTES
3094 d304 91 60              [ 4 ]           CMPA FPA1+3         ; = AND BRANCH
3095 d306 26 01              [ 3 ]           BNE  LBBBD          ; = IF <>
3096 d308 43                 [ 2 ]           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
3097 d309 1f a8              [ 6 ] LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
3098                               *         CLEAR IF FPA0 > FPA1
3099 d30b 59                 [ 2 ]           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
3100 d30c 24 0a              [ 3 ]           BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
3101 d30e e7 80              [ 6 ]           STB  ,X+            ; SAVE TEMPORARY QUOTIENT
3102 d310 0a 03              [ 6 ]           DEC  TMPLOC         ; DECREMENT BYTE COUNTER
3103 d312 2b 34              [ 3 ]           BMI  LBBFC          ; BRANCH IF DONE
3104 d314 27 2e              [ 3 ]           BEQ  LBBF8          ; BRANCH IF LAST BYTE
3105 d316 c6 01              [ 2 ]           LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
3106 d318 1f 8a              [ 6 ] LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
3107 d31a 25 0e              [ 3 ]           BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
3108 d31c 08 60              [ 6 ] LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
3109 d31e 09 5f              [ 6 ]           ROL  FPA1+2         ; *
3110 d320 09 5e              [ 6 ]           ROL  FPA1+1         ; *
3111 d322 09 5d              [ 6 ]           ROL  FPA1           ; *
3112 d324 25 e3              [ 3 ]           BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
3113 d326 2b c8              [ 3 ]           BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
3114                               *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
3115 d328 20 df              [ 3 ]           BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
3116                               * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
3117 d32a 96 60              [ 4 ] LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
3118 d32c 90 53              [ 4 ]           SUBA FPA0+3         ; *
3119 d32e 97 60              [ 4 ]           STA  FPA1+3         ; *
3120 d330 96 5f              [ 4 ]           LDA  FPA1+2         ; = THEN THE NEXT BYTE
3121 d332 92 52              [ 4 ]           SBCA FPA0+2         ; =
3122 d334 97 5f              [ 4 ]           STA  FPA1+2         ; =
3123 d336 96 5e              [ 4 ]           LDA  FPA1+1         ; * AND THE NEXT
3124 d338 92 51              [ 4 ]           SBCA FPA0+1         ; *
3125 d33a 97 5e              [ 4 ]           STA  FPA1+1         ; *
3126 d33c 96 5d              [ 4 ]           LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
3127 d33e 92 50              [ 4 ]           SBCA FPA0           ; =
3128 d340 97 5d              [ 4 ]           STA  FPA1           ; =
3129 d342 20 d8              [ 3 ]           BRA  LBBD0          ; GO SHIFT FPA1
3130 d344 c6 40              [ 2 ] LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
3131 d346 20 d0              [ 3 ]           BRA  LBBCC          ; GO SHIFT THE LAST BYTE
3132 d348 56                 [ 2 ] LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
3133 d349 56                 [ 2 ]           RORB                ; * BIT 5 AND MOVE
3134 d34a 56                 [ 2 ]           RORB                ; * BITS 1,0 TO BITS 7,6
3135 d34b d7 63              [ 4 ]           STB  FPSBYT         ; SAVE SUB BYTE
3136 d34d 8d 08              [ 7 ]           BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
3137 d34f 7e d1 68           [ 4 ]           JMP  LBA1C          ; NORMALIZE FPA0
3138 d352 c6 14              [ 2 ] LBC06     LDB  #2*10          ; /0' ERROR
3139 d354 7e c4 06           [ 4 ]           JMP  LAC46          ; PROCESS THE ERROR
3140                               * COPY MANTISSA FROM FPA2 TO FPA0
3141 d357 9e 13              [ 5 ] LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
3142 d359 9f 50              [ 5 ]           STX  FPA0           ; *
3143 d35b 9e 15              [ 5 ]           LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
3144 d35d 9f 52              [ 5 ]           STX  FPA0+2         ; =
3145 d35f 39                 [ 5 ]           RTS
3146                               * COPY A PACKED FP NUMBER FROM (X) TO FPA0
3147 d360 34 02              [ 6 ] LBC14     PSHS A              ; SAVE ACCA
3148 d362 ec 01              [ 6 ]           LDD  1,X            ; GET TOP TWO MANTISSA BYTES
3149 d364 97 54              [ 4 ]           STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
3150 d366 8a 80              [ 2 ]           ORA  #$80           ; UNPACK MS BYTE
3151 d368 dd 50              [ 5 ]           STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
3152 d36a 0f 63              [ 6 ]           CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3153 d36c e6 84              [ 4 ]           LDB  ,X             ; GET EXPONENT TO ACCB
3154 d36e ae 03              [ 6 ]           LDX  3,X            ; * MOVE LAST 2
3155 d370 9f 52              [ 5 ]           STX  FPA0+2         ; * MANTISSA BYTES
3156 d372 d7 4f              [ 4 ]           STB  FP0EXP         ; SAVE EXPONENT
3157 d374 35 82              [ 8 ]           PULS A,PC           ; RESTORE ACCA AND RETURN
3158                               
3159 d376 8e 00 45           [ 3 ] LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
3160 d379 20 06              [ 3 ]           BRA  LBC35          ; MOVE FPA0 TO FPA4
3161 d37b 8e 00 40           [ 3 ] LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
3162 d37e 8c                                 FCB  SKP2           ; SKIP TWO BYTES
3163 d37f 9e 3b              [ 5 ] LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
3164                               * PACK FPA0 AND MOVE IT TO ADDRESS IN X
3165 d381 96 4f              [ 4 ] LBC35     LDA  FP0EXP         ; * COPY EXPONENT
3166 d383 a7 84              [ 4 ]           STA  ,X             ; *
3167 d385 96 54              [ 4 ]           LDA  FP0SGN         ; GET MANTISSA SIGN BIT
3168 d387 8a 7f              [ 2 ]           ORA  #$7F           ; MASK THE BOTTOM 7 BITS
3169 d389 94 50              [ 4 ]           ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
3170 d38b a7 01              [ 5 ]           STA  1,X            ; SAVE MS BYTE
3171 d38d 96 51              [ 4 ]           LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
3172 d38f a7 02              [ 5 ]           STA  2,X            ; *
3173 d391 de 52              [ 5 ]           LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
3174 d393 ef 03              [ 6 ]           STU  3,X            ; =
3175 d395 39                 [ 5 ]           RTS
3176                               * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
3177 d396 96 61              [ 4 ] LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
3178 d398 97 54              [ 4 ] LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
3179 d39a 9e 5c              [ 5 ]           LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
3180 d39c 9f 4f              [ 5 ]           STX  FP0EXP         ; = FPA1 TO FPA0
3181 d39e 0f 63              [ 6 ]           CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3182 d3a0 96 5e              [ 4 ]           LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
3183 d3a2 97 51              [ 4 ]           STA  FPA0+1         ; * FROM FPA1 TO FPA0
3184 d3a4 96 54              [ 4 ]           LDA  FP0SGN         ; GET MANTISSA SIGN
3185 d3a6 9e 5f              [ 5 ]           LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
3186 d3a8 9f 52              [ 5 ]           STX  FPA0+2         ; * FROM FPA1 TO FPA0
3187 d3aa 39                 [ 5 ]           RTS
3188                               * TRANSFER FPA0 TO FPA1
3189 d3ab dc 4f              [ 5 ] LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
3190 d3ad dd 5c              [ 5 ]           STD  FP1EXP         ; *
3191 d3af 9e 51              [ 5 ]           LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
3192 d3b1 9f 5e              [ 5 ]           STX  FPA1+1         ; =
3193 d3b3 9e 53              [ 5 ]           LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
3194 d3b5 9f 60              [ 5 ]           STX  FPA1+3         ; *
3195 d3b7 4d                 [ 2 ]           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
3196 d3b8 39                 [ 5 ]           RTS
3197                               * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
3198                               * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
3199 d3b9 d6 4f              [ 4 ] LBC6D     LDB  FP0EXP         ; GET EXPONENT
3200 d3bb 27 08              [ 3 ]           BEQ  LBC79          ; BRANCH IF FPA0 = 0
3201 d3bd d6 54              [ 4 ] LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
3202 d3bf 59                 [ 2 ] LBC73     ROLB                ; BIT 7 TO CARRY
3203 d3c0 c6 ff              [ 2 ]           LDB  #$FF           ; NEGATIVE FLAG
3204 d3c2 25 01              [ 3 ]           BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
3205 d3c4 50                 [ 2 ]           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
3206 d3c5 39                 [ 5 ] LBC79     RTS
3207                               
3208                               * SGN
3209 d3c6 8d f1              [ 7 ] SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
3210                               * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
3211 d3c8 d7 50              [ 4 ] LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
3212 d3ca 0f 51              [ 6 ]           CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
3213 d3cc c6 88              [ 2 ]           LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
3214 d3ce 96 50              [ 4 ] LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
3215 d3d0 80 80              [ 2 ]           SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
3216 d3d2 d7 4f              [ 4 ] LBC86     STB  FP0EXP         ; SAVE EXPONENT
3217 d3d4 dc 74              [ 5 ]           LDD  ZERO           ; * ZERO OUT ACCD AND
3218 d3d6 dd 52              [ 5 ]           STD  FPA0+2         ; * BOTTOM HALF OF FPA0
3219 d3d8 97 63              [ 4 ]           STA  FPSBYT         ; CLEAR SUB BYTE
3220 d3da 97 54              [ 4 ]           STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
3221 d3dc 7e d1 64           [ 4 ]           JMP  LBA18          ; GO NORMALIZE FPA0
3222                               
3223                               * ABS
3224 d3df 0f 54              [ 6 ] ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
3225 d3e1 39                 [ 5 ]           RTS
3226                               * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
3227                               * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
3228                               * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
3229                               * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
3230 d3e2 e6 84              [ 4 ] LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
3231 d3e4 27 d3              [ 3 ]           BEQ  LBC6D          ; BRANCH IF FPA = 0
3232 d3e6 e6 01              [ 5 ]           LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
3233 d3e8 d8 54              [ 4 ]           EORB FP0SGN         ; EOR WITH SIGN OF FPA0
3234 d3ea 2b d1              [ 3 ]           BMI  LBC71          ; BRANCH IF SIGNS NOT =
3235                               * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
3236                               * FPA0 IS NORMALIZED, (X) IS PACKED.
3237 d3ec d6 4f              [ 4 ] LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
3238 d3ee e1 84              [ 4 ]           CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
3239 d3f0 26 1d              [ 3 ]           BNE  LBCC3          ; * (X) AND BRANCH IF <>.
3240 d3f2 e6 01              [ 5 ]           LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
3241 d3f4 ca 7f              [ 2 ]           ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
3242 d3f6 d4 50              [ 4 ]           ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
3243 d3f8 e1 01              [ 5 ]           CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
3244 d3fa 26 13              [ 3 ]           BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
3245 d3fc d6 51              [ 4 ]           LDB  FPA0+1         ; * COMPARE 2ND BYTE
3246 d3fe e1 02              [ 5 ]           CMPB 2,X            ; * OF MANTISSA,
3247 d400 26 0d              [ 3 ]           BNE  LBCC3          ; * BRANCH IF <>
3248 d402 d6 52              [ 4 ]           LDB  FPA0+2         ; = COMPARE 3RD BYTE
3249 d404 e1 03              [ 5 ]           CMPB 3,X            ; = OF MANTISSA,
3250 d406 26 07              [ 3 ]           BNE  LBCC3          ; = BRANCH IF <>
3251 d408 d6 53              [ 4 ]           LDB  FPA0+3         ; * SUBTRACT LS BYTE
3252 d40a e0 04              [ 5 ]           SUBB 4,X            ; * OF (X) FROM LS BYTE OF
3253 d40c 26 01              [ 3 ]           BNE  LBCC3          ; * FPA0, BRANCH IF <>
3254 d40e 39                 [ 5 ]           RTS                 ; RETURN IF FP (X) = FPA0
3255 d40f 56                 [ 2 ] LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
3256 d410 d8 54              [ 4 ]           EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
3257 d412 20 ab              [ 3 ]           BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
3258                               * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
3259                               * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
3260 d414 d6 4f              [ 4 ] LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3261 d416 27 3d              [ 3 ]           BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
3262 d418 c0 a0              [ 2 ]           SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
3263                               *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
3264                               *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
3265                               *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
3266 d41a 96 54              [ 4 ]           LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
3267 d41c 2a 05              [ 3 ]           BPL  LBCD7          ; BRANCH IF POSITIVE
3268 d41e 03 5b              [ 6 ]           COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
3269 d420 bd d1 c7           [ 8 ]           JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
3270 d423 8e 00 4f           [ 3 ] LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
3271 d426 c1 f8              [ 2 ]           CMPB #-8            ; EXPONENT DIFFERENCE < -8?
3272 d428 2e 06              [ 3 ]           BGT  LBCE4          ; YES
3273 d42a bd d1 fa           [ 8 ]           JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
3274 d42d 0f 5b              [ 6 ]           CLR  FPCARY         ; CLEAR CARRY IN BYTE
3275 d42f 39                 [ 5 ]           RTS
3276 d430 0f 5b              [ 6 ] LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
3277 d432 96 54              [ 4 ]           LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
3278 d434 49                 [ 2 ]           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
3279 d435 06 50              [ 6 ]           ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
3280                               *                             ; OF LS BYTE OF MANTISSA
3281 d437 7e d2 06           [ 4 ]           JMP  LBABA          ; DE-NORMALIZE FPA0
3282                               
3283                               * INT
3284                               * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
3285                               * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
3286                               * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
3287                               * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
3288                               * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
3289                               *
3290 d43a d6 4f              [ 4 ] INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
3291 d43c c1 a0              [ 2 ]           CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
3292 d43e 24 1d              [ 3 ]           BCC  LBD11          ; RETURN IF FPA0 >= 32768
3293 d440 8d d2              [ 7 ]           BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
3294                               *                             ; LS BYTE OF THE FPA0 MANTISSA
3295 d442 d7 63              [ 4 ]           STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
3296 d444 96 54              [ 4 ]           LDA  FP0SGN         ; GET MANTISSA SIGN
3297 d446 d7 54              [ 4 ]           STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
3298 d448 80 80              [ 2 ]           SUBA #$80           ; SET CARRY IF MANTISSA
3299 d44a 86 a0              [ 2 ]           LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
3300 d44c 97 4f              [ 4 ]           STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
3301 d44e 96 53              [ 4 ]           LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
3302 d450 97 01              [ 4 ]           STA  CHARAC         ; = SAVE IT IN CHARAC
3303 d452 7e d1 64           [ 4 ]           JMP  LBA18          ; NORMALIZE FPA0
3304                               
3305 d455 d7 50              [ 4 ] LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
3306 d457 d7 51              [ 4 ]           STB  FPA0+1         ; *
3307 d459 d7 52              [ 4 ]           STB  FPA0+2         ; *
3308 d45b d7 53              [ 4 ]           STB  FPA0+3         ; *
3309 d45d 39                 [ 5 ] LBD11     RTS                 ; *
3310                               
3311                               * CONVERT ASCII STRING TO FLOATING POINT
3312 d45e 9e 74              [ 5 ] LBD12     LDX  ZERO           ; (X) = 0
3313 d460 9f 54              [ 5 ]           STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
3314 d462 9f 4f              [ 5 ]           STX  FP0EXP         ; *
3315 d464 9f 51              [ 5 ]           STX  FPA0+1         ; *
3316 d466 9f 52              [ 5 ]           STX  FPA0+2         ; *
3317 d468 9f 47              [ 5 ]           STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
3318 d46a 9f 45              [ 5 ]           STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
3319 d46c 25 64              [ 3 ]           BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
3320                               *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
3321 d46e bd db 9b           [ 8 ]           JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
3322 d471 81 2d              [ 2 ] LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
3323 d473 26 04              [ 3 ]           BNE  LBD2D          ; * IF NO MINUS SIGN
3324 d475 03 55              [ 6 ]           COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
3325 d477 20 04              [ 3 ]           BRA  LBD31          ; INTERPRET THE REST OF THE STRING
3326 d479 81 2b              [ 2 ] LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
3327 d47b 26 04              [ 3 ]           BNE  LBD35          ; * IF NOT A PLUS SIGN
3328 d47d 9d 7c              [ 7 ] LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3329 d47f 25 51              [ 3 ]           BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
3330 d481 81 2e              [ 2 ] LBD35     CMPA #'.            ; DECIMAL POlNT?
3331 d483 27 28              [ 3 ]           BEQ  LBD61          ; YES
3332 d485 81 45              [ 2 ]           CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
3333 d487 26 28              [ 3 ]           BNE  LBD65          ; NO
3334                               * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
3335 d489 9d 7c              [ 7 ]           JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3336 d48b 25 64              [ 3 ]           BCS  LBDA5          ; BRANCH IF NUMERIC
3337 d48d 81 a7              [ 2 ]           CMPA #TOK_MINUS     ; MINUS TOKEN?
3338 d48f 27 0e              [ 3 ]           BEQ  LBD53          ; YES
3339 d491 81 2d              [ 2 ]           CMPA #'-            ; ASCII MINUS?
3340 d493 27 0a              [ 3 ]           BEQ  LBD53          ; YES
3341 d495 81 a6              [ 2 ]           CMPA #TOK_PLUS      ; PLUS TOKEN?
3342 d497 27 08              [ 3 ]           BEQ  LBD55          ; YES
3343 d499 81 2b              [ 2 ]           CMPA #'+            ; ASCII PLUS?
3344 d49b 27 04              [ 3 ]           BEQ  LBD55          ; YES
3345 d49d 20 06              [ 3 ]           BRA  LBD59          ; BRANCH IF NO SIGN FOUND
3346 d49f 03 48              [ 6 ] LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
3347                               * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
3348 d4a1 9d 7c              [ 7 ] LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3349 d4a3 25 4c              [ 3 ]           BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
3350 d4a5 0d 48              [ 6 ] LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
3351 d4a7 27 08              [ 3 ]           BEQ  LBD65          ; * AND BRANCH IF POSITIVE
3352 d4a9 00 47              [ 6 ]           NEG  V47            ; NEGATE VALUE OF EXPONENT
3353 d4ab 20 04              [ 3 ]           BRA  LBD65
3354 d4ad 03 46              [ 6 ] LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
3355 d4af 26 cc              [ 3 ]           BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
3356                               *         IF   SECOND DECIMAL POINT
3357                               * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
3358 d4b1 96 47              [ 4 ] LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
3359 d4b3 90 45              [ 4 ]           SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
3360 d4b5 97 47              [ 4 ]           STA  V47            ; * AND RESAVE IT.
3361 d4b7 27 12              [ 3 ]           BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
3362 d4b9 2a 09              [ 3 ]           BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
3363 d4bb bd d2 ce           [ 8 ] LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
3364 d4be 0c 47              [ 6 ]           INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
3365 d4c0 26 f9              [ 3 ]           BNE  LBD6F          ; KEEP MULTIPLYING
3366 d4c2 20 07              [ 3 ]           BRA  LBD7F          ; EXIT ROUTINE
3367 d4c4 bd d2 b6           [ 8 ] LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3368 d4c7 0a 47              [ 6 ]           DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
3369 d4c9 26 f9              [ 3 ]           BNE  LBD78          ; KEEP MULTIPLYING
3370 d4cb 96 55              [ 4 ] LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
3371 d4cd 2a 8e              [ 3 ]           BPL  LBD11          ; RETURN IF POSITIVE
3372 d4cf 7e d6 35           [ 4 ]           JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
3373                               *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
3374 d4d2 d6 45              [ 4 ] LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
3375 d4d4 d0 46              [ 4 ]           SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
3376 d4d6 d7 45              [ 4 ]           STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
3377                               *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
3378 d4d8 34 02              [ 6 ]           PSHS A              ; SAVE NEW DIGIT ON STACK
3379 d4da bd d2 b6           [ 8 ]           JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3380 d4dd 35 04              [ 6 ]           PULS B              ; GET NEW DIGIT BACK
3381 d4df c0 30              [ 2 ]           SUBB #'0            ; MASK OFF ASCII
3382 d4e1 8d 02              [ 7 ]           BSR  LBD99          ; ADD ACCB TO FPA0
3383 d4e3 20 98              [ 3 ]           BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
3384 d4e5 bd d3 7b           [ 8 ] LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
3385 d4e8 bd d3 c8           [ 8 ]           JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
3386 d4eb 8e 00 40           [ 3 ]           LDX  #V40           ; * ADD FPA0 TO
3387 d4ee 7e d1 0e           [ 4 ]           JMP  LB9C2          ; * FPA3
3388                               
3389                               
3390 d4f1 d6 47              [ 4 ] LBDA5     LDB  V47
3391 d4f3 58                 [ 2 ]           ASLB                ; TIMES 2
3392 d4f4 58                 [ 2 ]           ASLB                ; TIMES 4
3393 d4f5 db 47              [ 4 ]           ADDB V47            ; ADD 1 = TIMES 5
3394 d4f7 58                 [ 2 ]           ASLB                ; TIMES 10
3395 d4f8 80 30              [ 2 ]           SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
3396 d4fa 34 04              [ 6 ]           PSHS B              ; *RESULT ONTO THE STACK AND
3397 d4fc ab e0              [ 6 ]           ADDA ,S+            ; ADD lT TO ACCB
3398 d4fe 97 47              [ 4 ]           STA  V47            ; SAVE IN V47
3399 d500 20 9f              [ 3 ]           BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
3400                               *
3401 d502 9b 3e bc 1f fd           LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
3402 d507 9e 6e 6b 27 fd           LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
3403 d50c 9e 6e 6b 28 00           LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
3404                               *
3405 d511 8e c3 a7           [ 3 ] LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
3406 d514 8d 0c              [ 7 ]           BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
3407 d516 dc 68              [ 5 ]           LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
3408                               * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
3409                               * AND PRINT IT TO CONSOLE OUT
3410 d518 dd 50              [ 5 ] LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
3411 d51a c6 90              [ 2 ]           LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
3412 d51c 43                 [ 2 ]           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
3413 d51d bd d3 d2           [ 8 ]           JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
3414                               *         SAVE EXPONENT AND NORMALIZE IT
3415 d520 8d 03              [ 7 ]           BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
3416 d522 7e d0 e8           [ 4 ] LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
3417                               
3418                               * CONVERT FP NUMBER TO ASCII STRING
3419 d525 ce 01 f1           [ 3 ] LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
3420                               *                             ; THE STRING TO BE STORED IN STRING SPACE
3421 d528 86 20              [ 2 ] LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
3422 d52a d6 54              [ 4 ]           LDB  FP0SGN         ; GET SIGN OF FPA0
3423 d52c 2a 02              [ 3 ]           BPL  LBDE4          ; BRANCH IF POSITIVE
3424 d52e 86 2d              [ 2 ]           LDA  #'-            ; ASCII MINUS SIGN
3425 d530 a7 c0              [ 6 ] LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
3426 d532 df 64              [ 5 ]           STU  COEFPT         ; SAVE BUFFER POINTER
3427 d534 97 54              [ 4 ]           STA  FP0SGN         ; SAVE SIGN (IN ASCII)
3428 d536 86 30              [ 2 ]           LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
3429 d538 d6 4f              [ 4 ]           LDB  FP0EXP         ; GET FPA0 EXPONENT
3430 d53a 10 27 00 c6        [ 6 ]           LBEQ LBEB8          ; BRANCH IF FPA0 = 0
3431 d53e 4f                 [ 2 ]           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
3432 d53f c1 80              [ 2 ]           CMPB #$80           ; CHECK EXPONENT
3433 d541 22 08              [ 3 ]           BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
3434                               * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
3435 d543 8e d5 0c           [ 3 ]           LDX  #LBDC0         ; POINT X TO FP 1E+09
3436 d546 bd d2 16           [ 8 ]           JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3437 d549 86 f7              [ 2 ]           LDA  #-9            ; BASE 10 EXPONENT = -9
3438 d54b 97 45              [ 4 ] LBDFF     STA  V45            ; BASE 10 EXPONENT
3439                               * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
3440                               * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
3441                               * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
3442                               * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
3443                               * SCIENTIFIC NOTATION
3444 d54d 8e d5 07           [ 3 ] LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
3445 d550 bd d3 ec           [ 8 ]           JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
3446 d553 2e 0f              [ 3 ]           BGT  LBE18          ; BRANCH IF > 999,999,999
3447 d555 8e d5 02           [ 3 ] LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
3448 d558 bd d3 ec           [ 8 ]           JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
3449 d55b 2e 0e              [ 3 ]           BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
3450 d55d bd d2 b6           [ 8 ]           JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3451 d560 0a 45              [ 6 ]           DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
3452 d562 20 f1              [ 3 ]           BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
3453 d564 bd d2 ce           [ 8 ] LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
3454 d567 0c 45              [ 6 ]           INC  V45            ; ADD ONE TO BASE 10 EXPONENT
3455 d569 20 e2              [ 3 ]           BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
3456 d56b bd d1 00           [ 8 ] LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
3457 d56e bd d4 14           [ 8 ]           JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
3458 d571 c6 01              [ 2 ]           LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
3459 d573 96 45              [ 4 ]           LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
3460 d575 8b 0a              [ 2 ]           ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
3461 d577 2b 09              [ 3 ]           BMI  LBE36          ; BRANCH IF NUMBER < 1.0
3462 d579 81 0b              [ 2 ]           CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
3463                               *         USING SCIENTIFIC NOTATION
3464 d57b 24 05              [ 3 ]           BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
3465 d57d 4a                 [ 2 ]           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
3466 d57e 1f 89              [ 6 ]           TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
3467 d580 86 02              [ 2 ]           LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
3468 d582 4a                 [ 2 ] LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
3469 d583 4a                 [ 2 ]           DECA                ; * FROM BASE 10 EXPONENT
3470 d584 97 47              [ 4 ]           STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
3471                               *         IN   SCIENTIFIC NOTATION
3472 d586 d7 45              [ 4 ]           STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
3473                               *         LEFT OF DECIMAL POINT
3474 d588 2e 0d              [ 3 ]           BGT  LBE4B          ; BRANCH IF >= 1
3475 d58a de 64              [ 5 ]           LDU  COEFPT         ; POINT U TO THE STRING BUFFER
3476 d58c 86 2e              [ 2 ]           LDA  #'.            ; * STORE A PERIOD
3477 d58e a7 c0              [ 6 ]           STA  ,U+            ; * IN THE BUFFER
3478 d590 5d                 [ 2 ]           TSTB                ; CHECK DECIMAL POINT FLAG
3479 d591 27 04              [ 3 ]           BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
3480 d593 86 30              [ 2 ]           LDA  #'0            ; * STORE A ZERO
3481 d595 a7 c0              [ 6 ]           STA  ,U+            ; * IN THE BUFFER
3482                               
3483                               * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
3484 d597 8e d6 11           [ 3 ] LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
3485 d59a c6 80              [ 2 ]           LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
3486                               * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
3487                               * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
3488                               * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
3489                               * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
3490 d59c 96 53              [ 4 ] LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
3491 d59e ab 03              [ 5 ]           ADDA 3,X            ; * BYTE OF FPA0
3492 d5a0 97 53              [ 4 ]           STA  FPA0+3         ; * AND (X)
3493 d5a2 96 52              [ 4 ]           LDA  FPA0+2         ; = ADD MANTISSA
3494 d5a4 a9 02              [ 5 ]           ADCA 2,X            ; = NUMBER 3 BYTE OF
3495 d5a6 97 52              [ 4 ]           STA  FPA0+2         ; = FPA0 AND (X)
3496 d5a8 96 51              [ 4 ]           LDA  FPA0+1         ; * ADD MANTISSA
3497 d5aa a9 01              [ 5 ]           ADCA 1,X            ; * NUMBER 2 BYTE OF
3498 d5ac 97 51              [ 4 ]           STA  FPA0+1         ; * FPA0 AND (X)
3499 d5ae 96 50              [ 4 ]           LDA  FPA0           ; = ADD MANTISSA
3500 d5b0 a9 84              [ 4 ]           ADCA ,X             ; = MS BYTE OF
3501 d5b2 97 50              [ 4 ]           STA  FPA0           ; = FPA0 AND (X)
3502 d5b4 5c                 [ 2 ]           INCB                ; ADD ONE TO DIGIT COUNTER
3503 d5b5 56                 [ 2 ]           RORB                ; ROTATE CARRY INTO BIT 7
3504 d5b6 59                 [ 2 ]           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
3505 d5b7 28 e3              [ 3 ]           BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
3506 d5b9 24 03              [ 3 ]           BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
3507 d5bb c0 0b              [ 2 ]           SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
3508 d5bd 50                 [ 2 ]           NEGB                ; * ADDING MANTISSA
3509 d5be cb 2f              [ 2 ] LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
3510 d5c0 30 04              [ 5 ]           LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
3511 d5c2 1f 98              [ 6 ]           TFR  B,A            ; SAVE DIGIT IN ACCA
3512 d5c4 84 7f              [ 2 ]           ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
3513 d5c6 a7 c0              [ 6 ]           STA  ,U+            ; STORE DIGIT IN STRING BUFFER
3514 d5c8 0a 45              [ 6 ]           DEC  V45            ; DECREMENT DECIMAL POINT FLAG
3515 d5ca 26 04              [ 3 ]           BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
3516 d5cc 86 2e              [ 2 ]           LDA  #'.            ; * STORE DECIMAL POINT IN
3517 d5ce a7 c0              [ 6 ]           STA  ,U+            ; * STRING BUFFER
3518 d5d0 53                 [ 2 ] LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
3519 d5d1 c4 80              [ 2 ]           ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
3520 d5d3 8c d6 35           [ 4 ]           CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
3521 d5d6 26 c4              [ 3 ]           BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
3522                               * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
3523 d5d8 a6 c2              [ 6 ] LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
3524 d5da 81 30              [ 2 ]           CMPA #'0            ; WAS IT A ZERO?
3525 d5dc 27 fa              [ 3 ]           BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
3526 d5de 81 2e              [ 2 ]           CMPA #'.            ; CHECK FOR DECIMAL POINT
3527 d5e0 26 02              [ 3 ]           BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
3528 d5e2 33 5f              [ 5 ]           LEAU -1,U           ; STEP OVER THE DECIMAL POINT
3529 d5e4 86 2b              [ 2 ] LBE98     LDA  #'+            ; ASCII PLUS SIGN
3530 d5e6 d6 47              [ 4 ]           LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
3531 d5e8 27 1c              [ 3 ]           BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
3532 d5ea 2a 03              [ 3 ]           BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
3533 d5ec 86 2d              [ 2 ]           LDA  #'-            ; ASCII MINUS SIGN
3534 d5ee 50                 [ 2 ]           NEGB                ; NEGATE EXPONENT IF NEGATIVE
3535 d5ef a7 42              [ 5 ] LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
3536 d5f1 86 45              [ 2 ]           LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
3537 d5f3 a7 41              [ 5 ]           STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
3538 d5f5 86 2f              [ 2 ]           LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
3539                               
3540                               
3541 d5f7 4c                 [ 2 ] LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
3542 d5f8 c0 0a              [ 2 ]           SUBB #10            ; SUBTRACT 10 FROM ACCB
3543 d5fa 24 fb              [ 3 ]           BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
3544 d5fc cb 3a              [ 2 ]           ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
3545 d5fe ed 43              [ 6 ]           STD  3,U            ; SAVE EXPONENT IN STRING
3546 d600 6f 45              [ 7 ]           CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
3547 d602 20 04              [ 3 ]           BRA  LBEBC          ; GO RESET POINTER
3548 d604 a7 c4              [ 4 ] LBEB8     STA  ,U             ; STORE LAST CHARACTER
3549 d606 6f 41              [ 7 ] LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
3550                               *         PRINT SUBROUTINES)
3551 d608 8e 01 f1           [ 3 ] LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
3552 d60b 39                 [ 5 ]           RTS
3553                               *
3554 d60c 80 00 00 00 00           LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
3555                               *
3556                               *** TABLE OF UNNORMALIZED POWERS OF 10
3557 d611 fa 0a 1f 00              LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
3558 d615 00 98 96 80              LBEC9     FCB  $00,$98,$96,$80 ; 10000000
3559 d619 ff f0 bd c0              LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
3560 d61d 00 01 86 a0              LBED1     FCB  $00,$01,$86,$A0 ; 100000
3561 d621 ff ff d8 f0              LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
3562 d625 00 00 03 e8              LBED9     FCB  $00,$00,$03,$E8 ; 1000
3563 d629 ff ff ff 9c              LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
3564 d62d 00 00 00 0a              LBEE1     FCB  $00,$00,$00,$0A ; 10
3565 d631 ff ff ff ff              LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
3566                               *
3567                               *
3568 d635 96 4f              [ 4 ] LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
3569 d637 27 02              [ 3 ]           BEQ  LBEEF          ; BRANCH IF FPA0 = 0
3570 d639 03 54              [ 6 ]           COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
3571 d63b 39                 [ 5 ] LBEEF     RTS
3572                               * EXPAND A POLYNOMIAL OF THE FORM
3573                               * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
3574                               * AND THE X REGISTER POINTS TO A TABLE OF
3575                               * COEFFICIENTS A,B,C,D....
3576 d63c 9f 64              [ 5 ] LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3577 d63e bd d3 7b           [ 8 ]           JSR  LBC2F          ; MOVE FPA0 TO FPA3
3578 d641 8d 05              [ 7 ]           BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
3579 d643 8d 08              [ 7 ]           BSR  LBF01          ; EXPAND POLYNOMIAL
3580 d645 8e 00 40           [ 3 ]           LDX  #V40           ; POINT X TO FPA3
3581 d648 7e d2 16           [ 4 ] LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
3582                               
3583                               * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
3584                               * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
3585                               * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
3586                               * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
3587                               * OF PACKED FLOATING POINT NUMBERS. THE
3588                               * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
3589                               * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
3590 d64b 9f 64              [ 5 ] LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3591 d64d bd d3 76           [ 8 ] LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
3592 d650 9e 64              [ 5 ]           LDX  COEFPT         ; GET THE COEFFICIENT POINTER
3593 d652 e6 80              [ 6 ]           LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
3594 d654 d7 55              [ 4 ]           STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
3595 d656 9f 64              [ 5 ]           STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
3596 d658 8d ee              [ 7 ] LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3597 d65a 9e 64              [ 5 ]           LDX  COEFPT         ; *GET COEFFICIENT POINTER
3598 d65c 30 05              [ 5 ]           LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
3599 d65e 9f 64              [ 5 ]           STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
3600 d660 bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD (X) AND FPA0
3601 d663 8e 00 45           [ 3 ]           LDX  #V45           ; POINT (X) TO FPA4
3602 d666 0a 55              [ 6 ]           DEC  COEFCT         ; DECREMENT TEMP COUNTER
3603 d668 26 ee              [ 3 ]           BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
3604 d66a 39                 [ 5 ]           RTS
3605                               
3606                               * RND
3607 d66b bd d3 b9           [ 8 ] RND       JSR  LBC6D          ; TEST FPA0
3608 d66e 2b 1f              [ 3 ]           BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
3609 d670 27 15              [ 3 ]           BEQ  LBF3B          ; BRANCH IF FPA0 = 0
3610 d672 8d 10              [ 7 ]           BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3611 d674 bd d3 7b           [ 8 ]           JSR  LBC2F          ; PACK FPA0 TO FPA3
3612 d677 8d 0e              [ 7 ]           BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
3613 d679 8e 00 40           [ 3 ]           LDX  #V40           ; POINT (X) TO FPA3
3614 d67c 8d ca              [ 7 ]           BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3615 d67e 8e d2 11           [ 3 ]           LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
3616 d681 bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD 1.0 TO FPA0
3617 d684 7e d4 3a           [ 4 ] LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
3618                               * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
3619 d687 9e b1              [ 5 ] LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
3620 d689 9f 50              [ 5 ]           STX  FPA0           ; * RANDOM NUMBER
3621 d68b 9e b3              [ 5 ]           LDX  RVSEED+3       ; * SEED TO
3622 d68d 9f 52              [ 5 ]           STX  FPA0+2         ; * FPA0
3623 d68f be d6 bc           [ 6 ] LBF45     LDX  RSEED          ; = MOVE FIXED
3624 d692 9f 5d              [ 5 ]           STX  FPA1           ; = RANDOM NUMBER
3625 d694 be d6 be           [ 6 ]           LDX  RSEED+2        ; = SEED TO
3626 d697 9f 5f              [ 5 ]           STX  FPA1+2         ; = MANTISSA OF FPA0
3627 d699 bd d2 1c           [ 8 ]           JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
3628 d69c dc 8a              [ 5 ]           LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
3629 d69e c3 65 8b           [ 4 ]           ADDD #$658B         ; ADD A CONSTANT
3630 d6a1 dd b3              [ 5 ]           STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
3631 d6a3 dd 52              [ 5 ]           STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
3632 d6a5 dc 88              [ 5 ]           LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
3633 d6a7 c9 b0              [ 2 ]           ADCB #$B0           ; ADD A CONSTANT
3634 d6a9 89 05              [ 2 ]           ADCA #5             ; ADD A CONSTANT
3635 d6ab dd b1              [ 5 ]           STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
3636 d6ad dd 50              [ 5 ]           STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
3637 d6af 0f 54              [ 6 ]           CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
3638 d6b1 86 80              [ 2 ]           LDA  #$80           ; * SET FPA0 BIASED EXPONENT
3639 d6b3 97 4f              [ 4 ]           STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
3640 d6b5 96 15              [ 4 ]           LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
3641 d6b7 97 63              [ 4 ]           STA  FPSBYT         ; SAVE AS SUB BYTE
3642 d6b9 7e d1 68           [ 4 ]           JMP  LBA1C          ; NORMALIZE FPA0
3643                               *
3644 d6bc 40 e6                    RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
3645 d6be 4d ab                              FDB  $4DAB          ; *
3646                               
3647                               * SIN
3648                               * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
3649                               * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
3650                               * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
3651                               * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
3652                               
3653                               * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
3654                               * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
3655 d6c0 bd d3 ab           [ 8 ] SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
3656 d6c3 8e d7 05           [ 3 ]           LDX  #LBFBD         ; POINT (X) TO 2*PI
3657 d6c6 d6 61              [ 4 ]           LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
3658 d6c8 bd d2 d5           [ 8 ]           JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
3659 d6cb bd d3 ab           [ 8 ]           JSR  LBC5F          ; COPY FPA0 TO FPA1
3660 d6ce 8d b4              [ 7 ]           BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3661 d6d0 0f 62              [ 6 ]           CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
3662 d6d2 96 5c              [ 4 ]           LDA  FP1EXP         ; *GET EXPONENT OF FPA1
3663 d6d4 d6 4f              [ 4 ]           LDB  FP0EXP         ; *GET EXPONENT OF FPA0
3664 d6d6 bd d1 08           [ 8 ]           JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
3665                               * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
3666 d6d9 8e d7 0a           [ 3 ]           LDX  #LBFC2         ; POINT X TO FP (.25)
3667 d6dc bd d1 05           [ 8 ]           JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
3668 d6df 96 54              [ 4 ]           LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3669 d6e1 34 02              [ 6 ]           PSHS A              ; SAVE IT ON STACK
3670 d6e3 2a 09              [ 3 ]           BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
3671 d6e5 bd d1 00           [ 8 ]           JSR  LB9B4          ; ADD .5 (PI) TO FPA0
3672 d6e8 96 54              [ 4 ]           LDA  FP0SGN         ; GET SIGN OF FPA0
3673 d6ea 2b 05              [ 3 ]           BMI  LBFA9          ; BRANCH IF NEGATIVE
3674 d6ec 03 0a              [ 6 ]           COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
3675 d6ee bd d6 35           [ 8 ] LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
3676 d6f1 8e d7 0a           [ 3 ] LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
3677 d6f4 bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
3678 d6f7 35 02              [ 6 ]           PULS A              ; GET OLD MANTISSA SIGN
3679 d6f9 4d                 [ 2 ]           TSTA                ; * BRANCH IF OLD
3680 d6fa 2a 03              [ 3 ]           BPL  LBFB7          ; * SIGN WAS POSITIVE
3681 d6fc bd d6 35           [ 8 ]           JSR  LBEE9          ; TOGGLE MANTISSA SIGN
3682 d6ff 8e d7 0f           [ 3 ] LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
3683 d702 7e d6 3c           [ 4 ]           JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
3684                               
3685 d705 83 49 0f da a2           LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
3686 d70a 7f 00 00 00 00           LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
3687                               
3688                               
3689 d70f 05                       LBFC7     FCB  6-1            ; SIX COEFFICIENTS
3690 d710 84 e6 1a 2d 1b           LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
3691 d715 86 28 07 fb f8           LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
3692 d71a 87 99 68 89 01           LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
3693 d71f 87 23 35 df e1           LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
3694 d724 86 a5 5d e7 28           LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
3695 d729 83 49 0f da a2           LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
3696                               
3697 d72e a1 54 46 8f 13                     FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
3698 d733 8f 52 43 89 cd                     FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
3699                               * EXTENDED BASIC
3700                               
3701                               * COS
3702                               * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
3703 d738 8e d7 6b           [ 3 ] COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
3704 d73b bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD FPA0 TO (X)
3705 d73e 7e d6 c0           [ 4 ] L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
3706                               
3707                               * TAN
3708                               * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
3709 d741 bd d3 7b           [ 8 ] TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
3710 d744 0f 0a              [ 6 ]           CLR  RELFLG         ; RESET QUADRANT FLAG
3711 d746 8d f6              [ 7 ]           BSR  L837E          ; CALCULATE SIN OF ARGUMENT
3712 d748 8e 00 4a           [ 3 ]           LDX  #V4A           ; POINT X TO FPA5
3713 d74b bd d3 81           [ 8 ]           JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
3714 d74e 8e 00 40           [ 3 ]           LDX  #V40           ; POINT X TO FPA3
3715 d751 bd d3 60           [ 8 ]           JSR  LBC14          ; MOVE FPA3 TO FPA0
3716 d754 0f 54              [ 6 ]           CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
3717 d756 96 0a              [ 4 ]           LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
3718 d758 8d 0c              [ 7 ]           BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
3719 d75a 0d 4f              [ 6 ]           TST  FP0EXP         ; CHECK EXPONENT OF FPA0
3720 d75c 10 27 fa 7e        [ 6 ]           LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
3721 d760 8e 00 4a           [ 3 ]           LDX  #V4A           ; POINT X TO FPA5
3722 d763 7e d2 db           [ 4 ] L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
3723 d766 34 02              [ 6 ] L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
3724 d768 7e d6 ee           [ 4 ]           JMP  LBFA6          ; EXPAND POLYNOMIAL
3725                               
3726 d76b 81 49 0f da a2           L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
3727                               
3728                               * ATN
3729                               * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
3730                               * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
3731                               * TO EVALUATE THE EXPRESSION DEPENDING UPON
3732                               * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
3733                               
3734                               * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
3735                               * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
3736                               
3737 d770 96 54              [ 4 ] ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
3738 d772 34 02              [ 6 ]           PSHS A              ; * SAVE IT ON THE STACK
3739 d774 2a 02              [ 3 ]           BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
3740 d776 8d 24              [ 7 ]           BSR  L83DC          ; CHANGE SIGN OF FPA0
3741 d778 96 4f              [ 4 ] L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
3742 d77a 34 02              [ 6 ]           PSHS A              ; * SAVE IT ON THE STACK
3743 d77c 81 81              [ 2 ]           CMPA #$81           ; IS FPAO < 1.0?
3744 d77e 25 05              [ 3 ]           BLO  L83C5          ; YES
3745 d780 8e d2 11           [ 3 ]           LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
3746 d783 8d de              [ 7 ]           BSR  L83A3          ; GET RECIPROCAL OF FPA0
3747 d785 8e d7 a0           [ 3 ] L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
3748 d788 bd d6 3c           [ 8 ]           JSR  LBEF0          ; EXPAND POLYNOMIAL
3749 d78b 35 02              [ 6 ]           PULS A              ; GET EXPONENT OF ARGUMENT
3750 d78d 81 81              [ 2 ]           CMPA #$81           ; WAS ARGUMENT < 1.0?
3751 d78f 25 06              [ 3 ]           BLO  L83D7          ; YES
3752 d791 8e d7 6b           [ 3 ]           LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
3753 d794 bd d1 05           [ 8 ]           JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
3754 d797 35 02              [ 6 ] L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
3755 d799 4d                 [ 2 ]           TSTA                ; * AND SET FLAGS ACCORDING TO IT
3756 d79a 2a 03              [ 3 ]           BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
3757 d79c 7e d6 35           [ 4 ] L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
3758 d79f 39                 [ 5 ] L83DF     RTS
3759                               *
3760                               * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
3761 d7a0 0b                       L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
3762 d7a1 76 b3 83 bd d3           L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
3763 d7a6 79 1e f4 a6 f5           L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
3764 d7ab 7b 83 fc b0 10           L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
3765 d7b0 7c 0c 1f 67 ca           L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
3766 d7b5 7c de 53 cb c1           L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
3767 d7ba 7d 14 64 70 4c           L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
3768 d7bf 7d b7 ea 51 7a           L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
3769 d7c4 7d 63 30 88 7e           L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
3770 d7c9 7e 92 44 99 3a           L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
3771 d7ce 7e 4c cc 91 c7           L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
3772 d7d3 7f aa aa aa 13           L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
3773 d7d8 81 00 00 00 00           L8418     FCB  $81,$00,$00,$00,$00 ; 1
3774                               *
3775                               *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
3776                               *
3777 d7dd 03                       L841D     FCB  3              ; FOUR COEFFICIENTS
3778 d7de 7f 5e 56 cb 79           L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
3779 d7e3 80 13 9b 0b 64           L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
3780 d7e8 80 76 38 93 16           L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
3781 d7ed 82 38 aa 3b 20           L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
3782                               
3783 d7f2 80 35 04 f3 34           L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
3784                               
3785 d7f7 81 35 04 f3 34           L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
3786                               
3787 d7fc 80 80 00 00 00           L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
3788                               
3789 d801 80 31 72 17 f8           L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
3790                               *
3791                               * LOG - NATURAL LOGARITHM (LN)
3792                               
3793                               * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
3794                               * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
3795                               * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
3796                               * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
3797                               * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
3798                               * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
3799                               * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
3800 d806 bd d3 b9           [ 8 ] LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
3801 d809 10 2f f3 c4        [ 6 ]           LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
3802 d80d 8e d7 f2           [ 3 ]           LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
3803 d810 96 4f              [ 4 ]           LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
3804 d812 80 80              [ 2 ]           SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
3805 d814 34 02              [ 6 ]           PSHS A              ; *SAVE IT ON THE STACK
3806 d816 86 80              [ 2 ]           LDA  #$80
3807 d818 97 4f              [ 4 ]           STA  FP0EXP
3808 d81a bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD FPA0 TO (X)
3809 d81d 8e d7 f7           [ 3 ]           LDX  #L8437         ; POINT X TO SQR(2)
3810 d820 bd d2 db           [ 8 ]           JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
3811 d823 8e d2 11           [ 3 ]           LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
3812 d826 bd d1 05           [ 8 ]           JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
3813                               *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
3814 d829 8e d7 dd           [ 3 ]           LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
3815 d82c bd d6 3c           [ 8 ]           JSR  LBEF0          ; EXPAND POLYNOMIAL
3816 d82f 8e d7 fc           [ 3 ]           LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
3817 d832 bd d1 0e           [ 8 ]           JSR  LB9C2          ; ADD FPA0 TO X
3818 d835 35 04              [ 6 ]           PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
3819 d837 bd d4 e5           [ 8 ]           JSR  LBD99          ; ADD ACCB TO FPA0
3820 d83a 8e d8 01           [ 3 ]           LDX  #L8441         ; POINT X TO LN(2)
3821 d83d 7e d2 16           [ 4 ]           JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
3822                               
3823                               * SQR
3824 d840 bd d3 ab           [ 8 ] SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
3825 d843 8e d6 0c           [ 3 ]           LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
3826 d846 bd d3 60           [ 8 ]           JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
3827                               
3828                               * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
3829                               * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
3830                               * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
3831 d849 27 67              [ 3 ] L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
3832 d84b 4d                 [ 2 ]           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
3833 d84c 26 03              [ 3 ]           BNE  L8491          ; *AND BRANCH IF IT IS <> 0
3834 d84e 7e d1 86           [ 4 ]           JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
3835 d851 8e 00 4a           [ 3 ] L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
3836 d854 bd d3 81           [ 8 ]           JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
3837 d857 5f                 [ 2 ]           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
3838 d858 96 61              [ 4 ]           LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
3839 d85a 2a 10              [ 3 ]           BPL  L84AC          ; *BRANCH IF POSITIVE
3840 d85c bd d4 3a           [ 8 ]           JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
3841 d85f 8e 00 4a           [ 3 ]           LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
3842 d862 96 61              [ 4 ]           LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
3843 d864 bd d3 ec           [ 8 ]           JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
3844 d867 26 03              [ 3 ]           BNE  L84AC          ; *BRANCH IF NOT EQUAL
3845 d869 43                 [ 2 ]           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
3846 d86a d6 01              [ 4 ]           LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
3847 d86c bd d3 98           [ 8 ] L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
3848 d86f 34 04              [ 6 ]           PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
3849 d871 bd d8 06           [ 8 ]           JSR  LOG
3850 d874 8e 00 4a           [ 3 ]           LDX  #V4A           ; POINT (X) TO FPA5
3851 d877 bd d2 16           [ 8 ]           JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
3852 d87a 8d 36              [ 7 ]           BSR  EXP            ; CALCULATE E**(FPA0)
3853 d87c 35 02              [ 6 ]           PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
3854 d87e 46                 [ 2 ]           RORA                ; * AND BRANCH IF NEGATIVE
3855 d87f 10 25 fd b2        [ 6 ]           LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3856 d883 39                 [ 5 ]           RTS
3857                               
3858                               * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
3859 d884 81 38 aa 3b 29           L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
3860                               *
3861                               * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
3862                               *
3863 d889 07                       L84C9     FCB  7              ; EIGHT COEFFICIENTS
3864 d88a 71 34 58 3e 56           L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
3865 d88f 74 16 7e b3 1b           L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
3866 d894 77 2f ee e3 85           L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
3867 d899 7a 1d 84 1c 2a           L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
3868 d89e 7c 63 59 58 0a           L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
3869 d8a3 7e 75 fd e7 c6           L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
3870 d8a8 80 31 72 18 10           L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
3871 d8ad 81 00 00 00 00           L84ED     FCB  $81,$00,$00,$00,$00 ; 1
3872                               *
3873                               * EXP ( E**X)
3874                               * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
3875                               * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
3876                               * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
3877                               * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
3878                               * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
3879                               * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
3880                               
3881 d8b2 8e d8 84           [ 3 ] EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
3882 d8b5 bd d2 16           [ 8 ]           JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3883 d8b8 bd d3 7b           [ 8 ]           JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
3884 d8bb 96 4f              [ 4 ]           LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
3885 d8bd 81 88              [ 2 ]           CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
3886 d8bf 25 03              [ 3 ]           BLO  L8504          ; BRANCH IF FPA0 < 128
3887 d8c1 7e d2 a8           [ 4 ] L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
3888 d8c4 bd d4 3a           [ 8 ] L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
3889 d8c7 96 01              [ 4 ]           LDA  CHARAC         ; GET LS BYTE OF INTEGER
3890 d8c9 8b 81              [ 2 ]           ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
3891 d8cb 27 f4              [ 3 ]           BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
3892                               *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
3893 d8cd 4a                 [ 2 ]           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
3894 d8ce 34 02              [ 6 ]           PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
3895 d8d0 8e 00 40           [ 3 ]           LDX  #V40           ; POINT (X) TO FPA3
3896 d8d3 bd d1 05           [ 8 ]           JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
3897 d8d6 8e d8 89           [ 3 ]           LDX  #L84C9         ; POINT X TO COEFFICIENTS
3898 d8d9 bd d6 4b           [ 8 ]           JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
3899 d8dc 0f 62              [ 6 ]           CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
3900 d8de 35 02              [ 6 ]           PULS A              ; GET INTEGER EXPONENT FROM STACK
3901 d8e0 bd d2 94           [ 8 ]           JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
3902                               *              ; * INTEGER AND FRACTIONAL PARTS
3903 d8e3 39                 [ 5 ]           RTS
3904                               
3905                               * FIX
3906 d8e4 bd d3 b9           [ 8 ] FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
3907 d8e7 2b 03              [ 3 ]           BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
3908 d8e9 7e d4 3a           [ 4 ] L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
3909 d8ec 03 54              [ 6 ] L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
3910 d8ee 8d f9              [ 7 ]           BSR  L8529          ; CONVERT FPA0 TO INTEGER
3911 d8f0 7e d6 35           [ 4 ]           JMP  LBEE9          ; TOGGLE SIGN OF FPA0
3912                               
3913                               * EDIT
3914 d8f3 bd dd 21           [ 8 ] EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
3915 d8f6 32 62              [ 5 ]           LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3916 d8f8 86 01              [ 2 ] L8538     LDA  #$01           ; 'LIST' FLAG
3917 d8fa 97 98              [ 4 ]           STA  VD8            ; SET FLAG TO LIST LINE
3918 d8fc bd c4 a5           [ 8 ]           JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
3919 d8ff 10 25 ed 7f        [ 6 ]           LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
3920 d903 bd cf 3e           [ 8 ]           JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
3921 d906 1f 20              [ 6 ]           TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
3922 d908 83 00 f5           [ 4 ]           SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
3923 d90b d7 97              [ 4 ]           STB  VD7            ; SAVE LENGTH OF LINE
3924 d90d dc 2b              [ 5 ] L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
3925 d90f bd d5 18           [ 8 ]           JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
3926 d912 bd d0 f8           [ 8 ]           JSR  LB9AC          ; PRINT A SPACE
3927 d915 8e 00 f4           [ 3 ]           LDX  #LINBUF+1      ; POINT X TO BUFFER
3928 d918 d6 98              [ 4 ]           LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
3929 d91a 26 25              [ 3 ]           BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
3930 d91c 5f                 [ 2 ] L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
3931 d91d bd da 47           [ 8 ] L855D     JSR  L8687          ; GET KEY STROKE
3932 d920 bd e1 ec           [ 8 ]           JSR  L90AA          ; SET CARRY IF NOT NUMERIC
3933 d923 25 0b              [ 3 ]           BLO  L8570          ; BRANCH IF NOT NUMERIC
3934 d925 80 30              [ 2 ]           SUBA #'0            ; MASK OFF ASCII
3935 d927 34 02              [ 6 ]           PSHS A              ; SAVE IT ON STACK
3936 d929 86 0a              [ 2 ]           LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
3937 d92b 3d                 [11 ]           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
3938 d92c eb e0              [ 6 ]           ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
3939 d92e 20 ed              [ 3 ]           BRA  L855D          ; CHECK FOR ANOTHER DIGIT
3940 d930 c0 01              [ 2 ] L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
3941 d932 c9 01              [ 2 ]           ADCB #$01           ; *IS 0, THEN MAKE IT '1'
3942 d934 81 41              [ 2 ]           CMPA #'A            ; ABORT?
3943 d936 26 05              [ 3 ]           BNE  L857D          ; NO
3944 d938 bd d0 a8           [ 8 ]           JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3945 d93b 20 bb              [ 3 ]           BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
3946 d93d 81 4c              [ 2 ] L857D     CMPA #'L            ; LIST?
3947 d93f 26 0b              [ 3 ]           BNE  L858C          ; NO
3948 d941 8d 31              [ 7 ] L8581     BSR  L85B4          ; LIST THE LINE
3949 d943 0f 98              [ 6 ]           CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
3950 d945 bd d0 a8           [ 8 ]           JSR  LB958          ; PRINT CARRIAGE RETURN
3951 d948 20 c3              [ 3 ]           BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
3952 d94a 32 62              [ 5 ] L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3953 d94c 81 0d              [ 2 ] L858C     CMPA #CR            ; ENTER KEY?
3954 d94e 26 0d              [ 3 ]           BNE  L859D          ; NO
3955 d950 8d 22              [ 7 ]           BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
3956 d952 bd d0 a8           [ 8 ] L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
3957 d955 8e 00 f4           [ 3 ]           LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
3958 d958 9f 83              [ 5 ]           STX  CHARAD         ; * TO THE LINE INPUT BUFFER
3959 d95a 7e c4 4e           [ 4 ]           JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
3960 d95d 81 45              [ 2 ] L859D     CMPA #'E            ; EXIT?
3961 d95f 27 f1              [ 3 ]           BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
3962 d961 81 51              [ 2 ]           CMPA #'Q            ; QUIT?
3963 d963 26 06              [ 3 ]           BNE  L85AB          ; NO
3964 d965 bd d0 a8           [ 8 ]           JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3965 d968 7e c4 25           [ 4 ]           JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
3966 d96b 8d 02              [ 7 ] L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
3967 d96d 20 ad              [ 3 ]           BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
3968 d96f 81 20              [ 2 ] L85AF     CMPA #SPACE         ; SPACE BAR?
3969 d971 26 10              [ 3 ]           BNE  L85C3          ; NO
3970 d973 8c                       L85B3     FCB  SKP2           ; SKIP TWO BYTES
3971                               * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
3972                               *
3973 d974 c6 f9              [ 2 ] L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
3974 d976 a6 84              [ 4 ] L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
3975 d978 27 08              [ 3 ]           BEQ  L85C2          ; EXIT IF IT'S A 0
3976 d97a bd c0 17           [ 8 ]           JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
3977 d97d 30 01              [ 5 ]           LEAX $01,X          ; MOVE POINTER UP ONE
3978 d97f 5a                 [ 2 ]           DECB                ; DECREMENT CHARACTER COUNTER
3979 d980 26 f4              [ 3 ]           BNE  L85B6          ; LOOP IF NOT DONE
3980 d982 39                 [ 5 ] L85C2     RTS
3981 d983 81 44              [ 2 ] L85C3     CMPA #'D            ; DELETE?
3982 d985 26 48              [ 3 ]           BNE  L860F          ; NO
3983 d987 6d 84              [ 6 ] L85C7     TST  ,X             ; * CHECK FOR END OF LINE
3984 d989 27 f7              [ 3 ]           BEQ  L85C2          ; * AND BRANCH IF SO
3985 d98b 8d 04              [ 7 ]           BSR  L85D1          ; REMOVE A CHARACTER
3986 d98d 5a                 [ 2 ]           DECB                ; DECREMENT REPEAT PARAMETER
3987 d98e 26 f7              [ 3 ]           BNE  L85C7          ; BRANCH IF NOT DONE
3988 d990 39                 [ 5 ]           RTS
3989                               * REMOVE ONE CHARACTER FROM BUFFER
3990 d991 0a 97              [ 6 ] L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
3991 d993 31 1f              [ 5 ]           LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
3992 d995 31 21              [ 5 ] L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
3993 d997 a6 21              [ 5 ]           LDA  $01,Y          ; GET NEXT CHARACTER
3994 d999 a7 a4              [ 4 ]           STA  ,Y             ; PUT IT IN CURRENT POSITION
3995 d99b 26 f8              [ 3 ]           BNE  L85D5          ; BRANCH IF NOT END OF LINE
3996 d99d 39                 [ 5 ]           RTS
3997 d99e 81 49              [ 2 ] L85DE     CMPA #'I            ;  INSERT?
3998 d9a0 27 13              [ 3 ]           BEQ  L85F5          ; YES
3999 d9a2 81 58              [ 2 ]           CMPA #'X            ; EXTEND?
4000 d9a4 27 0d              [ 3 ]           BEQ  L85F3          ; YES
4001 d9a6 81 48              [ 2 ]           CMPA #'H            ; HACK?
4002 d9a8 26 5c              [ 3 ]           BNE  L8646          ; NO
4003 d9aa 6f 84              [ 6 ]           CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
4004 d9ac 1f 10              [ 6 ]           TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
4005 d9ae 83 00 f5           [ 4 ]           SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
4006 d9b1 d7 97              [ 4 ]           STB  VD7            ; SAVE NEW BUFFER LENGTH
4007 d9b3 8d bf              [ 7 ] L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
4008 d9b5 bd da 47           [ 8 ] L85F5     JSR  L8687          ; GET A KEYSTROKE
4009 d9b8 81 0d              [ 2 ]           CMPA #CR            ; ENTER KEY?
4010 d9ba 27 8e              [ 3 ]           BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
4011 d9bc 81 1b              [ 2 ]           CMPA #ESC           ; ESCAPE?
4012 d9be 27 25              [ 3 ]           BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
4013 d9c0 81 08              [ 2 ]           CMPA #BS            ; BACK SPACE?
4014 d9c2 26 22              [ 3 ]           BNE  L8626          ; NO
4015 d9c4 8c 00 f4           [ 4 ]           CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4016 d9c7 27 ec              [ 3 ]           BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
4017 d9c9 8d 45              [ 7 ]           BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
4018 d9cb 8d c4              [ 7 ]           BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4019 d9cd 20 e6              [ 3 ]           BRA  L85F5          ; GET INSERT SUB COMMAND
4020 d9cf 81 43              [ 2 ] L860F     CMPA #'C            ; CHANGE?
4021 d9d1 26 cb              [ 3 ]           BNE  L85DE          ; NO
4022 d9d3 6d 84              [ 6 ] L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
4023 d9d5 27 0e              [ 3 ]           BEQ  L8625          ; BRANCH IF END OF LINE
4024 d9d7 bd da 47           [ 8 ]           JSR  L8687          ; GET A KEYSTROKE
4025 d9da 25 02              [ 3 ]           BLO  L861E          ; BRANCH IF LEGITIMATE KEY
4026 d9dc 20 f5              [ 3 ]           BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
4027 d9de a7 80              [ 6 ] L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
4028 d9e0 8d 37              [ 7 ]           BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
4029 d9e2 5a                 [ 2 ]           DECB                ; DECREMENT REPEAT PARAMETER
4030 d9e3 26 ee              [ 3 ]           BNE  L8613          ; BRANCH IF NOT DONE
4031 d9e5 39                 [ 5 ] L8625     RTS
4032 d9e6 d6 97              [ 4 ] L8626     LDB  VD7            ; GET LENGTH OF LINE
4033 d9e8 c1 f9              [ 2 ]           CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
4034 d9ea 26 02              [ 3 ]           BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
4035 d9ec 20 c7              [ 3 ]           BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
4036 d9ee 34 10              [ 7 ] L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
4037 d9f0 6d 80              [ 8 ] L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
4038 d9f2 26 fc              [ 3 ]           BNE  L8630          ; * LINE (0) IS FOUND
4039 d9f4 e6 82              [ 6 ] L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
4040 d9f6 e7 01              [ 5 ]           STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
4041 d9f8 ac e4              [ 6 ]           CMPX ,S             ; HAVE WE REACHED STARTING POINT?
4042 d9fa 26 f8              [ 3 ]           BNE  L8634          ; NO - KEEP GOING
4043 d9fc 32 62              [ 5 ]           LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
4044 d9fe a7 80              [ 6 ]           STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
4045 da00 8d 17              [ 7 ]           BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4046 da02 0c 97              [ 6 ]           INC  VD7            ; ADD ONE TO BUFFER LENGTH
4047 da04 20 af              [ 3 ]           BRA  L85F5          ; GET INSERT SUB COMMAND
4048 da06 81 08              [ 2 ] L8646     CMPA #BS            ; BACKSPACE?
4049 da08 26 12              [ 3 ]           BNE  L865C          ; NO
4050 da0a 8d 04              [ 7 ] L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
4051 da0c 5a                 [ 2 ]           DECB                ; DECREMENT REPEAT PARAMETER
4052 da0d 26 fb              [ 3 ]           BNE  L864A          ; LOOP UNTIL DONE
4053 da0f 39                 [ 5 ]           RTS
4054 da10 8c 00 f4           [ 4 ] L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4055 da13 27 d0              [ 3 ]           BEQ  L8625          ; DO NOT ALLOW BS IF AT START
4056 da15 30 1f              [ 5 ]           LEAX -1,X           ; MOVE POINTER BACK ONE
4057 da17 86 08              [ 2 ]           LDA  #BS            ; BACK SPACE
4058 da19 7e c0 17           [ 4 ] L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
4059 da1c 81 4b              [ 2 ] L865C     CMPA #'K            ; KILL?
4060 da1e 27 05              [ 3 ]           BEQ  L8665          ; YES
4061 da20 80 53              [ 2 ]           SUBA #'S            ; SEARCH?
4062 da22 27 01              [ 3 ]           BEQ  L8665          ; YES
4063 da24 39                 [ 5 ]           RTS
4064 da25 34 02              [ 6 ] L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
4065 da27 8d 1e              [ 7 ]           BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
4066 da29 34 02              [ 6 ]           PSHS A              ; * AND SAVE IT ON STACK
4067 da2b a6 84              [ 4 ] L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
4068 da2d 27 16              [ 3 ]           BEQ  L8685          ; AND RETURN IF END OF LINE
4069 da2f 6d 61              [ 7 ]           TST  $01,S          ; CHECK KILL/SEARCH FLAG
4070 da31 26 06              [ 3 ]           BNE  L8679          ; BRANCH IF KILL
4071 da33 8d e4              [ 7 ]           BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4072 da35 30 01              [ 5 ]           LEAX $01,X          ; INCREMENT BUFFER POINTER
4073 da37 20 03              [ 3 ]           BRA  L867C          ; CHECK NEXT INPUT CHARACTER
4074 da39 bd d9 91           [ 8 ] L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4075 da3c a6 84              [ 4 ] L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
4076 da3e a1 e4              [ 4 ]           CMPA ,S             ; COMPARE TO TARGET CHARACTER
4077 da40 26 e9              [ 3 ]           BNE  L866B          ; BRANCH IF NO MATCH
4078 da42 5a                 [ 2 ]           DECB                ; DECREMENT REPEAT PARAMETER
4079 da43 26 e6              [ 3 ]           BNE  L866B          ; BRANCH IF NOT DONE
4080 da45 35 a0              [ 9 ] L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
4081                               *
4082                               * GET A KEYSTRKE
4083 da47 bd c0 03           [ 8 ] L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
4084 da4a 81 7f              [ 2 ]           CMPA #$7F           ; GRAPHIC CHARACTER?
4085 da4c 24 f9              [ 3 ]           BCC  L8687          ; YES - GET ANOTHER CHAR
4086 da4e 81 5f              [ 2 ]           CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
4087 da50 26 02              [ 3 ]           BNE  L8694          ; NO
4088 da52 86 1b              [ 2 ]           LDA  #ESC           ; REPLACE W/ESCAPE CODE
4089 da54 81 0d              [ 2 ] L8694     CMPA #CR            ; ENTER KEY
4090 da56 27 0e              [ 3 ]           BEQ  L86A6          ; YES
4091 da58 81 1b              [ 2 ]           CMPA #ESC           ; ESCAPE?
4092 da5a 27 0a              [ 3 ]           BEQ  L86A6          ; YES
4093 da5c 81 08              [ 2 ]           CMPA #BS            ; BACKSPACE?
4094 da5e 27 06              [ 3 ]           BEQ  L86A6          ; YES
4095 da60 81 20              [ 2 ]           CMPA #SPACE         ; SPACE
4096 da62 25 e3              [ 3 ]           BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
4097 da64 1a 01              [ 3 ]           ORCC #$01           ; SET CARRY
4098 da66 39                 [ 5 ] L86A6     RTS
4099                               
4100                               * TRON
4101 da67 86                       TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
4102                               
4103                               * TROFF
4104 da68 4f                 [ 2 ] TROFF     CLRA                ; TROFF FLAG
4105 da69 97 8c              [ 4 ]           STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
4106 da6b 39                 [ 5 ]           RTS
4107                               
4108                               * POS
4109                               
4110 da6c 86 00              [ 2 ] POS       LDA  #0             ; GET DEVICE NUMBER
4111 da6e d6 79              [ 4 ]           LDB  LPTPOS         ; GET PRINT POSITION
4112 da70 1d                 [ 2 ] LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
4113 da71 7e cc 7b           [ 4 ]           JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
4114                               
4115                               
4116                               * VARPTR
4117 da74 bd c9 f6           [ 8 ] VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
4118 da77 dc 1f              [ 5 ]           LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
4119 da79 34 06              [ 7 ]           PSHS B,A            ; SAVE IT ON STACK
4120 da7b bd ca de           [ 8 ]           JSR  LB357          ; GET VARIABLE DESCRIPTOR
4121 da7e bd c9 f3           [ 8 ]           JSR  LB267          ; SYNTAX CHECK FOR ')'
4122 da81 35 06              [ 7 ]           PULS A,B            ; GET END OF ARRAYS ADDR BACK
4123 da83 1e 10              [ 8 ]           EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
4124 da85 9c 1f              [ 6 ]           CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
4125 da87 26 51              [ 3 ]           BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
4126 da89 7e cc 7b           [ 4 ]           JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
4127                               
4128                               * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
4129 da8c 9d 7c              [ 7 ] L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
4130 da8e bd c9 f6           [ 8 ]           JSR  LB26A          ; SYNTAX CHECK FOR '('
4131 da91 bd ca de           [ 8 ]           JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
4132 da94 34 10              [ 7 ]           PSHS X              ; * SAVE IT ON THE STACK
4133 da96 ec 02              [ 6 ]           LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
4134 da98 10 93 21           [ 7 ]           CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
4135 da9b 23 04              [ 3 ]           BLS  L86EB          ; BRANCH IF <=
4136 da9d 93 27              [ 6 ]           SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
4137 da9f 23 12              [ 3 ]           BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
4138 daa1 e6 84              [ 4 ] L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
4139 daa3 bd cc f4           [ 8 ]           JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4140 daa6 34 10              [ 7 ]           PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
4141 daa8 ae 62              [ 6 ]           LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
4142 daaa bd cd ca           [ 8 ]           JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
4143 daad 35 50              [ 9 ]           PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
4144 daaf af 42              [ 6 ]           STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
4145 dab1 34 40              [ 7 ]           PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
4146 dab3 bd ce bf           [ 8 ] L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4147 dab6 34 04              [ 6 ]           PSHS B              ; SAVE POSITION PARAMETER ON STACK
4148 dab8 5d                 [ 2 ]           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
4149 dab9 27 1f              [ 3 ]           BEQ  L8724          ; * IF START OF STRING
4150 dabb c6 ff              [ 2 ]           LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
4151 dabd 81 29              [ 2 ]           CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
4152 dabf 27 03              [ 3 ]           BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
4153 dac1 bd ce bf           [ 8 ]           JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4154 dac4 34 04              [ 6 ] L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
4155 dac6 bd c9 f3           [ 8 ]           JSR  LB267          ; SYNTAX CHECK FOR ')'
4156 dac9 c6 ae              [ 2 ]           LDB  #TOK_EQUALS    ; TOKEN FOR =
4157 dacb bd c9 fb           [ 8 ]           JSR  LB26F          ; SYNTAX CHECK FOR '='
4158 dace 8d 2e              [ 7 ]           BSR  L8748          ; EVALUATE REPLACEMENT STRING
4159 dad0 1f 13              [ 6 ]           TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
4160 dad2 ae 62              [ 6 ]           LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
4161 dad4 a6 84              [ 4 ]           LDA  ,X             ; GET LENGTH OF OLDSTRING
4162 dad6 a0 61              [ 5 ]           SUBA $01,S          ; SUBTRACT POSITION PARAMETER
4163 dad8 24 03              [ 3 ]           BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
4164 dada 7e cb d1           [ 4 ] L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
4165 dadd 4c                 [ 2 ] L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
4166                               *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
4167 dade a1 e4              [ 4 ]           CMPA ,S
4168 dae0 24 02              [ 3 ]           BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
4169 dae2 a7 e4              [ 4 ]           STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
4170 dae4 a6 61              [ 5 ] L872E     LDA  $01,S          ; GET POSITION PARAMETER
4171 dae6 1e 89              [ 8 ]           EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
4172 dae8 ae 02              [ 6 ]           LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
4173 daea 5a                 [ 2 ]           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
4174                               *                             ; * WANTS IT TO START AT ZERO
4175 daeb 3a                 [ 3 ]           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
4176 daec 4d                 [ 2 ]           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
4177 daed 27 0d              [ 3 ]           BEQ  L8746          ; * THEN RETURN
4178 daef a1 e4              [ 4 ]           CMPA ,S
4179 daf1 23 02              [ 3 ]           BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
4180 daf3 a6 e4              [ 4 ]           LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
4181 daf5 1f 89              [ 6 ] L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
4182 daf7 1e 31              [ 8 ]           EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
4183 daf9 bd c1 b1           [ 8 ]           JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
4184 dafc 35 96              [11 ] L8746     PULS A,B,X,PC
4185 dafe bd c8 e2           [ 8 ] L8748     JSR  LB156          ; EVALUATE EXPRESSION
4186 db01 7e cd db           [ 4 ]           JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
4187                               *                             ; *TO STRING, ACCB = LENGTH
4188                               
4189                               * STRING
4190 db04 bd c9 f6           [ 8 ] STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
4191 db07 bd ce 92           [ 8 ]           JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
4192 db0a 34 04              [ 6 ]           PSHS B              ; SAVE LENGTH OF STRING
4193 db0c bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4194 db0f bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSION
4195 db12 bd c9 f3           [ 8 ]           JSR  LB267          ; SYNTAX CHECK FOR ')'
4196 db15 96 06              [ 4 ]           LDA  VALTYP         ; GET VARIABLE TYPE
4197 db17 26 05              [ 3 ]           BNE  L8768          ; BRANCH IF STRING
4198 db19 bd ce 95           [ 8 ]           JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
4199 db1c 20 03              [ 3 ]           BRA  L876B          ; SAVE THE STRING IN STRING SPACE
4200 db1e bd ce 2b           [ 8 ] L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
4201 db21 34 04              [ 6 ] L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
4202 db23 e6 61              [ 5 ]           LDB  $01,S          ; GET LENGTH OF STRING
4203 db25 bd cc 96           [ 8 ]           JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
4204 db28 35 06              [ 7 ]           PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
4205 db2a 27 05              [ 3 ]           BEQ  L877B          ; BRANCH IF NULL STRING
4206 db2c a7 80              [ 6 ] L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
4207 db2e 5a                 [ 2 ]           DECB                ; DECREMENT LENGTH
4208 db2f 26 fb              [ 3 ]           BNE  L8776          ; BRANCH IF NOT DONE
4209 db31 7e ce 22           [ 4 ] L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
4210                               
4211                               * INSTR
4212 db34 bd c9 f6           [ 8 ] INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
4213 db37 bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSION
4214 db3a c6 01              [ 2 ]           LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
4215 db3c 34 04              [ 6 ]           PSHS B              ; SAVE START
4216 db3e 96 06              [ 4 ]           LDA  VALTYP         ; GET VARIABLE TYPE
4217 db40 26 10              [ 3 ]           BNE  L879C          ; BRANCH IF STRING
4218 db42 bd ce 95           [ 8 ]           JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
4219 db45 e7 e4              [ 4 ]           STB  ,S             ; SAVE START SEARCH VALUE
4220 db47 27 91              [ 3 ]           BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
4221 db49 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4222 db4c bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
4223 db4f bd c8 d2           [ 8 ]           JSR  LB146          ; 'TM' ERROR IF NUMERIC
4224 db52 9e 52              [ 5 ] L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
4225 db54 34 10              [ 7 ]           PSHS X              ; SAVE ON THE STACK
4226 db56 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4227 db59 bd da fe           [ 8 ]           JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
4228 db5c 34 14              [ 8 ]           PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
4229 db5e bd c9 f3           [ 8 ]           JSR  LB267          ; SYNTAX CHECK FOR ')'
4230 db61 ae 63              [ 6 ]           LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
4231 db63 bd cd e0           [ 8 ]           JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
4232 db66 34 04              [ 6 ]           PSHS B              ; SAVE LENGTH ON STACK
4233                               *
4234                               * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
4235                               * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
4236                               * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
4237 db68 e1 66              [ 5 ]           CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
4238 db6a 25 23              [ 3 ]           BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
4239 db6c a6 61              [ 5 ]           LDA  $01,S          ; GET LENGTH OF TARGET STRING
4240 db6e 27 1c              [ 3 ]           BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
4241 db70 e6 66              [ 5 ]           LDB  $06,S          ; GET START POSITION
4242 db72 5a                 [ 2 ]           DECB                ; MOVE BACK ONE
4243 db73 3a                 [ 3 ]           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
4244 db74 31 84              [ 4 ] L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
4245 db76 ee 62              [ 6 ]           LDU  $02,S          ; POINT U TO START OF TARGET
4246 db78 e6 61              [ 5 ]           LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
4247 db7a a6 e4              [ 4 ]           LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
4248 db7c a0 66              [ 5 ]           SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
4249 db7e 4c                 [ 2 ]           INCA                ; ADD ONE
4250 db7f a1 61              [ 5 ]           CMPA $01,S          ; COMPARE TO TARGET LENGTH
4251 db81 25 0c              [ 3 ]           BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
4252 db83 a6 80              [ 6 ] L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
4253 db85 a1 c0              [ 6 ]           CMPA ,U+            ; COMPARE IT TO TARGET STRING
4254 db87 26 0c              [ 3 ]           BNE  L87DF          ; BRANCH IF NO MATCH
4255 db89 5a                 [ 2 ]           DECB                ; DECREMENT TARGET LENGTH
4256 db8a 26 f7              [ 3 ]           BNE  L87CD          ; CHECK ANOTHER CHARACTER
4257 db8c e6 66              [ 5 ] L87D6     LDB  $06,S          ; GET MATCH POSITION
4258 db8e 21                       L87D8     FCB  SKP1           ; SKIP NEXT BYTE
4259 db8f 5f                 [ 2 ] L87D9     CLRB                ; MATCH ADDRESS = 0
4260 db90 32 67              [ 5 ]           LEAS $07,S          ; CLEAN UP THE STACK
4261 db92 7e cc 7a           [ 4 ]           JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
4262 db95 6c 66              [ 7 ] L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
4263 db97 30 21              [ 5 ]           LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
4264 db99 20 d9              [ 3 ]           BRA  L87BE          ; KEEP LOOKING FOR A MATCH
4265                               
4266                               * EXTENDED BASIC RVEC19 HOOK CODE
4267 db9b 81 26              [ 2 ] XVEC19    CMPA #'&            ; *
4268 db9d 26 5c              [ 3 ]           BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
4269 db9f 32 62              [ 5 ]           LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4270                               * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
4271 dba1 0f 52              [ 6 ] L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
4272 dba3 0f 53              [ 6 ]           CLR  FPA0+3         ; * BYTES OF FPA0
4273 dba5 8e 00 52           [ 3 ]           LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
4274 dba8 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4275 dbaa 81 4f              [ 2 ]           CMPA #'O
4276 dbac 27 12              [ 3 ]           BEQ  L880A          ; YES
4277 dbae 81 48              [ 2 ]           CMPA #'H
4278 dbb0 27 23              [ 3 ]           BEQ  L881F          ; YES
4279 dbb2 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4280 dbb4 20 0c              [ 3 ]           BRA  L880C          ; DEFAULT TO OCTAL (&O)
4281 dbb6 81 38              [ 2 ] L8800     CMPA #'8
4282 dbb8 10 22 ee 47        [ 6 ]           LBHI LB277
4283 dbbc c6 03              [ 2 ]           LDB  #$03           ; BASE 8 MULTIPLIER
4284 dbbe 8d 2a              [ 7 ]           BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4285                               * EVALUATE AN &O VARIABLE
4286 dbc0 9d 7c              [ 7 ] L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4287 dbc2 25 f2              [ 3 ] L880C     BLO  L8800          ; BRANCH IF NUMERIC
4288 dbc4 0f 50              [ 6 ] L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
4289 dbc6 0f 51              [ 6 ]           CLR  FPA0+1         ; * BYTES OF FPA0
4290 dbc8 0f 06              [ 6 ]           CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
4291 dbca 0f 63              [ 6 ]           CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
4292 dbcc 0f 54              [ 6 ]           CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
4293 dbce c6 a0              [ 2 ]           LDB  #$A0           ; * SET EXPONENT OF FPA0
4294 dbd0 d7 4f              [ 4 ]           STB  FP0EXP         ; *
4295 dbd2 7e d1 68           [ 4 ]           JMP  LBA1C          ; GO NORMALIZE FPA0
4296                               * EVALUATE AN &H VARIABLE
4297 dbd5 9d 7c              [ 7 ] L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4298 dbd7 25 0b              [ 3 ]           BLO  L882E          ; BRANCH IF NUMERIC
4299 dbd9 bd cb 29           [ 8 ]           JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4300 dbdc 25 e6              [ 3 ]           BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
4301 dbde 81 47              [ 2 ]           CMPA #'G            ; CHECK FOR LETTERS A-F
4302 dbe0 24 e2              [ 3 ]           BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
4303 dbe2 80 07              [ 2 ]           SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
4304 dbe4 c6 04              [ 2 ] L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
4305 dbe6 8d 02              [ 7 ]           BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4306 dbe8 20 eb              [ 3 ]           BRA  L881F          ; KEEP EVALUATING VARIABLE
4307 dbea 68 01              [ 7 ] L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
4308 dbec 69 84              [ 6 ]           ROL  ,X             ; * ACCUMULATOR BY TWO
4309 dbee 10 25 f5 ec        [ 6 ]           LBCS LBA92          ; 'OV' OVERFLOW ERROR
4310 dbf2 5a                 [ 2 ]           DECB                ; DECREMENT SHIFT COUNTER
4311 dbf3 26 f5              [ 3 ]           BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
4312 dbf5 80 30              [ 2 ]           SUBA #'0            ; MASK OFF ASCII
4313 dbf7 ab 01              [ 5 ]           ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
4314 dbf9 a7 01              [ 5 ]           STA  $01,X          ; * ACCUMULATOR AND SAVE IT
4315 dbfb 39                 [ 5 ] L8845     RTS
4316                               
4317 dbfc 35 40              [ 7 ] XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
4318 dbfe 0f 06              [ 6 ]           CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4319 dc00 9e 83              [ 5 ]           LDX  CHARAD         ; CURRENT INPUT POINTER TO X
4320 dc02 9d 7c              [ 7 ]           JSR  GETNCH         ; GET CHARACTER FROM BASIC
4321 dc04 81 26              [ 2 ]           CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
4322 dc06 27 99              [ 3 ]           BEQ  L87EB          ; PROCESS A '&' VARIABLE
4323 dc08 81 b0              [ 2 ]           CMPA #TOK_FN        ; TOKEN FOR FN
4324 dc0a 27 5e              [ 3 ]           BEQ  L88B4          ; PROCESS FN CALL
4325 dc0c 81 ff              [ 2 ]           CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4326 dc0e 26 08              [ 3 ]           BNE  L8862          ; NOT SECONDARY
4327 dc10 9d 7c              [ 7 ]           JSR  GETNCH         ; GET CHARACTER FROM BASIC
4328 dc12 81 83              [ 2 ]           CMPA #TOK_USR       ; TOKEN FOR USR
4329 dc14 10 27 00 ab        [ 6 ]           LBEQ L892C          ; PROCESS USR CALL
4330 dc18 9f 83              [ 5 ] L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
4331 dc1a 6e c4              [ 3 ]           JMP  ,U             ; RETURN TO CALLING ROUTINE
4332 dc1c 9e 68              [ 5 ] L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
4333 dc1e 30 01              [ 5 ]           LEAX $01,X          ; IN DIRECT MODE?
4334 dc20 26 d9              [ 3 ]           BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
4335 dc22 c6 16              [ 2 ]           LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
4336 dc24 7e c4 06           [ 4 ] L886E     JMP  LAC46          ; PROCESS ERROR
4337                               
4338 dc27 ae 9f 00 83        [10 ] DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
4339 dc2b 8c ff 83           [ 4 ]           CMPX #TOK_FF_USR    ; TOKEN FOR USR
4340 dc2e 10 27 00 74        [ 6 ]           LBEQ L890F          ; BRANCH IF DEF USR
4341 dc32 8d 23              [ 7 ]           BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
4342 dc34 8d e6              [ 7 ]           BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
4343 dc36 bd c9 f6           [ 8 ]           JSR  LB26A          ; SYNTAX CHECK FOR '('
4344 dc39 c6 80              [ 2 ]           LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
4345 dc3b d7 08              [ 4 ]           STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
4346 dc3d bd ca de           [ 8 ]           JSR  LB357          ; GET VARIABLE DESCRIPTOR
4347 dc40 8d 25              [ 7 ]           BSR  L88B1          ; 'TM' ERROR IF STRING
4348 dc42 bd c9 f3           [ 8 ]           JSR  LB267          ; SYNTAX CHECK FOR ')'
4349 dc45 c6 ae              [ 2 ]           LDB  #TOK_EQUALS    ; TOKEN FOR '='
4350 dc47 bd c9 fb           [ 8 ]           JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4351 dc4a 9e 4b              [ 5 ]           LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
4352 dc4c dc 83              [ 5 ]           LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
4353 dc4e ed 84              [ 5 ]           STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
4354 dc50 dc 39              [ 5 ]           LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
4355 dc52 ed 02              [ 6 ]           STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
4356 dc54 7e c6 90           [ 4 ]           JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
4357 dc57 c6 b0              [ 2 ] L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
4358 dc59 bd c9 fb           [ 8 ]           JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
4359 dc5c c6 80              [ 2 ]           LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
4360 dc5e d7 08              [ 4 ]           STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
4361 dc60 8a 80              [ 2 ]           ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
4362 dc62 bd ca e3           [ 8 ]           JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
4363 dc65 9f 4b              [ 5 ]           STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
4364 dc67 7e c8 cf           [ 4 ] L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
4365                               * EVALUATE AN FN CALL
4366 dc6a 8d eb              [ 7 ] L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
4367 dc6c 34 10              [ 7 ]           PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
4368 dc6e bd c9 ee           [ 8 ]           JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4369 dc71 8d f4              [ 7 ]           BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
4370 dc73 35 40              [ 7 ]           PULS U              ; POINT U TO FN NAME DESCRIPTOR
4371 dc75 c6 32              [ 2 ]           LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
4372 dc77 ae 42              [ 6 ]           LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
4373 dc79 27 a9              [ 3 ]           BEQ  L886E          ; BRANCH TO ERROR HANDLER
4374 dc7b 10 9e 83           [ 6 ]           LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
4375 dc7e ee c4              [ 5 ]           LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
4376 dc80 df 83              [ 5 ]           STU  CHARAD         ; * SAVE IT IN INPUT POINTER
4377 dc82 a6 04              [ 5 ]           LDA  $04,X          ; = GET FP VALUE OF
4378 dc84 34 02              [ 6 ]           PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
4379 dc86 ec 84              [ 5 ]           LDD  ,X             ; = POINTER, AND ADDRESS OF START
4380 dc88 ee 02              [ 6 ]           LDU  $02,X          ; = OF FN FORMULA AND SAVE
4381 dc8a 34 76              [13 ]           PSHS U,Y,X,B,A      ; = THEM ON THE STACK
4382 dc8c bd d3 81           [ 8 ]           JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
4383 dc8f bd c8 cd           [ 8 ] L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
4384 dc92 35 76              [13 ]           PULS A,B,X,Y,U      ; RESTORE REGISTERS
4385 dc94 ed 84              [ 5 ]           STD  ,X             ; * GET THE FP
4386 dc96 ef 02              [ 6 ]           STU  $02,X          ; * VALUE OF THE ARGUMENT
4387 dc98 35 02              [ 6 ]           PULS A              ; * VARIABLE OFF OF THE
4388 dc9a a7 04              [ 5 ]           STA  $04,X          ; * STACK AND RE-SAVE IT
4389 dc9c 9d 82              [ 7 ]           JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
4390 dc9e 10 26 ed 61        [ 6 ]           LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
4391 dca2 10 9f 83           [ 6 ]           STY  CHARAD         ; RESTORE INPUT POINTER
4392 dca5 39                 [ 5 ] L88EF     RTS
4393                               
4394                               
4395                               
4396                               * DEF USR
4397 dca6 9d 7c              [ 7 ] L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
4398 dca8 8d 09              [ 7 ]           BSR  L891C          ; GET FN NUMBER
4399 dcaa 34 10              [ 7 ]           PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
4400 dcac 8d 2d              [ 7 ]           BSR  L8944          ; CALCULATE EXEC ADDRESS
4401 dcae 35 40              [ 7 ]           PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
4402 dcb0 af c4              [ 5 ]           STX  ,U             ; SAVE EXEC ADDRESS
4403 dcb2 39                 [ 5 ]           RTS
4404 dcb3 5f                 [ 2 ] L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
4405 dcb4 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4406 dcb6 24 06              [ 3 ]           BCC  L8927          ; BRANCH IF NOT NUMERIC
4407 dcb8 80 30              [ 2 ]           SUBA #'0            ; MASK OFF ASCII
4408 dcba 1f 89              [ 6 ]           TFR  A,B            ; SAVE USR NUMBER IN ACCB
4409 dcbc 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4410 dcbe 9e 8d              [ 5 ] L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
4411 dcc0 58                 [ 2 ]           ASLB                ; X2 - 2 BYTES/USR ADDRESS
4412 dcc1 3a                 [ 3 ]           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
4413 dcc2 39                 [ 5 ]           RTS
4414                               * PROCESS A USR CALL
4415 dcc3 8d ee              [ 7 ] L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
4416 dcc5 ae 84              [ 5 ]           LDX  ,X             ; * GET EXEC ADDRESS AND
4417 dcc7 34 10              [ 7 ]           PSHS X              ; * PUSH IT ONTO STACK
4418 dcc9 bd c9 ee           [ 8 ]           JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4419 dccc 8e 00 4f           [ 3 ]           LDX  #FP0EXP        ; POINT X TO FPA0
4420 dccf 96 06              [ 4 ]           LDA  VALTYP         ; GET VARIABLE TYPE
4421 dcd1 27 07              [ 3 ]           BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
4422 dcd3 bd cd de           [ 8 ]           JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
4423 dcd6 9e 52              [ 5 ]           LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
4424 dcd8 96 06              [ 4 ]           LDA  VALTYP         ; GET VARIABLE TYPE
4425 dcda 39                 [ 5 ] L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
4426 dcdb c6 ae              [ 2 ] L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
4427 dcdd bd c9 fb           [ 8 ]           JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4428 dce0 7e ce c4           [ 4 ]           JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
4429                               
4430                               
4431                               
4432                               * DEL
4433 dce3 10 27 ee ea        [ 6 ] DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
4434 dce7 bd c7 17           [ 8 ]           JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
4435 dcea bd c4 a5           [ 8 ]           JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
4436 dced 9f 93              [ 5 ]           STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
4437 dcef 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4438 dcf1 27 10              [ 3 ]           BEQ  L8990          ; BRANCH IF END OF LINE
4439 dcf3 81 a7              [ 2 ]           CMPA #TOK_MINUS     ; TOKEN FOR '-'
4440 dcf5 26 3b              [ 3 ]           BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
4441 dcf7 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4442 dcf9 27 04              [ 3 ]           BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
4443 dcfb 8d 24              [ 7 ]           BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
4444 dcfd 20 04              [ 3 ]           BRA  L8990          ; * AND SAVE IT IN BINVAL
4445 dcff 86 ff              [ 2 ] L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
4446 dd01 97 2b              [ 4 ]           STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
4447 dd03 de 93              [ 5 ] L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
4448 dd05 8c                       L8992     FCB  SKP2           ; SKIP TWO BYTES
4449 dd06 ee c4              [ 5 ] L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
4450 dd08 ec c4              [ 5 ]           LDD  ,U             ; CHECK FOR END OF PROGRAM
4451 dd0a 27 06              [ 3 ]           BEQ  L899F          ; BRANCH IF END OF PROGRAM
4452 dd0c ec 42              [ 6 ]           LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
4453 dd0e 93 2b              [ 6 ]           SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
4454 dd10 23 f4              [ 3 ]           BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
4455 dd12 9e 93              [ 5 ] L899F     LDX  VD3            ; GET STARTING LINE NUMBER
4456 dd14 8d 15              [ 7 ]           BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
4457 dd16 bd c4 c5           [ 8 ]           JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
4458 dd19 9e 93              [ 5 ]           LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
4459 dd1b bd c4 95           [ 8 ]           JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
4460 dd1e 7e c4 25           [ 4 ]           JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
4461 dd21 bd c7 17           [ 8 ] L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
4462 dd24 7e c1 ba           [ 4 ]           JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
4463 dd27 a6 c0              [ 6 ] L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
4464 dd29 a7 80              [ 6 ]           STA  ,X+            ; MOVE THE BYTE TO (X)
4465 dd2b 11 93 1b           [ 7 ] L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
4466 dd2e 26 f7              [ 3 ]           BNE  L89B4          ; BRANCH IF NOT AT END
4467 dd30 9f 1b              [ 5 ]           STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
4468 dd32 39                 [ 5 ] L89BF     RTS
4469                               
4470                               
4471 dd33 bd dc 1c           [ 8 ] L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
4472 dd36 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHAR FROM BASIC
4473 dd38 81 22              [ 2 ] L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
4474 dd3a 26 0b              [ 3 ]           BNE  L89E1          ; BRANCH IF NO PROMPT STRING
4475 dd3c bd c9 d0           [ 8 ]           JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
4476 dd3f c6 3b              [ 2 ]           LDB  #';            ; *
4477 dd41 bd c9 fb           [ 8 ]           JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
4478 dd44 bd d0 eb           [ 8 ]           JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
4479 dd47 32 7e              [ 5 ] L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
4480 dd49 bd c7 cc           [ 8 ]           JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
4481 dd4c 32 62              [ 5 ]           LEAS $02,S          ; CLEAN UP THE STACK
4482 dd4e bd ca de           [ 8 ]           JSR  LB357          ; SEARCH FOR A VARIABLE
4483 dd51 9f 3b              [ 5 ]           STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
4484 dd53 bd c8 d2           [ 8 ]           JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
4485 dd56 8e 00 f3           [ 3 ]           LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
4486 dd59 4f                 [ 2 ]           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
4487 dd5a bd cc a3           [ 8 ]           JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
4488 dd5d 7e c7 54           [ 4 ]           JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
4489 dd60 bd c7 17           [ 8 ] L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
4490 dd63 9e 2b              [ 5 ]           LDX  BINVAL         ; GET BINARY VALUE
4491 dd65 39                 [ 5 ]           RTS
4492 dd66 9e 91              [ 5 ] L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
4493 dd68 9f 2b              [ 5 ] L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
4494 dd6a 7e c4 a5           [ 4 ]           JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
4495                               
4496                               * RENUM
4497 dd6d bd c4 ca           [ 8 ] RENUM     JSR  LAD26          ; ERASE VARIABLES
4498 dd70 cc 00 0a           [ 3 ]           LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
4499 dd73 dd 95              [ 5 ]           STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
4500 dd75 dd 8f              [ 5 ]           STD  VCF            ; SAVE DEFAULT INTERVAL
4501 dd77 5f                 [ 2 ]           CLRB                ; NOW ACCD = 0
4502 dd78 dd 91              [ 5 ]           STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
4503 dd7a 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4504 dd7c 24 06              [ 3 ]           BCC  L8A20          ; BRANCH IF NOT NUMERIC
4505 dd7e 8d e0              [ 7 ]           BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4506 dd80 9f 95              [ 5 ]           STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
4507 dd82 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4508 dd84 27 1b              [ 3 ] L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
4509 dd86 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4510 dd89 24 06              [ 3 ]           BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4511 dd8b 8d d3              [ 7 ]           BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4512 dd8d 9f 91              [ 5 ]           STX  VD1            ; SAVE NEW RENUMBER LINE
4513 dd8f 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4514 dd91 27 0e              [ 3 ] L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
4515 dd93 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4516 dd96 24 06              [ 3 ]           BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4517 dd98 8d c6              [ 7 ]           BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4518 dd9a 9f 8f              [ 5 ]           STX  VCF            ; SAVE NEW INTERVAL
4519 dd9c 27 49              [ 3 ]           BEQ  L8A83          ; 'FC' ERROR
4520 dd9e bd c1 ba           [ 8 ] L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
4521 dda1 8d c3              [ 7 ] L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
4522 dda3 9f 93              [ 5 ]           STX  VD3            ; SAVE ADDRESS
4523 dda5 9e 95              [ 5 ]           LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
4524 dda7 8d bf              [ 7 ]           BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
4525 dda9 9c 93              [ 6 ]           CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
4526 ddab 25 3a              [ 3 ]           BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
4527 ddad 8d 1c              [ 7 ]           BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
4528 ddaf bd de 41           [ 8 ]           JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
4529 ddb2 bd c4 93           [ 8 ]           JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
4530 ddb5 8d af              [ 7 ]           BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
4531 ddb7 9f 93              [ 5 ]           STX  VD3            ; SAVE IT
4532 ddb9 8d 3a              [ 7 ]           BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
4533 ddbb 8d 0f              [ 7 ]           BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
4534 ddbd 8d 36              [ 7 ]           BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
4535 ddbf bd de dc           [ 8 ]           JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
4536 ddc2 bd c4 ca           [ 8 ]           JSR  LAD26          ; ERASE VARIABLES
4537 ddc5 bd c4 93           [ 8 ]           JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
4538 ddc8 7e c4 25           [ 4 ]           JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
4539 ddcb 86                       L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
4540 ddcc 4f                 [ 2 ] L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
4541 ddcd 97 98              [ 4 ]           STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
4542 ddcf 9e 93              [ 5 ]           LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
4543 ddd1 dc 95              [ 5 ]           LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
4544 ddd3 8d 15              [ 7 ]           BSR  L8A86          ; RETURN IF END OF PROGRAM
4545 ddd5 0d 98              [ 6 ] L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
4546 ddd7 26 02              [ 3 ]           BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
4547 ddd9 ed 02              [ 6 ]           STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
4548 dddb ae 84              [ 5 ] L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
4549 dddd 8d 0b              [ 7 ]           BSR  L8A86          ; RETURN IF END OF PROGRAM
4550 dddf d3 8f              [ 6 ]           ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
4551 dde1 25 04              [ 3 ]           BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
4552 dde3 81 fa              [ 2 ]           CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
4553 dde5 25 ee              [ 3 ]           BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
4554 dde7 7e cb d1           [ 4 ] L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
4555                               * TEST THE TWO BYTES POINTED TO BY (X).
4556                               * NORMAL RETURN IF <> 0. IF = 0 (END OF
4557                               * PROGRAM) RETURN IS PULLED OFF STACK AND
4558                               * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
4559 ddea 34 06              [ 7 ] L8A86     PSHS B,A            ; SAVE ACCD
4560 ddec ec 84              [ 5 ]           LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
4561 ddee 35 06              [ 7 ]           PULS A,B            ; RESTORE ACCD
4562 ddf0 26 02              [ 3 ]           BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
4563 ddf2 32 62              [ 5 ]           LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4564 ddf4 39                 [ 5 ] L8A90     RTS
4565 ddf5 9e 19              [ 5 ] L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
4566 ddf7 30 1f              [ 5 ]           LEAX -1,X           ; MOVE POINTER BACK ONE
4567 ddf9 30 01              [ 5 ] L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
4568 ddfb 8d ed              [ 7 ]           BSR  L8A86          ; RETURN IF END OF PROGRAM
4569 ddfd 30 03              [ 5 ] L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
4570 ddff 30 01              [ 5 ] L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
4571 de01 a6 84              [ 4 ]           LDA  ,X             ; CHECK CURRENT CHARACTER
4572 de03 27 f4              [ 3 ]           BEQ  L8A95          ; BRANCH IF END OF LINE
4573 de05 9f 0f              [ 5 ]           STX  TEMPTR         ; SAVE CURRENT POINTER
4574 de07 4a                 [ 2 ]           DECA                ; =
4575 de08 27 0c              [ 3 ]           BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
4576 de0a 4a                 [ 2 ]           DECA                ; *
4577 de0b 27 2a              [ 3 ]           BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
4578 de0d 4a                 [ 2 ]           DECA                ; =
4579 de0e 26 ef              [ 3 ]           BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
4580 de10 86 03              [ 2 ] L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
4581 de12 a7 80              [ 6 ]           STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
4582 de14 20 e7              [ 3 ]           BRA  L8A99          ; GO GET ANOTHER CHARACTER
4583 de16 ec 01              [ 6 ] L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
4584 de18 6a 02              [ 7 ]           DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
4585 de1a 27 01              [ 3 ]           BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
4586 de1c 4f                 [ 2 ]           CLRA                ; CLEAR MS BYTE
4587 de1d e6 03              [ 5 ] L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
4588 de1f 6a 04              [ 7 ]           DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
4589 de21 27 01              [ 3 ]           BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
4590 de23 5f                 [ 2 ]           CLRB                ; CLEAR LS BYTE
4591 de24 ed 01              [ 6 ] L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
4592 de26 dd 2b              [ 5 ]           STD  BINVAL         ; SAVE TRIAL LINE NUMBER
4593 de28 bd c4 a5           [ 8 ]           JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
4594 de2b 9e 0f              [ 5 ] L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
4595 de2d 25 e1              [ 3 ]           BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
4596 de2f dc 47              [ 5 ]           LDD  V47            ; GET START ADDRESS OF LINE NUMBER
4597 de31 6c 80              [ 8 ]           INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
4598                               *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
4599                               
4600 de33 ed 84              [ 5 ]           STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
4601 de35 20 c6              [ 3 ]           BRA  L8A99          ; GO GET ANOTHER CHARACTER
4602 de37 6f 84              [ 6 ] L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
4603 de39 ae 01              [ 6 ]           LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
4604 de3b ae 02              [ 6 ]           LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
4605 de3d 9f 47              [ 5 ]           STX  V47            ; SAVE IT TEMPORARILY
4606 de3f 20 ea              [ 3 ]           BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
4607 de41 9e 19              [ 5 ] L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
4608 de43 20 04              [ 3 ]           BRA  L8AE5
4609 de45 9e 83              [ 5 ] L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
4610 de47 30 01              [ 5 ]           LEAX $01,X          ; *AND BUMP IT ONE
4611 de49 8d 9f              [ 7 ] L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
4612 de4b 30 02              [ 5 ]           LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
4613 de4d 30 01              [ 5 ] L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
4614 de4f 9f 83              [ 5 ] L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
4615 de51 9d 7c              [ 7 ] L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4616 de53 4d                 [ 2 ] L8AEF     TSTA                ; CHECK THE CHARACTER
4617 de54 27 ef              [ 3 ]           BEQ  L8AE1          ; BRANCH IF END OF LINE
4618 de56 2a f9              [ 3 ]           BPL  L8AED          ; BRANCH IF NOT A TOKEN
4619 de58 9e 83              [ 5 ]           LDX  CHARAD         ; GET CURRENT INPUT POINTER
4620 de5a 81 ff              [ 2 ]           CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
4621 de5c 27 ef              [ 3 ]           BEQ  L8AE9          ; YES - IGNORE IT
4622 de5e 81 a2              [ 2 ]           CMPA #TOK_THEN      ; TOKEN FOR THEN?
4623 de60 27 12              [ 3 ]           BEQ  L8B13          ; YES
4624 de62 81 84              [ 2 ]           CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
4625 de64 27 0e              [ 3 ]           BEQ  L8B13          ; YES
4626 de66 81 81              [ 2 ]           CMPA #TOK_GO        ; TOKEN FOR GO?
4627 de68 26 e7              [ 3 ]           BNE  L8AED          ; NO
4628 de6a 9d 7c              [ 7 ]           JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4629 de6c 81 a0              [ 2 ]           CMPA #TOK_TO        ; TOKEN FOR TO?
4630 de6e 27 04              [ 3 ]           BEQ  L8B13          ; YES
4631 de70 81 a1              [ 2 ]           CMPA #TOK_SUB       ; TOKEN FOR SUB?
4632 de72 26 db              [ 3 ]           BNE  L8AEB          ; NO
4633 de74 9d 7c              [ 7 ] L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4634 de76 25 04              [ 3 ]           BLO  L8B1B          ; BRANCH IF NUMERIC
4635 de78 9d 82              [ 7 ] L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
4636 de7a 20 d7              [ 3 ]           BRA  L8AEF          ; KEEP CHECKING THE LINE
4637 de7c 9e 83              [ 5 ] L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
4638 de7e 34 10              [ 7 ]           PSHS X              ; SAVE IT ON THE STACK
4639 de80 bd c7 17           [ 8 ]           JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
4640 de83 9e 83              [ 5 ]           LDX  CHARAD         ; GET CURRENT INPUT POINTER
4641 de85 a6 82              [ 6 ] L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
4642 de87 bd e1 ec           [ 8 ]           JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
4643 de8a 25 f9              [ 3 ]           BLO  L8B24          ; BRANCH IF NON-NUMERIC
4644 de8c 30 01              [ 5 ]           LEAX $01,X          ; MOVE POINTER UP ONE
4645 de8e 1f 10              [ 6 ]           TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
4646 de90 e0 61              [ 5 ]           SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
4647 de92 c0 05              [ 2 ]           SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
4648                               *
4649 de94 27 20              [ 3 ]           BEQ  L8B55          ; BRANCH IF EXACTLY 5
4650 de96 25 0a              [ 3 ]           BLO  L8B41          ; BRANCH IF < 5
4651 de98 33 84              [ 4 ]           LEAU ,X             ; TRANSFER X TO U
4652 de9a 50                 [ 2 ]           NEGB                ; NEGATE B
4653 de9b 30 85              [ 5 ]           LEAX B,X            ; MOVE X BACK B BYTES
4654 de9d bd dd 2b           [ 8 ]           JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
4655                               *         *U   = END OF BASIC; (I) = NEW END OF BASIC
4656 dea0 20 14              [ 3 ]           BRA  L8B55
4657                               * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
4658 dea2 9f 47              [ 5 ] L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
4659 dea4 9e 1b              [ 5 ]           LDX  VARTAB         ; GET END OF BASIC PROGRAM
4660 dea6 9f 43              [ 5 ]           STX  V43            ; SAVE IT
4661 dea8 50                 [ 2 ]           NEGB                ; NEGATE B
4662 dea9 30 85              [ 5 ]           LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
4663 deab 9f 41              [ 5 ]           STX  V41            ; SAVE POINTER
4664 dead 9f 1b              [ 5 ]           STX  VARTAB         ; STORE END OF BASIC PROGRAM
4665 deaf bd c3 de           [ 8 ]           JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
4666 deb2 9e 45              [ 5 ]           LDX  V45            ; * GET AND SAVE THE
4667 deb4 9f 83              [ 5 ]           STX  CHARAD         ; * NEW CURRENT INPUT POINTER
4668 deb6 35 10              [ 7 ] L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
4669 deb8 86 01              [ 2 ]           LDA  #$01           ; NEW LINE NUMBER FLAG
4670 deba a7 84              [ 4 ]           STA  ,X             ; * SAVE NEW LINE FLAG
4671 debc a7 02              [ 5 ]           STA  $02,X          ; *
4672 debe a7 04              [ 5 ]           STA  $04,X          ; *
4673 dec0 d6 2b              [ 4 ]           LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
4674 dec2 26 04              [ 3 ]           BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
4675 dec4 c6 01              [ 2 ]           LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
4676                               *              ; THINK IT IS THE END OF A LINE
4677 dec6 6c 02              [ 7 ]           INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
4678 dec8 e7 01              [ 5 ] L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
4679 deca d6 2c              [ 4 ]           LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
4680 decc 26 04              [ 3 ]           BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
4681 dece c6 01              [ 2 ]           LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
4682 ded0 6c 04              [ 7 ]           INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
4683 ded2 e7 03              [ 5 ] L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
4684 ded4 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4685 ded6 81 2c              [ 2 ]           CMPA #',            ; IS IT A COMMA?
4686 ded8 27 9a              [ 3 ]           BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
4687 deda 20 9c              [ 3 ]           BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
4688 dedc 9e 19              [ 5 ] L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
4689 dede 30 1f              [ 5 ]           LEAX -1,X           ; MOVE POINTER BACK ONE
4690 dee0 30 01              [ 5 ] L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
4691 dee2 ec 02              [ 6 ]           LDD  $02,X          ; GET ADDRESS OF NEXT LINE
4692 dee4 dd 68              [ 5 ]           STD  CURLIN         ; SAVE IT IN CURLIN
4693 dee6 bd dd ea           [ 8 ]           JSR  L8A86          ; RETURN IF END OF PROGRAM
4694 dee9 30 03              [ 5 ]           LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
4695 deeb 30 01              [ 5 ] L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
4696 deed a6 84              [ 4 ] L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
4697 deef 27 ef              [ 3 ]           BEQ  L8B7F          ; BRANCH IF END OF LINE
4698 def1 4a                 [ 2 ]           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
4699 def2 27 1b              [ 3 ]           BEQ  L8BAE          ; YES
4700 def4 80 02              [ 2 ]           SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
4701 def6 26 f3              [ 3 ]           BNE  L8B8A          ; NO
4702 def8 34 10              [ 7 ]           PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4703 defa 8e df 39           [ 3 ]           LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
4704 defd bd d0 e8           [ 8 ]           JSR  LB99C          ; PRINT STRING TO THE SCREEN
4705 df00 ae e4              [ 5 ]           LDX  ,S             ; GET INPUT POINTER
4706 df02 ec 01              [ 6 ]           LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
4707 df04 bd d5 18           [ 8 ]           JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
4708 df07 bd d5 11           [ 8 ]           JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
4709 df0a bd d0 a8           [ 8 ]           JSR  LB958          ; SEND A CR TO CONSOLE OUT
4710 df0d 35 10              [ 7 ]           PULS X              ; GET INPUT POINTER BACK
4711 df0f 34 10              [ 7 ] L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4712 df11 ec 01              [ 6 ]           LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
4713 df13 dd 52              [ 5 ]           STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
4714 df15 bd db c4           [ 8 ]           JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
4715 df18 bd d5 25           [ 8 ]           JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
4716 df1b 35 40              [ 7 ]           PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
4717 df1d c6 05              [ 2 ]           LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
4718 df1f 30 01              [ 5 ] L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
4719 df21 a6 84              [ 4 ]           LDA  ,X             ; GET AN ASCII BYTE
4720 df23 27 05              [ 3 ]           BEQ  L8BC9          ; BRANCH IF END OF NUMBER
4721 df25 5a                 [ 2 ]           DECB                ; DECREMENT BYTE COUNTER
4722 df26 a7 c0              [ 6 ]           STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
4723 df28 20 f5              [ 3 ]           BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
4724 df2a 30 c4              [ 4 ] L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
4725 df2c 5d                 [ 2 ]           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
4726 df2d 27 be              [ 3 ]           BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
4727 df2f 31 c4              [ 4 ]           LEAY ,U             ; SAVE NEW LINE POINTER IN Y
4728 df31 33 c5              [ 5 ]           LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
4729 df33 bd dd 2b           [ 8 ]           JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
4730 df36 30 a4              [ 4 ]           LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
4731 df38 20 b3              [ 3 ]           BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
4732                               
4733 df3a 55 4c 20                 L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
4734 df3d 00                                 FCB  0
4735                               
4736                               
4737 df3e bd ce c7           [ 8 ] HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
4738 df41 8e 01 f0           [ 3 ]           LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
4739 df44 c6 04              [ 2 ]           LDB  #$04           ; CONVERT 4 NIBBLES
4740 df46 34 04              [ 6 ] L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
4741 df48 5f                 [ 2 ]           CLRB                ; CLEAR CARRY FLAG
4742 df49 86 04              [ 2 ]           LDA  #$04           ; 4 SHIFTS
4743 df4b 08 53              [ 6 ] L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
4744 df4d 09 52              [ 6 ]           ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
4745 df4f 59                 [ 2 ]           ROLB                ; IF OVERFLOW, ACCB <> 0
4746 df50 4a                 [ 2 ]           DECA                ; * DECREMENT SHIFT COUNTER AND
4747 df51 26 f8              [ 3 ]           BNE  L8BEA          ; * BRANCH IF NOT DONE
4748 df53 5d                 [ 2 ]           TSTB                ; CHECK FOR OVERFLOW
4749 df54 26 0a              [ 3 ]           BNE  L8BFF          ; BRANCH IF OVERFLOW
4750 df56 a6 e4              [ 4 ]           LDA  ,S             ; * GET NIBBLE COUNTER,
4751 df58 4a                 [ 2 ]           DECA                ; * DECREMENT IT AND
4752 df59 27 05              [ 3 ]           BEQ  L8BFF          ; * BRANCH IF DONE
4753 df5b 8c 01 f0           [ 4 ]           CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
4754 df5e 27 0c              [ 3 ]           BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
4755 df60 cb 30              [ 2 ] L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
4756 df62 c1 39              [ 2 ]           CMPB #'9            ; COMPARE TO ASCII 9
4757 df64 23 02              [ 3 ]           BLS  L8C07          ; BRANCH IF < 9
4758 df66 cb 07              [ 2 ]           ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
4759 df68 e7 80              [ 6 ] L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
4760 df6a 6f 84              [ 6 ]           CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
4761 df6c 35 04              [ 6 ] L8C0B     PULS B              ; * GET NIBBLE COUNTER,
4762 df6e 5a                 [ 2 ]           DECB                ; * DECREMENT IT AND
4763 df6f 26 d5              [ 3 ]           BNE  L8BE5          ; * BRANCH IF NOT DONE
4764 df71 32 62              [ 5 ]           LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
4765 df73 8e 01 ef           [ 3 ]           LDX  #STRBUF+1      ; RESET POINTER
4766 df76 7e cc 9f           [ 4 ]           JMP  LB518          ; SAVE STRING ON STRING STACK
4767                               * PROCESS EXCLAMATION POINT
4768 df79 86 01              [ 2 ] L8E37     LDA  #$01           ; * SET SPACES
4769 df7b 97 99              [ 4 ]           STA  VD9            ; * COUNTER = 1
4770                               * PROCESS STRING ITEM - LIST
4771 df7d 5a                 [ 2 ] L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4772 df7e bd e1 1a           [ 8 ]           JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
4773 df81 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4774 df83 10 27 00 93        [ 6 ]           LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
4775 df87 d7 93              [ 4 ]           STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
4776 df89 bd c8 e2           [ 8 ]           JSR  LB156          ; EVALUATE EXPRESSION
4777 df8c bd c8 d2           [ 8 ]           JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4778 df8f 9e 52              [ 5 ]           LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
4779 df91 9f 4d              [ 5 ]           STX  V4D            ; * AND SAVE IT IN V4D
4780 df93 d6 99              [ 4 ]           LDB  VD9            ; GET SPACES COUNTER
4781 df95 bd ce 34           [ 8 ]           JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
4782 df98 bd d0 eb           [ 8 ]           JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
4783                               * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
4784 df9b 9e 52              [ 5 ]           LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
4785 df9d d6 99              [ 4 ]           LDB  VD9            ; GET SPACES COUNTER
4786 df9f e0 84              [ 4 ]           SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
4787 dfa1 5a                 [ 2 ] L8E5F     DECB                ; DECREMENT DIFFERENCE
4788 dfa2 10 2b 01 4f        [ 6 ]           LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
4789 dfa6 bd d0 f8           [ 8 ]           JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
4790 dfa9 20 f6              [ 3 ]           BRA  L8E5F          ; KEEP PADDING
4791                               * PERCENT SIGN - PROCESS A %SPACES% COMMAND
4792 dfab d7 93              [ 4 ] L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
4793 dfad 9f 0f              [ 5 ]           STX  TEMPTR         ; * COUNTER AND POINTER
4794 dfaf 86 02              [ 2 ]           LDA  #$02           ; INITIAL SPACES COUNTER = 2
4795 dfb1 97 99              [ 4 ]           STA  VD9            ; SAVE IN SPACES COUNTER
4796 dfb3 a6 84              [ 4 ] L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
4797 dfb5 81 25              [ 2 ]           CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
4798 dfb7 27 c4              [ 3 ]           BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
4799 dfb9 81 20              [ 2 ]           CMPA #'             ; BLANK
4800 dfbb 26 07              [ 3 ]           BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
4801 dfbd 0c 99              [ 6 ]           INC  VD9            ; ADD ONE TO SPACES COUNTER
4802 dfbf 30 01              [ 5 ]           LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4803 dfc1 5a                 [ 2 ]           DECB                ; DECREMENT LENGTH COUNTER
4804 dfc2 26 ef              [ 3 ]           BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
4805 dfc4 9e 0f              [ 5 ] L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
4806 dfc6 d6 93              [ 4 ]           LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
4807 dfc8 86 25              [ 2 ]           LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
4808                               * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
4809 dfca bd e1 1a           [ 8 ] L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4810 dfcd bd c0 17           [ 8 ]           JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4811 dfd0 20 29              [ 3 ]           BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
4812                               
4813                               * PRINT RAM HOOK
4814 dfd2 81 b1              [ 2 ] XVEC9     CMPA #TOK_USING     ; USING TOKEN
4815 dfd4 27 01              [ 3 ]           BEQ  L8E95          ; BRANCH IF PRINT USING
4816 dfd6 39                 [ 5 ]           RTS
4817                               
4818                               * PRINT USING
4819                               * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
4820                               * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
4821                               * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
4822 dfd7 32 62              [ 5 ] L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
4823 dfd9 bd c8 e4           [ 8 ]           JSR  LB158          ; EVALUATE FORMAT STRING
4824 dfdc bd c8 d2           [ 8 ]           JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4825 dfdf c6 3b              [ 2 ]           LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
4826 dfe1 bd c9 fb           [ 8 ]           JSR  LB26F          ; SYNTAX CHECK FOR ;
4827 dfe4 9e 52              [ 5 ]           LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
4828 dfe6 9f 95              [ 5 ]           STX  VD5            ; * AND SAVE IT IN VD5
4829 dfe8 20 06              [ 3 ]           BRA  L8EAE          ; GO PROCESS FORMAT STRING
4830 dfea 96 97              [ 4 ] L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
4831 dfec 27 08              [ 3 ]           BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
4832 dfee 9e 95              [ 5 ]           LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
4833 dff0 0f 97              [ 6 ] L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4834 dff2 e6 84              [ 4 ]           LDB  ,X             ; GET LENGTH OF FORMAT STRING
4835 dff4 26 03              [ 3 ]           BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
4836 dff6 7e cb d1           [ 4 ] L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
4837 dff9 ae 02              [ 6 ] L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
4838                               * INTERPRET THE FORMAT STRING
4839 dffb 0f 9a              [ 6 ] L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
4840 dffd 0f 99              [ 6 ] L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
4841 dfff a6 80              [ 6 ]           LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4842 e001 81 21              [ 2 ]           CMPA #'!            ; EXCLAMATION POINT?
4843 e003 10 27 ff 72        [ 6 ]           LBEQ L8E37          ; YES - STRING TYPE FORMAT
4844 e007 81 23              [ 2 ]           CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
4845 e009 27 5b              [ 3 ]           BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
4846 e00b 5a                 [ 2 ]           DECB                ; DECREMENT FORMAT STRING LENGTH
4847 e00c 26 16              [ 3 ]           BNE  L8EE2          ; BRANCH IF NOT DONE
4848 e00e bd e1 1a           [ 8 ]           JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4849 e011 bd c0 17           [ 8 ]           JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4850 e014 9d 82              [ 7 ] L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4851 e016 26 d2              [ 3 ]           BNE  L8EA8          ; BRANCH IF NOT END OF LINE
4852 e018 96 97              [ 4 ]           LDA  VD7            ; GET NEXT PRINT ITEM FLAG
4853 e01a 26 03              [ 3 ] L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
4854 e01c bd d0 a8           [ 8 ]           JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4855 e01f 9e 95              [ 5 ] L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
4856 e021 7e cd e0           [ 4 ]           JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
4857 e024 81 2b              [ 2 ] L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
4858 e026 26 09              [ 3 ]           BNE  L8EEF          ; NO PLUS
4859 e028 bd e1 1a           [ 8 ]           JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4860 e02b 86 08              [ 2 ]           LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
4861 e02d 97 9a              [ 4 ]           STA  VDA            ; * PRE-SIGN FORCE FLAG
4862 e02f 20 cc              [ 3 ]           BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
4863 e031 81 2e              [ 2 ] L8EEF     CMPA #'.            ; DECIMAL POINT?
4864 e033 27 4e              [ 3 ]           BEQ  L8F41          ; YES
4865 e035 81 25              [ 2 ]           CMPA #'%            ; PERCENT SIGN?
4866 e037 10 27 ff 70        [ 6 ]           LBEQ L8E69          ; YES
4867 e03b a1 84              [ 4 ]           CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
4868                               *              ; CHARACTER TO THE NEXT ONE IN THE STRING
4869 e03d 26 8b              [ 3 ] L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
4870                               * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
4871 e03f 81 24              [ 2 ]           CMPA #'$            ; DOLLAR SIGN?
4872 e041 27 19              [ 3 ]           BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
4873 e043 81 2a              [ 2 ]           CMPA #'*            ; ASTERISK?
4874 e045 26 f6              [ 3 ]           BNE  L8EFB          ; NO - ILLEGAL CHARACTER
4875 e047 96 9a              [ 4 ]           LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
4876 e049 8a 20              [ 2 ]           ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
4877 e04b 97 9a              [ 4 ]           STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
4878 e04d c1 02              [ 2 ]           CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
4879 e04f 25 11              [ 3 ]           BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
4880 e051 a6 01              [ 5 ]           LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
4881 e053 81 24              [ 2 ]           CMPA #'$            ; CHECK FOR **$
4882 e055 26 0b              [ 3 ]           BNE  L8F20          ; CHECK FOR MORE CHARACTERS
4883 e057 5a                 [ 2 ]           DECB                ; DECREMENT STRING LENGTH COUNTER
4884 e058 30 01              [ 5 ]           LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4885 e05a 0c 99              [ 6 ]           INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
4886                               *              ; FLOATING DOLLAR SIGN COMBINATION
4887 e05c 96 9a              [ 4 ] L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
4888 e05e 8a 10              [ 2 ]           ORA  #$10           ; * BIT 4 TO INDICATE A
4889 e060 97 9a              [ 4 ]           STA  VDA            ; * FLOATING DOLLAR SIGN
4890 e062 30 01              [ 5 ] L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4891 e064 0c 99              [ 6 ]           INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
4892                               * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
4893 e066 0f 98              [ 6 ] L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
4894 e068 0c 99              [ 6 ] L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
4895 e06a 5a                 [ 2 ]           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4896 e06b 27 49              [ 3 ]           BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4897 e06d a6 80              [ 6 ]           LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
4898 e06f 81 2e              [ 2 ]           CMPA #'.            ; DECIMAL POINT?
4899 e071 27 1e              [ 3 ]           BEQ  L8F4F          ; YES
4900 e073 81 23              [ 2 ]           CMPA #'#            ; NUMBER SIGN?
4901 e075 27 f1              [ 3 ]           BEQ  L8F26          ; YES
4902 e077 81 2c              [ 2 ]           CMPA #',            ; COMMA?
4903 e079 26 21              [ 3 ]           BNE  L8F5A          ; NO
4904 e07b 96 9a              [ 4 ]           LDA  VDA            ; * GET THE STATUS BYTE
4905 e07d 8a 40              [ 2 ]           ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
4906 e07f 97 9a              [ 4 ]           STA  VDA            ; * COMMA SEPARATOR FLAG
4907 e081 20 e5              [ 3 ]           BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
4908                               * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
4909 e083 a6 84              [ 4 ] L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
4910 e085 81 23              [ 2 ]           CMPA #'#            ; IS IT A NUMBER SIGN?
4911 e087 10 26 ff 3f        [ 6 ]           LBNE L8E88          ; NO
4912 e08b 86 01              [ 2 ]           LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
4913 e08d 97 98              [ 4 ]           STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
4914 e08f 30 01              [ 5 ]           LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4915                               * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
4916 e091 0c 98              [ 6 ] L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
4917 e093 5a                 [ 2 ]           DECB                ; DECREMENT FORMAT LENGTH COUNTER
4918 e094 27 20              [ 3 ]           BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4919 e096 a6 80              [ 6 ]           LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4920 e098 81 23              [ 2 ]           CMPA #'#            ; IS IT NUMBER SIGN?
4921 e09a 27 f5              [ 3 ]           BEQ  L8F4F          ; YES - KEEP CHECKING
4922                               * CHECK FOR EXPONENTIAL FORCE
4923 e09c 81 5e              [ 2 ] L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
4924 e09e 26 16              [ 3 ]           BNE  L8F74          ; NO UP ARROW
4925 e0a0 a1 84              [ 4 ]           CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
4926 e0a2 26 12              [ 3 ]           BNE  L8F74          ; NO
4927 e0a4 a1 01              [ 5 ]           CMPA $01,X          ; AND THE NEXT CHARACTER?
4928 e0a6 26 0e              [ 3 ]           BNE  L8F74          ; NO
4929 e0a8 a1 02              [ 5 ]           CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
4930 e0aa 26 0a              [ 3 ]           BNE  L8F74          ; NO, ALSO
4931 e0ac c1 04              [ 2 ]           CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
4932 e0ae 25 06              [ 3 ]           BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
4933 e0b0 c0 04              [ 2 ]           SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
4934 e0b2 30 04              [ 5 ]           LEAX $04,X          ; * FOUR FROM LENGTH
4935 e0b4 0c 9a              [ 6 ]           INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
4936                               
4937                               * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
4938 e0b6 30 1f              [ 5 ] L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
4939 e0b8 0c 99              [ 6 ]           INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
4940 e0ba 96 9a              [ 4 ]           LDA  VDA            ; * PRE-SIGN
4941 e0bc 85 08              [ 2 ]           BITA #$08           ; * FORCE AND
4942 e0be 26 18              [ 3 ]           BNE  L8F96          ; * BRANCH IF SET
4943 e0c0 0a 99              [ 6 ]           DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
4944 e0c2 5d                 [ 2 ]           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
4945 e0c3 27 13              [ 3 ]           BEQ  L8F96          ; * IF END OF FORMAT STRING
4946 e0c5 a6 84              [ 4 ]           LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
4947 e0c7 80 2d              [ 2 ]           SUBA #'-            ; CHECK FOR MINUS SIGN
4948 e0c9 27 06              [ 3 ]           BEQ  L8F8F          ; BRANCH IF MINUS SIGN
4949 e0cb 81 fe              [ 2 ]           CMPA #$FE           ; * WAS CMPA #('+')-('-')
4950 e0cd 26 09              [ 3 ]           BNE  L8F96          ; BRANCH IF NO PLUS SIGN
4951 e0cf 86 08              [ 2 ]           LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
4952 e0d1 8a 04              [ 2 ] L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
4953 e0d3 9a 9a              [ 4 ]           ORA  VDA            ; 'OR' IN THE STATUS BYTE
4954 e0d5 97 9a              [ 4 ]           STA  VDA            ; SAVE THE STATUS BYTE
4955 e0d7 5a                 [ 2 ]           DECB                ; DECREMENT FORMAT STRING LENGTH
4956                               
4957                               * EVALUATE NUMERIC ITEM-LIST
4958 e0d8 9d 82              [ 7 ] L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
4959 e0da 10 27 ff 3c        [ 6 ]           LBEQ L8ED8          ; BRANCH IF END OF LINE
4960 e0de d7 93              [ 4 ]           STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
4961 e0e0 bd c8 cd           [ 8 ]           JSR  LB141          ; EVALUATE EXPRESSION
4962 e0e3 96 99              [ 4 ]           LDA  VD9            ; GET THE LEFT DIGIT COUNTER
4963 e0e5 9b 98              [ 4 ]           ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
4964 e0e7 81 11              [ 2 ]           CMPA #17            ; *
4965 e0e9 10 22 ea e4        [ 6 ]           LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
4966 e0ed bd e1 27           [ 8 ]           JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
4967 e0f0 30 1f              [ 5 ]           LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
4968 e0f2 bd d0 e8           [ 8 ]           JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
4969 e0f5 0f 97              [ 6 ] L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4970 e0f7 9d 82              [ 7 ]           JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4971 e0f9 27 0d              [ 3 ]           BEQ  L8FC6          ; BRANCH IF END OF LINE
4972 e0fb 97 97              [ 4 ]           STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
4973 e0fd 81 3b              [ 2 ]           CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
4974 e0ff 27 05              [ 3 ]           BEQ  L8FC4          ; * BRANCH IF SEMICOLON
4975 e101 bd c9 f9           [ 8 ]           JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4976 e104 20 02              [ 3 ]           BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
4977 e106 9d 7c              [ 7 ] L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
4978 e108 9e 95              [ 5 ] L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
4979 e10a e6 84              [ 4 ]           LDB  ,X             ; GET LENGTH OF FORMAT STRING
4980 e10c d0 93              [ 4 ]           SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
4981 e10e ae 02              [ 6 ]           LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
4982 e110 3a                 [ 3 ]           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
4983 e111 d6 93              [ 4 ]           LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
4984 e113 10 26 fe e4        [ 6 ]           LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
4985 e117 7e e0 14           [ 4 ]           JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
4986                               *         USED ON LAST PRINT ITEM
4987                               
4988                               * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
4989 e11a 34 02              [ 6 ] L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
4990 e11c 86 2b              [ 2 ]           LDA  #'+            ; GET ASCII PLUS SIGN
4991 e11e 0d 9a              [ 6 ]           TST  VDA            ; * CHECK THE STATUS BYTE AND
4992 e120 27 03              [ 3 ]           BEQ  L8FE3          ; * RETURN IF = 0
4993 e122 bd c0 17           [ 8 ]           JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
4994 e125 35 82              [ 8 ] L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
4995                               
4996                               * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
4997 e127 ce 01 f2           [ 3 ] L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
4998 e12a c6 20              [ 2 ]           LDB  #SPACE         ; BLANK
4999 e12c 96 9a              [ 4 ]           LDA  VDA            ; * GET THE STATUS FLAG AND
5000 e12e 85 08              [ 2 ]           BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
5001 e130 27 02              [ 3 ]           BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
5002 e132 c6 2b              [ 2 ]           LDB  #'+            ; PLUS SIGN
5003 e134 0d 54              [ 6 ] L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
5004 e136 2a 04              [ 3 ]           BPL  L8FFA          ; BRANCH IF POSITIVE
5005 e138 0f 54              [ 6 ]           CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
5006 e13a c6 2d              [ 2 ]           LDB  #'-            ; MINUS SIGN
5007 e13c e7 c0              [ 6 ] L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
5008 e13e c6 30              [ 2 ]           LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
5009 e140 e7 c0              [ 6 ]           STB  ,U+            ; *
5010 e142 84 01              [ 2 ]           ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
5011 e144 10 26 01 07        [ 6 ]           LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
5012 e148 8e d5 0c           [ 3 ]           LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
5013 e14b bd d3 ec           [ 8 ]           JSR  LBCA0          ; COMPARE FPA0 TO (X)
5014 e14e 2b 15              [ 3 ]           BMI  L9023          ; BRANCH IF FPA0 < 1E+09
5015 e150 bd d5 25           [ 8 ]           JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5016 e153 a6 80              [ 6 ] L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
5017 e155 26 fc              [ 3 ]           BNE  L9011          ; * ASCII STRING (ZERO BYTE)
5018 e157 a6 82              [ 6 ] L9015     LDA  ,-X            ; MOVE THE
5019 e159 a7 01              [ 5 ]           STA  $01,X          ; ENTIRE STRING
5020 e15b 8c 01 f1           [ 4 ]           CMPX #STRBUF+3      ; UP ONE
5021 e15e 26 f7              [ 3 ]           BNE  L9015          ; BYTE
5022 e160 86 25              [ 2 ]           LDA  #'%            ; * INSERT A % SIGN AT START OF
5023 e162 a7 84              [ 4 ]           STA  ,X             ; * STRING - OVERFLOW ERROR
5024 e164 39                 [ 5 ]           RTS
5025                               
5026 e165 96 4f              [ 4 ] L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5027 e167 97 47              [ 4 ]           STA  V47            ; AND SAVE IT IN V74
5028 e169 27 03              [ 3 ]           BEQ  L902C          ; BRANCH IF FPA0 = 0
5029 e16b bd e3 0f           [ 8 ]           JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
5030                               *              ; PLACES TO LEFT OF DECIMAL POINT
5031 e16e 96 47              [ 4 ] L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
5032 e170 10 2b 00 81        [ 6 ]           LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
5033 e174 40                 [ 2 ]           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
5034 e175 9b 99              [ 4 ]           ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
5035 e177 80 09              [ 2 ]           SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
5036 e179 bd e2 2c           [ 8 ]           JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
5037 e17c bd e3 a5           [ 8 ]           JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5038 e17f bd e3 44           [ 8 ]           JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
5039 e182 96 47              [ 4 ]           LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
5040 e184 bd e3 c3           [ 8 ]           JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
5041 e187 96 47              [ 4 ]           LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
5042 e189 bd e3 8b           [ 8 ]           JSR  L9249          ; CHECK FOR DECIMAL POINT
5043 e18c 96 98              [ 4 ]           LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5044 e18e 26 02              [ 3 ]           BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
5045 e190 33 5f              [ 5 ]           LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
5046                               *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
5047 e192 4a                 [ 2 ] L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
5048 e193 bd e2 2c           [ 8 ]           JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
5049 e196 bd e2 c7           [ 8 ] L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
5050 e199 4d                 [ 2 ]           TSTA                ; WAS THERE A POST-SIGN?
5051 e19a 27 06              [ 3 ]           BEQ  L9060          ; NO
5052 e19c c1 2a              [ 2 ]           CMPB #'*            ; IS THE FIRST CHARACTER AN $?
5053 e19e 27 02              [ 3 ]           BEQ  L9060          ; YES
5054 e1a0 e7 c0              [ 6 ]           STB  ,U+            ; STORE THE POST-SIGN
5055 e1a2 6f c4              [ 6 ] L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
5056                               *
5057                               * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
5058                               * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
5059 e1a4 8e 01 f1           [ 3 ]           LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
5060 e1a7 30 01              [ 5 ] L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
5061 e1a9 9f 0f              [ 5 ]           STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
5062 e1ab 96 3a              [ 4 ]           LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
5063 e1ad 90 10              [ 4 ]           SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
5064 e1af 90 99              [ 4 ]           SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
5065                               *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
5066 e1b1 27 38              [ 3 ]           BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
5067 e1b3 a6 84              [ 4 ]           LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
5068 e1b5 81 20              [ 2 ]           CMPA #SPACE         ; SPACE?
5069 e1b7 27 ee              [ 3 ]           BEQ  L9065          ; YES - ADVANCE POINTER
5070 e1b9 81 2a              [ 2 ]           CMPA #'*            ; ASTERISK?
5071 e1bb 27 ea              [ 3 ]           BEQ  L9065          ; YES - ADVANCE POINTER
5072 e1bd 4f                 [ 2 ]           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
5073 e1be 34 02              [ 6 ] L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
5074 e1c0 a6 80              [ 6 ]           LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
5075 e1c2 81 2d              [ 2 ]           CMPA #'-            ; MINUS SIGN?
5076 e1c4 27 f8              [ 3 ]           BEQ  L907C          ; YES
5077 e1c6 81 2b              [ 2 ]           CMPA #'+            ; PLUS SIGN?
5078 e1c8 27 f4              [ 3 ]           BEQ  L907C          ; YES
5079 e1ca 81 24              [ 2 ]           CMPA #'$            ; DOLLAR SIGN?
5080 e1cc 27 f0              [ 3 ]           BEQ  L907C          ; YES
5081 e1ce 81 30              [ 2 ]           CMPA #'0            ; ZERO?
5082 e1d0 26 0e              [ 3 ]           BNE  L909E          ; NO - ERROR
5083 e1d2 a6 01              [ 5 ]           LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
5084 e1d4 8d 16              [ 7 ]           BSR  L90AA          ; CLEAR CARRY IF NUMERIC
5085 e1d6 25 08              [ 3 ]           BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
5086 e1d8 35 02              [ 6 ] L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
5087 e1da a7 82              [ 6 ]           STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
5088 e1dc 26 fa              [ 3 ]           BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
5089 e1de 20 c7              [ 3 ]           BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
5090 e1e0 35 02              [ 6 ] L909E     PULS A              ;
5091 e1e2 4d                 [ 2 ]           TSTA                ; * THE STACK AND EXIT WHEN
5092 e1e3 26 fb              [ 3 ]           BNE  L909E          ; * ZERO FLAG FOUND
5093 e1e5 9e 0f              [ 5 ]           LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
5094 e1e7 86 25              [ 2 ]           LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
5095 e1e9 a7 82              [ 6 ]           STA  ,-X            ; * INDICATE AN ERROR
5096 e1eb 39                 [ 5 ] L90A9     RTS
5097                               *
5098                               * CLEAR CARRY IF NUMERIC
5099 e1ec 81 30              [ 2 ] L90AA     CMPA #'0            ; ASCII ZERO
5100 e1ee 25 04              [ 3 ]           BLO  L90B2          ; RETURN IF ACCA < ASCII 0
5101 e1f0 80 3a              [ 2 ]           SUBA #$3A           ; *  #'9'+1
5102 e1f2 80 c6              [ 2 ]           SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
5103 e1f4 39                 [ 5 ] L90B2     RTS
5104                               *
5105                               * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
5106 e1f5 96 98              [ 4 ] L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
5107 e1f7 27 01              [ 3 ]           BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
5108 e1f9 4a                 [ 2 ]           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
5109 e1fa 9b 47              [ 4 ] L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
5110                               *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
5111                               *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
5112 e1fc 2b 01              [ 3 ]           BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
5113 e1fe 4f                 [ 2 ]           CLRA                ; FORCE SHIFT COUNTER = 0
5114 e1ff 34 02              [ 6 ] L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
5115 e201 2a 0a              [ 3 ] L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
5116 e203 34 02              [ 6 ]           PSHS A              ; SAVE SHIFT COUNTER ON STACK
5117 e205 bd d2 ce           [ 8 ]           JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
5118 e208 35 02              [ 6 ]           PULS A              ; GET SHIFT COUNTER FROM THE STACK
5119 e20a 4c                 [ 2 ]           INCA                ; BUMP SHIFT COUNTER UP BY ONE
5120 e20b 20 f4              [ 3 ]           BRA  L90BF          ; CHECK FOR FURTHER DIVISION
5121 e20d 96 47              [ 4 ] L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
5122 e20f a0 e0              [ 6 ]           SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
5123 e211 97 47              [ 4 ]           STA  V47            ; * FPA0 WAS SHIFTED ABOVE
5124 e213 8b 09              [ 2 ]           ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
5125 e215 2b 19              [ 3 ]           BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
5126 e217 96 99              [ 4 ]           LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
5127 e219 80 09              [ 2 ]           SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
5128 e21b 90 47              [ 4 ]           SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
5129 e21d 8d 0d              [ 7 ]           BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
5130 e21f bd e3 a5           [ 8 ]           JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5131 e222 20 1d              [ 3 ]           BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
5132                               *
5133                               * PUT (ACCA+1) ASCII ZEROES IN BUFFER
5134 e224 34 02              [ 6 ] L90E2     PSHS A              ; SAVE ZERO COUNTER
5135 e226 86 30              [ 2 ]           LDA  #'0            ; * INSERT A ZERO INTO
5136 e228 a7 c0              [ 6 ]           STA  ,U+            ; * THE BUFFER
5137 e22a 35 02              [ 6 ]           PULS A              ; RESTORE ZERO COUNTER
5138                               
5139                               * PUT ACCA ASCII ZEROES INTO THE BUFFER
5140 e22c 4a                 [ 2 ] L90EA     DECA                ; DECREMENT ZERO COUNTER
5141 e22d 2a f5              [ 3 ]           BPL  L90E2          ; BRANCH IF NOT DONE
5142 e22f 39                 [ 5 ]           RTS
5143                               
5144 e230 96 99              [ 4 ] L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
5145 e232 8d f8              [ 7 ]           BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
5146 e234 bd e3 8f           [ 8 ]           JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
5147 e237 86 f7              [ 2 ]           LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
5148 e239 90 47              [ 4 ]           SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
5149 e23b 8d ef              [ 7 ]           BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
5150 e23d 0f 45              [ 6 ]           CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
5151 e23f 0f 97              [ 6 ]           CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
5152 e241 bd e3 44           [ 8 ] L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
5153 e244 96 98              [ 4 ]           LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5154 e246 26 02              [ 3 ]           BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
5155 e248 de 39              [ 5 ]           LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
5156 e24a 9b 47              [ 4 ] L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
5157                               * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
5158                               *         *SIGNIFICANT DATA
5159 e24c 16 ff 43           [ 5 ]           LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
5160                               *
5161                               * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
5162 e24f 96 4f              [ 4 ] L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5163 e251 34 02              [ 6 ]           PSHS A              ; * SAVE IT ON THE STACK
5164 e253 27 03              [ 3 ]           BEQ  L9116          ; BRANCH IF FPA0 = 0
5165 e255 bd e3 0f           [ 8 ]           JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
5166                               *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
5167 e258 96 98              [ 4 ] L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5168 e25a 27 01              [ 3 ]           BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
5169 e25c 4a                 [ 2 ]           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
5170 e25d 9b 99              [ 4 ] L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
5171 e25f 7f 01 f1           [ 7 ]           CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
5172 e262 d6 9a              [ 4 ]           LDB  VDA            ; * GET THE STATUS BYTE FOR A
5173 e264 c4 04              [ 2 ]           ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
5174 e266 26 03              [ 3 ]           BNE  L9129          ; * A POST-BYTE FORCE
5175 e268 73 01 f1           [ 7 ]           COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
5176 e26b bb 01 f1           [ 5 ] L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
5177 e26e 80 09              [ 2 ]           SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
5178                               *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
5179 e270 34 02              [ 6 ]           PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
5180                               *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
5181                               *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
5182 e272 2a 0a              [ 3 ] L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
5183 e274 34 02              [ 6 ]           PSHS A              ; SAVE SHIFT COUNTER
5184 e276 bd d2 ce           [ 8 ]           JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
5185 e279 35 02              [ 6 ]           PULS A              ; RESTORE THE SHIFT COUNTER
5186 e27b 4c                 [ 2 ]           INCA                ; ADD 1 TO SHIFT COUNTER
5187 e27c 20 f4              [ 3 ]           BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
5188 e27e a6 e4              [ 4 ] L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
5189 e280 2b 01              [ 3 ]           BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
5190 e282 4f                 [ 2 ]           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
5191 e283 40                 [ 2 ] L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
5192 e284 9b 99              [ 4 ]           ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
5193 e286 4c                 [ 2 ]           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
5194 e287 bb 01 f1           [ 5 ]           ADDA STRBUF+3       ; *
5195 e28a 97 45              [ 4 ]           STA  V45            ; SAVE DECIMAL POINT COUNTER
5196 e28c 0f 97              [ 6 ]           CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
5197 e28e bd e3 44           [ 8 ]           JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
5198 e291 35 02              [ 6 ]           PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
5199 e293 bd e3 c3           [ 8 ]           JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
5200 e296 96 98              [ 4 ]           LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
5201 e298 26 02              [ 3 ]           BNE  L915A          ; *IF NOT ZERO
5202 e29a 33 5f              [ 5 ]           LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
5203                               
5204                               * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
5205 e29c e6 e0              [ 6 ] L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
5206 e29e 27 09              [ 3 ]           BEQ  L9167          ; BRANCH IF EXPONENT = 0
5207 e2a0 d6 47              [ 4 ]           LDB  V47            ; GET BASE 10 EXPONENT
5208 e2a2 cb 09              [ 2 ]           ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
5209 e2a4 d0 99              [ 4 ]           SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
5210 e2a6 f0 01 f1           [ 5 ]           SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
5211 e2a9 86 2b              [ 2 ] L9167     LDA  #'+            ; PLUS SIGN
5212 e2ab 5d                 [ 2 ]           TSTB                ; TEST EXPONENT
5213 e2ac 2a 03              [ 3 ]           BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
5214 e2ae 86 2d              [ 2 ]           LDA  #'-            ; MINUS SIGN
5215 e2b0 50                 [ 2 ]           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
5216 e2b1 a7 41              [ 5 ] L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
5217 e2b3 86 45              [ 2 ]           LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
5218 e2b5 a7 c1              [ 7 ]           STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
5219 e2b7 86 2f              [ 2 ]           LDA  #$2F           ; * WAS LDA #'0'-1
5220                               *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
5221 e2b9 4c                 [ 2 ] L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
5222 e2ba c0 0a              [ 2 ]           SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
5223 e2bc 24 fb              [ 3 ]           BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
5224 e2be cb 3a              [ 2 ]           ADDB #$3A           ; WAS ADDB #'9'+1
5225 e2c0 ed c1              [ 8 ]           STD  ,U++           ; SAVE EXPONENT IN BUFFER
5226 e2c2 6f c4              [ 6 ]           CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
5227 e2c4 7e e1 96           [ 4 ]           JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
5228                               
5229                               * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
5230 e2c7 8e 01 f2           [ 3 ] L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
5231 e2ca e6 84              [ 4 ]           LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
5232 e2cc 34 04              [ 6 ]           PSHS B              ; * AND SAVE IT ON THE STACK
5233 e2ce 86 20              [ 2 ]           LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
5234 e2d0 d6 9a              [ 4 ]           LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
5235 e2d2 c5 20              [ 2 ]           BITB #$20           ; * ASTERISK LEFT PADDING
5236 e2d4 35 04              [ 6 ]           PULS B              ; GET SIGN BYTE AGAIN
5237 e2d6 27 08              [ 3 ]           BEQ  L919E          ; BRANCH IF NO PADDING
5238 e2d8 86 2a              [ 2 ]           LDA  #'*            ; PAD WITH ASTERISK
5239 e2da c1 20              [ 2 ]           CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
5240 e2dc 26 02              [ 3 ]           BNE  L919E          ; NO
5241 e2de 1f 89              [ 6 ]           TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
5242 e2e0 34 04              [ 6 ] L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
5243 e2e2 a7 80              [ 6 ] L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
5244 e2e4 e6 84              [ 4 ]           LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
5245 e2e6 27 10              [ 3 ]           BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
5246 e2e8 c1 45              [ 2 ]           CMPB #'E            ; * CHECK FOR AN 'E' AND
5247 e2ea 27 0c              [ 3 ]           BEQ  L91B6          ; * PUT A ZERO BEFORE IT
5248 e2ec c1 30              [ 2 ]           CMPB #'0            ; * REPLACE LEADING ZEROES WITH
5249 e2ee 27 f2              [ 3 ]           BEQ  L91A0          ; * PAD CHARACTERS
5250 e2f0 c1 2c              [ 2 ]           CMPB #',            ; * REPLACE LEADING COMMAS
5251 e2f2 27 ee              [ 3 ]           BEQ  L91A0          ; * WITH PAD CHARACTERS
5252 e2f4 c1 2e              [ 2 ]           CMPB #'.            ; * CHECK FOR DECIMAL POINT
5253 e2f6 26 04              [ 3 ]           BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
5254 e2f8 86 30              [ 2 ] L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
5255 e2fa a7 82              [ 6 ]           STA  ,-X            ; * WITH A ZERO
5256 e2fc 96 9a              [ 4 ] L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
5257 e2fe 85 10              [ 2 ]           BITA #$10           ; * FOR FLOATING $
5258 e300 27 04              [ 3 ]           BEQ  L91C4          ; * BRANCH IF NO FLOATING $
5259 e302 c6 24              [ 2 ]           LDB  #'$            ; * STORE A $ IN
5260 e304 e7 82              [ 6 ]           STB  ,-X            ; * BUFFER
5261 e306 84 04              [ 2 ] L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
5262 e308 35 04              [ 6 ]           PULS B              ; GET SIGN CHARACTER
5263 e30a 26 02              [ 3 ]           BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
5264 e30c e7 82              [ 6 ]           STB  ,-X            ; STORE FIRST CHARACTER
5265 e30e 39                 [ 5 ] L91CC     RTS
5266                               *
5267                               * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
5268                               * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
5269 e30f 34 40              [ 7 ] L91CD     PSHS U              ; SAVE BUFFER POINTER
5270 e311 4f                 [ 2 ]           CLRA                ; INITIAL EXPONENT OFFSET = 0
5271 e312 97 47              [ 4 ] L91D0     STA  V47            ; SAVE EXPONENT OFFSET
5272 e314 d6 4f              [ 4 ]           LDB  FP0EXP         ; GET EXPONENT OF FPA0
5273 e316 c1 80              [ 2 ]           CMPB #$80           ; * COMPARE TO EXPONENT OF .5
5274 e318 22 11              [ 3 ]           BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
5275                               
5276                               * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
5277 e31a 8e d5 0c           [ 3 ]           LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
5278 e31d bd d2 16           [ 8 ]           JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
5279 e320 96 47              [ 4 ]           LDA  V47            ; GET EXPONENT OFFSET
5280 e322 80 09              [ 2 ]           SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
5281 e324 20 ec              [ 3 ]           BRA  L91D0          ; CHECK TO SEE IF > 1.0
5282 e326 bd d2 ce           [ 8 ] L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
5283 e329 0c 47              [ 6 ]           INC  V47            ; INCREMENT EXPONENT OFFSET
5284 e32b 8e d5 07           [ 3 ] L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
5285 e32e bd d3 ec           [ 8 ]           JSR  LBCA0          ; COMPARE FPA0 TO X
5286 e331 2e f3              [ 3 ]           BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
5287 e333 8e d5 02           [ 3 ] L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
5288 e336 bd d3 ec           [ 8 ]           JSR  LBCA0          ; COMPARE FPA0 TO X
5289 e339 2e 07              [ 3 ]           BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
5290 e33b bd d2 b6           [ 8 ]           JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5291 e33e 0a 47              [ 6 ]           DEC  V47            ; DECREMENT EXPONENT OFFSET
5292 e340 20 f1              [ 3 ]           BRA  L91F1          ; KEEP UNNORMALIZING
5293 e342 35 c0              [ 9 ] L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
5294                               *
5295                               * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
5296                               * INTO A DECIMAL ASCII STRING IN THE BUFFER
5297 e344 34 40              [ 7 ] L9202     PSHS U              ; SAVE BUFFER POINTER
5298 e346 bd d1 00           [ 8 ]           JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5299 e349 bd d4 14           [ 8 ]           JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
5300 e34c 35 40              [ 7 ]           PULS U              ; RESTORE BUFFER POINTER
5301                               *
5302                               * CONVERT FPA0 INTO A DECIMAL ASCII STRING
5303 e34e 8e d6 11           [ 3 ]           LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
5304 e351 c6 80              [ 2 ]           LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
5305                               * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5306                               * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5307                               * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
5308                               * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
5309 e353 8d 36              [ 7 ] L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
5310 e355 96 53              [ 4 ] L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
5311 e357 ab 03              [ 5 ]           ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
5312 e359 97 53              [ 4 ]           STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
5313 e35b 96 52              [ 4 ]           LDA  FPA0+2         ; *
5314 e35d a9 02              [ 5 ]           ADCA $02,X          ; *
5315 e35f 97 52              [ 4 ]           STA  FPA0+2         ; *
5316 e361 96 51              [ 4 ]           LDA  FPA0+1         ; *
5317 e363 a9 01              [ 5 ]           ADCA $01,X          ; *
5318 e365 97 51              [ 4 ]           STA  FPA0+1         ; *
5319 e367 96 50              [ 4 ]           LDA  FPA0           ; *
5320 e369 a9 84              [ 4 ]           ADCA ,X             ; *
5321 e36b 97 50              [ 4 ]           STA  FPA0           ; *
5322 e36d 5c                 [ 2 ]           INCB                ; ADD ONE TO DIGIT COUNTER
5323 e36e 56                 [ 2 ]           RORB                ; ROTATE CARRY INTO BIT 7
5324 e36f 59                 [ 2 ]           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
5325 e370 28 e3              [ 3 ]           BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
5326 e372 24 03              [ 3 ]           BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
5327 e374 c0 0b              [ 2 ]           SUBB #10+1          ; WAS SUBB #10+1
5328 e376 50                 [ 2 ]           NEGB                ; * IF ADDING MANTISSA
5329 e377 cb 2f              [ 2 ] L9235     ADDB #$2F           ; WAS ADDB #'0'-1
5330 e379 30 04              [ 5 ]           LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
5331 e37b 1f 98              [ 6 ]           TFR  B,A            ; SAVE DIGIT IN ACCA
5332 e37d 84 7f              [ 2 ]           ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
5333 e37f a7 c0              [ 6 ]           STA  ,U+            ; STORE DIGIT IN BUFFER
5334 e381 53                 [ 2 ]           COMB                ; TOGGLE ADD/SUBTRACT FLAG
5335 e382 c4 80              [ 2 ]           ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
5336 e384 8c d6 35           [ 4 ]           CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
5337 e387 26 ca              [ 3 ]           BNE  L9211          ; BRANCH IF NOT DONE
5338 e389 6f c4              [ 6 ]           CLR  ,U             ; PUT A ZERO AT END OF INTEGER
5339                               
5340                               * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
5341 e38b 0a 45              [ 6 ] L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
5342 e38d 26 09              [ 3 ]           BNE  L9256          ; NOT TIME FOR DECIMAL POINT
5343 e38f df 39              [ 5 ] L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
5344 e391 86 2e              [ 2 ]           LDA  #'.            ; * STORE A DECIMAL
5345 e393 a7 c0              [ 6 ]           STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
5346 e395 0f 97              [ 6 ]           CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
5347                               *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
5348 e397 39                 [ 5 ]           RTS
5349 e398 0a 97              [ 6 ] L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
5350 e39a 26 08              [ 3 ]           BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
5351 e39c 86 03              [ 2 ]           LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
5352 e39e 97 97              [ 4 ]           STA  VD7            ; * DIGITS BETWEEN COMMAS
5353 e3a0 86 2c              [ 2 ]           LDA  #',            ; * PUT A COMMA INTO
5354 e3a2 a7 c0              [ 6 ]           STA  ,U+            ; * THE BUFFER
5355 e3a4 39                 [ 5 ] L9262     RTS
5356                               
5357                               * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5358 e3a5 96 47              [ 4 ] L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
5359 e3a7 8b 0a              [ 2 ]           ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
5360 e3a9 97 45              [ 4 ]           STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
5361 e3ab 4c                 [ 2 ]           INCA                ; ADD ONE FOR THE DECIMAL POINT
5362 e3ac 80 03              [ 2 ] L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
5363 e3ae 24 fc              [ 3 ]           BCC  L926A          ; * THE REMAINDER IN ACCA
5364 e3b0 8b 05              [ 2 ]           ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
5365 e3b2 97 97              [ 4 ]           STA  VD7            ; SAVE COMMA COUNTER
5366 e3b4 96 9a              [ 4 ]           LDA  VDA            ; GET STATUS BYTE
5367 e3b6 84 40              [ 2 ]           ANDA #$40           ; CHECK FOR COMMA FLAG
5368 e3b8 26 02              [ 3 ]           BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
5369 e3ba 97 97              [ 4 ]           STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
5370 e3bc 39                 [ 5 ] L927A     RTS
5371                               *
5372                               * INSERT ACCA ZEROES INTO THE BUFFER
5373 e3bd 34 02              [ 6 ] L927B     PSHS A              ; SAVE ZEROES COUNTER
5374 e3bf 8d ca              [ 7 ]           BSR  L9249          ; CHECK FOR DECIMAL POINT
5375 e3c1 35 02              [ 6 ]           PULS A              ; RESTORE ZEROES COUNTER
5376 e3c3 4a                 [ 2 ] L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
5377 e3c4 2b 0a              [ 3 ]           BMI  L928E          ; * RETURN IF < 0
5378 e3c6 34 02              [ 6 ]           PSHS A              ; SAVE ZEROES COUNTER
5379 e3c8 86 30              [ 2 ]           LDA  #'0            ; * PUT A ZERO INTO
5380 e3ca a7 c0              [ 6 ]           STA  ,U+            ; * THE BUFFER
5381 e3cc a6 e0              [ 6 ]           LDA  ,S+            ; RESTORE THE ZEROES COUNTER
5382 e3ce 26 ed              [ 3 ]           BNE  L927B          ; BRANCH IF NOT DONE
5383 e3d0 39                 [ 5 ] L928E     RTS
5384                               
5385                               
5386                               * LINE
5387 e3d1 81 89              [ 2 ] LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
5388 e3d3 10 27 f9 5c        [ 6 ]           LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
5389 e3d7 7e ca 03           [ 4 ]           JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
5390                               
5391                               * END OF EXTENDED BASIC
5392                               
5393                               ;************************************************************************
5394                               ;
5395                               ; 6809 Disassembler
5396                               ;
5397                               ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
5398                               ;
5399                               ; Licensed under the Apache License, Version 2.0 (the "License");
5400                               ; you may not use this file except in compliance with the License.
5401                               ; You may obtain a copy of the License at
5402                               ;
5403                               ;   http://www.apache.org/licenses/LICENSE-2.0
5404                               ;
5405                               ; Unless required by applicable law or agreed to in writing, software
5406                               ; distributed under the License is distributed on an "AS IS" BASIS,
5407                               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
5408                               ; See the License for the specific language governing permissions and
5409                               ; limitations under the License.
5410                               ;
5411                               ; Revision History
5412                               ; Version Date         Comments
5413                               ; 0.0     29-Jan-2019  First version started, based on 6502 code.
5414                               ; 0.1     03-Feb-2019  All instructions now supported.
5415                               ; 0.2     05-Feb-2019  Integrated into ASSSIST09/BASIC ROM.
5416                               
5417                               ; Character defines
5418                               
5419 000d                          RET     EQU     $0D             ; Carriage return
5420 0020                          SP      EQU     $20             ; Space
5421                               
5422 0018                          PAGELEN EQU     24              ; Number of instructions to show before waiting for keypress
5423                               
5424                               ; Start address for RAM variables
5425 7e2a                                  ORG     $7E2A
5426                               
5427                               ; Variables
5428                               
5429 7e2a                          ADRS    RMB     2               ; Current address to disassemble
5430 7e2c                          OPCODE  RMB     1               ; Opcode of instruction
5431 7e2d                          AM      RMB     1               ; Addressing mode of instruction
5432 7e2e                          OPTYPE  RMB     1               ; Instruction type
5433 7e2f                          POSTBYT RMB     1               ; Post byte (for indexed addressing)
5434 7e30                          LENG    RMB     1               ; Length of instruction
5435 7e31                          TEMP    RMB     2               ; Temp variable (used by print routines)
5436 7e33                          TEMP1   RMB     2               ; Temp variable
5437 7e35                          FIRST   RMB     1               ; Flag used to indicate first time an item printed
5438 7e36                          PAGE23  RMB     1               ; Flag indicating page2/3 instruction when non-zero
5439                               
5440                               ; Instructions. Matches indexes into entries in table MNEMONICS.
5441                               
5442 0000                          OP_INV   EQU    $00
5443 0001                          OP_ABX   EQU    $01
5444 0002                          OP_ADCA  EQU    $02
5445 0003                          OP_ADCB  EQU    $03
5446 0004                          OP_ADDA  EQU    $04
5447 0005                          OP_ADDB  EQU    $05
5448 0006                          OP_ADDD  EQU    $06
5449 0007                          OP_ANDA  EQU    $07
5450 0008                          OP_ANDB  EQU    $08
5451 0009                          OP_ANDCC EQU    $09
5452 000a                          OP_ASL   EQU    $0A
5453 000b                          OP_ASLA  EQU    $0B
5454 000c                          OP_ASLB  EQU    $0C
5455 000d                          OP_ASR   EQU    $0D
5456 000e                          OP_ASRA  EQU    $0E
5457 000f                          OP_ASRB  EQU    $0F
5458 0010                          OP_BCC   EQU    $10
5459 0011                          OP_BCS   EQU    $11
5460 0012                          OP_BEQ   EQU    $12
5461 0013                          OP_BGE   EQU    $13
5462 0014                          OP_BGT   EQU    $14
5463 0015                          OP_BHI   EQU    $15
5464 0016                          OP_BITA  EQU    $16
5465 0017                          OP_BITB  EQU    $17
5466 0018                          OP_BLE   EQU    $18
5467 0019                          OP_BLS   EQU    $19
5468 001a                          OP_BLT   EQU    $1A
5469 001b                          OP_BMI   EQU    $1B
5470 001c                          OP_BNE   EQU    $1C
5471 001d                          OP_BPL   EQU    $1D
5472 001e                          OP_BRA   EQU    $1E
5473 001f                          OP_BRN   EQU    $1F
5474 0020                          OP_BSR   EQU    $20
5475 0021                          OP_BVC   EQU    $21
5476 0022                          OP_BVS   EQU    $22
5477 0023                          OP_CLR   EQU    $23
5478 0024                          OP_CLRA  EQU    $24
5479 0025                          OP_CLRB  EQU    $25
5480 0026                          OP_CMPA  EQU    $26
5481 0027                          OP_CMPB  EQU    $27
5482 0028                          OP_CMPD  EQU    $28
5483 0029                          OP_CMPS  EQU    $29
5484 002a                          OP_CMPU  EQU    $2A
5485 002b                          OP_CMPX  EQU    $2B
5486 002c                          OP_CMPY  EQU    $2C
5487 002d                          OP_COMA  EQU    $2D
5488 002e                          OP_COMB  EQU    $2E
5489 002f                          OP_COM   EQU    $2F
5490 0030                          OP_CWAI  EQU    $30
5491 0031                          OP_DAA   EQU    $31
5492 0032                          OP_DEC   EQU    $32
5493 0033                          OP_DECA  EQU    $33
5494 0034                          OP_DECB  EQU    $34
5495 0035                          OP_EORA  EQU    $35
5496 0036                          OP_EORB  EQU    $36
5497 0037                          OP_EXG   EQU    $37
5498 0038                          OP_INC   EQU    $38
5499 0039                          OP_INCA  EQU    $39
5500 003a                          OP_INCB  EQU    $3A
5501 003b                          OP_JMP   EQU    $3B
5502 003c                          OP_JSR   EQU    $3C
5503 003d                          OP_LBCC  EQU    $3D
5504 003e                          OP_LBCS  EQU    $3E
5505 003f                          OP_LBEQ  EQU    $3F
5506 0040                          OP_LBGE  EQU    $40
5507 0041                          OP_LBGT  EQU    $41
5508 0042                          OP_LBHI  EQU    $42
5509 0043                          OP_LBLE  EQU    $43
5510 0044                          OP_LBLS  EQU    $44
5511 0045                          OP_LBLT  EQU    $45
5512 0046                          OP_LBMI  EQU    $46
5513 0047                          OP_LBNE  EQU    $47
5514 0048                          OP_LBPL  EQU    $48
5515 0049                          OP_LBRA  EQU    $49
5516 004a                          OP_LBRN  EQU    $4A
5517 004b                          OP_LBSR  EQU    $4B
5518 004c                          OP_LBVC  EQU    $4C
5519 004d                          OP_LBVS  EQU    $4D
5520 004e                          OP_LDA   EQU    $4E
5521 004f                          OP_LDB   EQU    $4F
5522 0050                          OP_LDD   EQU    $50
5523 0051                          OP_LDS   EQU    $51
5524 0052                          OP_LDU   EQU    $52
5525 0053                          OP_LDX   EQU    $53
5526 0054                          OP_LDY   EQU    $54
5527 0055                          OP_LEAS  EQU    $55
5528 0056                          OP_LEAU  EQU    $56
5529 0057                          OP_LEAX  EQU    $57
5530 0058                          OP_LEAY  EQU    $58
5531 0059                          OP_LSR   EQU    $59
5532 005a                          OP_LSRA  EQU    $5A
5533 005b                          OP_LSRB  EQU    $5B
5534 005c                          OP_MUL   EQU    $5C
5535 005d                          OP_NEG   EQU    $5D
5536 005e                          OP_NEGA  EQU    $5E
5537 005f                          OP_NEGB  EQU    $5F
5538 0060                          OP_NOP   EQU    $60
5539 0061                          OP_ORA   EQU    $61
5540 0062                          OP_ORB   EQU    $62
5541 0063                          OP_ORCC  EQU    $63
5542 0064                          OP_PSHS  EQU    $64
5543 0065                          OP_PSHU  EQU    $65
5544 0066                          OP_PULS  EQU    $66
5545 0067                          OP_PULU  EQU    $67
5546 0068                          OP_ROL   EQU    $68
5547 0069                          OP_ROLA  EQU    $69
5548 006a                          OP_ROLB  EQU    $6A
5549 006b                          OP_ROR   EQU    $6B
5550 006c                          OP_RORA  EQU    $6C
5551 006d                          OP_RORB  EQU    $6D
5552 006e                          OP_RTI   EQU    $6E
5553 006f                          OP_RTS   EQU    $6F
5554 0070                          OP_SBCA  EQU    $70
5555 0071                          OP_SBCB  EQU    $71
5556 0072                          OP_SEX   EQU    $72
5557 0073                          OP_STA   EQU    $73
5558 0074                          OP_STB   EQU    $74
5559 0075                          OP_STD   EQU    $75
5560 0076                          OP_STS   EQU    $76
5561 0077                          OP_STU   EQU    $77
5562 0078                          OP_STX   EQU    $78
5563 0079                          OP_STY   EQU    $79
5564 007a                          OP_SUBA  EQU    $7A
5565 007b                          OP_SUBB  EQU    $7B
5566 007c                          OP_SUBD  EQU    $7C
5567 007d                          OP_SWI   EQU    $7D
5568 007e                          OP_SWI2  EQU    $7E
5569 007f                          OP_SWI3  EQU    $7F
5570 0080                          OP_SYNC  EQU    $80
5571 0081                          OP_TFR   EQU    $81
5572 0082                          OP_TST   EQU    $82
5573 0083                          OP_TSTA  EQU    $83
5574 0084                          OP_TSTB  EQU    $84
5575                               
5576                               ; Addressing Modes. OPCODES table lists these for each instruction.
5577                               ; LENGTHS lists the instruction length for each addressing mode.
5578                               ; Need to distinguish relative modes that are 2 and 3 (long) bytes.
5579                               ; Some immediate are 2 and some 3 bytes.
5580                               ; Indexed modes can be longer depending on postbyte.
5581                               ; Page 2 and 3 opcodes are one byte longer (prefixed by 10 or 11)
5582                               
5583 0000                          AM_INVALID      EQU     0       ; $01 (1)
5584 0001                          AM_INHERENT     EQU     1       ; RTS (1)
5585 0002                          AM_IMMEDIATE8   EQU     2       ; LDA #$12 (2)
5586 0003                          AM_IMMEDIATE16  EQU     3       ; LDD #$1234 (3)
5587 0004                          AM_DIRECT       EQU     4       ; LDA $12 (2)
5588 0005                          AM_EXTENDED     EQU     5       ; LDA $1234 (3)
5589 0006                          AM_RELATIVE8    EQU     6       ; BSR $1234 (2)
5590 0007                          AM_RELATIVE16   EQU     7       ; LBSR $1234 (3)
5591 0008                          AM_INDEXED      EQU     8       ; LDA 0,X (2+)
5592                               
5593                               ; *** CODE ***
5594                               
5595 e400                                  ORG     $E400
5596                               
5597                               ; Unassemble command. Disassembles a page at a time. Can be run directly or
5598                               ; as an ASSIST09 monitor external command. Gets start address from
5599                               ; command line.
5600                               
5601 e400 17 1a 5d           [ 9 ] CUNAS:  LBSR    CDNUM           ; Parse command line, return 16-bit number in D
5602 e403 fd 7e 2a           [ 6 ]         STD     ADRS            ; Store it
5603 e406 86 18              [ 2 ] PAGE:   LDA     #PAGELEN        ; Number of instructions to disassemble per page
5604 e408 34 02              [ 6 ] DIS:    PSHS    A               ; Save A
5605 e40a 17 01 97           [ 9 ]         LBSR    DISASM          ; Do disassembly of one instruction
5606 e40d 35 02              [ 6 ]         PULS    A               ; Restore A
5607 e40f 4a                 [ 2 ]         DECA                    ; Decrement count
5608 e410 26 f6              [ 3 ]         BNE     DIS             ; Go back and repeat until a page has been done
5609 e412 30 8d 0b 8f        [ 9 ]         LEAX    MSG2,PCR        ; Display message to press a key
5610 e416 17 00 84           [ 9 ]         LBSR    PrintString
5611 e419 8d 63              [ 7 ] BADKEY: BSR     GetChar         ; Wait for keyboard input
5612 e41b 8d 11              [ 7 ]         BSR     PrintCR
5613 e41d 81 20              [ 2 ]         CMPA    #SP             ; Space key pressed?
5614 e41f 27 e5              [ 3 ]         BEQ     PAGE            ; If so, display next page
5615 e421 81 51              [ 2 ]         CMPA    #'Q             ; Q key pressed?
5616 e423 27 08              [ 3 ]         BEQ     RETN            ; If so, return
5617 e425 81 71              [ 2 ]         CMPA    #'q             ; q key pressed?
5618 e427 27 04              [ 3 ]         BEQ     RETN            ; If so, return
5619 e429 8d 72              [ 7 ]         BSR     PrintString     ; Bad key, prompt and try again
5620 e42b 20 ec              [ 3 ]         BRA     BADKEY
5621 e42d 39                 [ 5 ] RETN:   RTS                     ; Return to caller
5622                               
5623                               ; *** Utility Functions ***
5624                               ; Some of these call ASSIST09 ROM monitor routines.
5625                               
5626                               ; Print CR/LF to the console.
5627                               ; Registers changed: none
5628                               PrintCR:
5629 e42e 34 02              [ 6 ]         PSHS    A               ; Save A
5630 e430 86 0d              [ 2 ]         LDA     #RET
5631 e432 8d 47              [ 7 ]         BSR     PrintChar
5632 e434 86 0a              [ 2 ]         LDA     #LF
5633 e436 8d 43              [ 7 ]         BSR     PrintChar
5634 e438 35 02              [ 6 ]         PULS    A               ; Restore A
5635 e43a 39                 [ 5 ]         RTS
5636                               
5637                               ; Print dollar sign to the console.
5638                               ; Registers changed: none
5639                               PrintDollar:
5640 e43b 34 02              [ 6 ]         PSHS    A               ; Save A
5641 e43d 86 24              [ 2 ]         LDA     #'$
5642 e43f 8d 3a              [ 7 ]         BSR     PrintChar
5643 e441 35 02              [ 6 ]         PULS    A               ; Restore A
5644 e443 39                 [ 5 ]         RTS
5645                               
5646                               ; Print comma to the console.
5647                               ; Registers changed: none
5648                               PrintComma:
5649 e444 34 02              [ 6 ]         PSHS    A               ; Save A
5650 e446 86 2c              [ 2 ]         LDA     #',
5651 e448 8d 31              [ 7 ]         BSR     PrintChar
5652 e44a 35 02              [ 6 ]         PULS    A               ; Restore A
5653 e44c 39                 [ 5 ]         RTS
5654                               
5655                               ; Print left square bracket to the console.
5656                               ; Registers changed: none
5657                               PrintLBracket:
5658 e44d 34 02              [ 6 ]         PSHS    A               ; Save A
5659 e44f 86 5b              [ 2 ]         LDA     #'[
5660 e451 8d 28              [ 7 ]         BSR     PrintChar
5661 e453 35 02              [ 6 ]         PULS    A               ; Restore A
5662 e455 39                 [ 5 ]         RTS
5663                               
5664                               ; Print right square bracket to the console.
5665                               ; Registers changed: none
5666                               PrintRBracket:
5667 e456 34 02              [ 6 ]         PSHS    A               ; Save A
5668 e458 86 5d              [ 2 ]         LDA     #']
5669 e45a 8d 1f              [ 7 ]         BSR     PrintChar
5670 e45c 35 02              [ 6 ]         PULS    A               ; Restore A
5671 e45e 39                 [ 5 ]         RTS
5672                               
5673                               ; Print space sign to the console.
5674                               ; Registers changed: none
5675                               PrintSpace:
5676 e45f 3f                 [19 ]         SWI
5677 e460 07                               FCB     SPACEF
5678 e461 39                 [ 5 ]         RTS
5679                               
5680                               ; Print two spaces to the console.
5681                               ; Registers changed: none
5682                               Print2Spaces:
5683 e462 34 02              [ 6 ]         PSHS    A               ; Save A
5684 e464 86 20              [ 2 ]         LDA     #SP
5685 e466 8d 13              [ 7 ]         BSR     PrintChar
5686 e468 8d 11              [ 7 ]         BSR     PrintChar
5687 e46a 35 02              [ 6 ]         PULS    A               ; Restore A
5688 e46c 39                 [ 5 ]         RTS
5689                               
5690                               ; Print several space characters.
5691                               ; A contains number of spaces to print.
5692                               ; Registers changed: none
5693                               PrintSpaces:
5694 e46d 34 02              [ 6 ]         PSHS    A               ; Save registers used
5695 e46f 81 00              [ 2 ] PS1:    CMPA    #0              ; Is count zero?
5696 e471 27 05              [ 3 ]         BEQ     PS2             ; Is so, done
5697 e473 8d ea              [ 7 ]         BSR     PrintSpace      ; Print a space
5698 e475 4a                 [ 2 ]         DECA                    ; Decrement count
5699 e476 20 f7              [ 3 ]         BRA     PS1             ; Check again
5700 e478 35 02              [ 6 ] PS2:    PULS    A               ; Restore registers used
5701 e47a 39                 [ 5 ]         RTS
5702                               
5703                               ; Print character to the console
5704                               ; A contains character to print.
5705                               ; Registers changed: none
5706                               PrintChar:
5707 e47b 3f                 [19 ]         SWI                     ; Call ASSIST09 monitor function
5708 e47c 01                               FCB     OUTCH           ; Service code byte
5709 e47d 39                 [ 5 ]         RTS
5710                               
5711                               ; Get character from the console
5712                               ; A contains character read. Blocks until key pressed. Character is
5713                               ; echoed. Ignores NULL ($00) and RUBOUT ($7F). CR ($OD) is converted
5714                               ; to LF ($0A).
5715                               ; Registers changed: none (flags may change). Returns char in A.
5716                               GetChar:
5717 e47e 3f                 [19 ]         SWI                     ; Call ASSIST09 monitor function
5718 e47f 00                               FCB     INCHNP          ; Service code byte
5719 e480 39                 [ 5 ]         RTS
5720                               
5721                               ; Print a byte as two hex digits followed by a space.
5722                               ; A contains byte to print.
5723                               ; Registers changed: none
5724                               PrintByte:
5725 e481 34 16              [ 9 ]         PSHS    A,B,X           ; Save registers used
5726 e483 b7 7e 31           [ 5 ]         STA     TEMP            ; Needs to be in memory so we can point to it
5727 e486 30 8d 99 a7        [ 9 ]         LEAX    TEMP,PCR        ; Get pointer to it
5728 e48a 3f                 [19 ]         SWI                     ; Call ASSIST09 monitor function
5729 e48b 04                               FCB     OUT2HS          ; Service code byte
5730 e48c 35 16              [ 9 ]         PULS    X,B,A           ; Restore registers used
5731 e48e 39                 [ 5 ]         RTS
5732                               
5733                               ; Print a word as four hex digits followed by a space.
5734                               ; X contains word to print.
5735                               ; Registers changed: none
5736                               PrintAddress:
5737 e48f 34 16              [ 9 ]         PSHS    A,B,X           ; Save registers used
5738 e491 bf 7e 31           [ 6 ]         STX     TEMP            ; Needs to be in memory so we can point to it
5739 e494 30 8d 99 99        [ 9 ]         LEAX    TEMP,PCR        ; Get pointer to it
5740 e498 3f                 [19 ]         SWI                     ; Call ASSIST09 monitor function
5741 e499 05                               FCB     OUT4HS          ; Service code byte
5742 e49a 35 16              [ 9 ]         PULS    X,B,A           ; Restore registers used
5743 e49c 39                 [ 5 ]         RTS
5744                               
5745                               ; Print a string.
5746                               ; X points to start of string to display.
5747                               ; String must be terminated in EOT character.
5748                               ; Registers changed: none
5749                               PrintString:
5750 e49d 34 10              [ 7 ]         PSHS    X               ; Save registers used
5751 e49f 3f                 [19 ]         SWI                     ; Call ASSIST09 monitor function
5752 e4a0 02                               FCB     PDATA1          ; Service code byte
5753 e4a1 35 10              [ 7 ]         PULS    X               ; Restore registers used
5754 e4a3 39                 [ 5 ]         RTS
5755                               
5756                               ; Decode the instruction pointed to by ADRS. On return will have set
5757                               ; ADRS, OPCODE, OPTYPE, LENG, AM, PAGE23, and POSTBYT.
5758                               
5759 e4a4 7f 7e 36           [ 7 ] Decode: CLR     PAGE23          ; Clear page2/3 flag
5760 e4a7 ae 8d 99 7f        [10 ]         LDX     ADRS,PCR        ; Get address of instruction
5761 e4ab e6 84              [ 4 ]         LDB     ,X              ; Get instruction op code
5762 e4ad c1 10              [ 2 ]         CMPB    #$10            ; Is it a page 2 16-bit opcode prefix with 10?
5763 e4af 27 07              [ 3 ]         BEQ     handle10        ; If so, do special handling
5764 e4b1 c1 11              [ 2 ]         CMPB    #$11            ; Is it a page 3 16-bit opcode prefix with 11?
5765 e4b3 27 53              [ 3 ]         BEQ     handle11        ; If so, do special handling
5766 e4b5 16 00 a0           [ 5 ]         LBRA    not1011         ; If not, handle as normal case
5767                               
5768                               handle10:                       ; Handle page 2 instruction
5769 e4b8 86 01              [ 2 ]         LDA     #1              ; Set page2/3 flag
5770 e4ba b7 7e 36           [ 5 ]         STA     PAGE23
5771 e4bd e6 01              [ 5 ]         LDB     1,X             ; Get real opcode
5772 e4bf f7 7e 2c           [ 5 ]         STB     OPCODE          ; Save it.
5773 e4c2 30 8d 0a 46        [ 9 ]         LEAX    PAGE2,PCR       ; Pointer to start of table
5774 e4c6 4f                 [ 2 ]         CLRA                    ; Set index into table to zero
5775                               search10:
5776 e4c7 e1 86              [ 5 ]         CMPB    A,X             ; Check for match of opcode in table
5777 e4c9 27 1f              [ 3 ]         BEQ     found10         ; Branch if found
5778 e4cb 8b 03              [ 2 ]         ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
5779 e4cd 6d 86              [ 7 ]         TST     A,X             ; Check entry
5780 e4cf 27 02              [ 3 ]         BEQ     notfound10      ; If zero, then reached end of table
5781 e4d1 20 f4              [ 3 ]         BRA     search10        ; If not, keep looking
5782                               
5783                               notfound10:                     ; Instruction not found, so is invalid.
5784 e4d3 86 10              [ 2 ]         LDA     #$10            ; Set opcode to 10
5785 e4d5 b7 7e 2c           [ 5 ]         STA     OPCODE
5786 e4d8 86 00              [ 2 ]         LDA     #OP_INV         ; Set as instruction type invalid
5787 e4da b7 7e 2e           [ 5 ]         STA     OPTYPE
5788 e4dd 86 00              [ 2 ]         LDA     #AM_INVALID     ; Set as addressing mode invalid
5789 e4df b7 7e 2d           [ 5 ]         STA     AM
5790 e4e2 86 01              [ 2 ]         LDA     #1              ; Set length to one
5791 e4e4 b7 7e 30           [ 5 ]         STA     LENG
5792 e4e7 16 00 90           [ 5 ]         LBRA    dism            ; Disassemble as normal
5793                               
5794                               found10:                        ; Found entry in table
5795 e4ea 8b 01              [ 2 ]         ADDA    #1              ; Advance to instruction type entry in table
5796 e4ec e6 86              [ 5 ]         LDB     A,X             ; Get instruction type
5797 e4ee f7 7e 2e           [ 5 ]         STB     OPTYPE          ; Save it
5798 e4f1 8b 01              [ 2 ]         ADDA    #1              ; Advanced to address mode entry in table
5799 e4f3 e6 86              [ 5 ]         LDB     A,X             ; Get address mode
5800 e4f5 f7 7e 2d           [ 5 ]         STB     AM              ; Save it
5801 e4f8 4f                 [ 2 ]         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
5802 e4f9 1f 01              [ 6 ]         TFR     D,X             ; Put addressing mode in X
5803 e4fb e6 89 ec df        [ 8 ]         LDB     LENGTHS,X       ; Get instruction length from table
5804 e4ff f7 7e 30           [ 5 ]         STB     LENG            ; Store it
5805 e502 7c 7e 30           [ 7 ]         INC     LENG            ; Add one because it is a two byte op code
5806 e505 16 00 72           [ 5 ]         LBRA    dism            ; Continue normal disassembly processing.
5807                               
5808                               handle11:                       ; Same logic as above, but use table for page 3 opcodes.
5809 e508 86 01              [ 2 ]         LDA     #1              ; Set page2/3 flag
5810 e50a b7 7e 36           [ 5 ]         STA     PAGE23
5811 e50d e6 01              [ 5 ]         LDB     1,X             ; Get real opcode
5812 e50f f7 7e 2c           [ 5 ]         STB     OPCODE          ; Save it.
5813 e512 30 8d 0a 69        [ 9 ]         LEAX    PAGE3,PCR       ; Pointer to start of table
5814 e516 4f                 [ 2 ]         CLRA                    ; Set index into table to zero
5815                               search11:
5816 e517 e1 86              [ 5 ]         CMPB    A,X             ; Check for match of opcode in table
5817 e519 27 1f              [ 3 ]         BEQ     found11         ; Branch if found
5818 e51b 8b 03              [ 2 ]         ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
5819 e51d 6d 86              [ 7 ]         TST     A,X             ; Check entry
5820 e51f 27 02              [ 3 ]         BEQ     notfound11      ; If zero, then reached end of table
5821 e521 20 f4              [ 3 ]         BRA     search11        ; If not, keep looking
5822                               
5823                               notfound11:                     ; Instruction not found, so is invalid.
5824 e523 86 11              [ 2 ]         LDA     #$11            ; Set opcode to 10
5825 e525 b7 7e 2c           [ 5 ]         STA     OPCODE
5826 e528 86 00              [ 2 ]         LDA     #OP_INV         ; Set as instruction type invalid
5827 e52a b7 7e 2e           [ 5 ]         STA     OPTYPE
5828 e52d 86 00              [ 2 ]         LDA     #AM_INVALID     ; Set as addressing mode invalid
5829 e52f b7 7e 2d           [ 5 ]         STA     AM
5830 e532 86 01              [ 2 ]         LDA     #1              ; Set length to one
5831 e534 b7 7e 30           [ 5 ]         STA     LENG
5832 e537 16 00 40           [ 5 ]         LBRA    dism            ; Disassemble as normal
5833                               
5834                               found11:                        ; Found entry in table
5835 e53a 8b 01              [ 2 ]         ADDA    #1              ; Advance to instruction type entry in table
5836 e53c e6 86              [ 5 ]         LDB     A,X             ; Get instruction type
5837 e53e f7 7e 2e           [ 5 ]         STB     OPTYPE          ; Save it
5838 e541 8b 01              [ 2 ]         ADDA    #1              ; Advanced to address mode entry in table
5839 e543 e6 86              [ 5 ]         LDB     A,X             ; Get address mode
5840 e545 f7 7e 2d           [ 5 ]         STB     AM              ; Save it
5841 e548 4f                 [ 2 ]         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
5842 e549 1f 01              [ 6 ]         TFR     D,X             ; Put addressing mode in X
5843 e54b e6 89 ec df        [ 8 ]         LDB     LENGTHS,X       ; Get instruction length from table
5844 e54f f7 7e 30           [ 5 ]         STB     LENG            ; Store it
5845 e552 7c 7e 30           [ 7 ]         INC     LENG            ; Add one because it is a two byte op code
5846 e555 16 00 22           [ 5 ]         LBRA    dism            ; Continue normal disassembly processing.
5847                               
5848                               not1011:
5849 e558 f7 7e 2c           [ 5 ]         STB     OPCODE          ; Save the op code
5850 e55b 4f                 [ 2 ]         CLRA                    ; Clear MSB of D
5851 e55c 1f 01              [ 6 ]         TFR     D,X             ; Put op code in X
5852 e55e e6 89 ed 0c        [ 8 ]         LDB     OPCODES,X       ; Get opcode type from table
5853 e562 f7 7e 2e           [ 5 ]         STB     OPTYPE          ; Store it
5854 e565 f6 7e 2c           [ 5 ]         LDB     OPCODE          ; Get op code again
5855 e568 1f 01              [ 6 ]         TFR     D,X             ; Put opcode in X
5856 e56a e6 89 ee 0c        [ 8 ]         LDB     MODES,X         ; Get addressing mode type from table
5857 e56e f7 7e 2d           [ 5 ]         STB     AM              ; Store it
5858 e571 1f 01              [ 6 ]         TFR     D,X             ; Put addressing mode in X
5859 e573 e6 89 ec df        [ 8 ]         LDB     LENGTHS,X       ; Get instruction length from table
5860 e577 f7 7e 30           [ 5 ]         STB     LENG            ; Store it
5861                               
5862                               ; If addressing mode is indexed, get and save the indexed addressing
5863                               ; post byte.
5864                               
5865 e57a b6 7e 2d           [ 5 ] dism:   LDA     AM              ; Get addressing mode
5866 e57d 81 08              [ 2 ]         CMPA    #AM_INDEXED     ; Is it indexed mode?
5867 e57f 26 22              [ 3 ]         BNE     NotIndexed      ; Branch if not
5868 e581 ae 8d 98 a5        [10 ]         LDX     ADRS,PCR        ; Get address of op code
5869                                                               ; If it is a page2/3 instruction, op code is the next byte after ADRS
5870 e585 7d 7e 36           [ 7 ]         TST     PAGE23          ; Page2/3 instruction?
5871 e588 27 04              [ 3 ]         BEQ     norm            ; Branch if not
5872 e58a a6 02              [ 5 ]         LDA     2,X             ; Post byte is two past ADRS
5873 e58c 20 02              [ 3 ]         BRA     getpb
5874 e58e a6 01              [ 5 ] norm:   LDA     1,X             ; Get next byte (the post byte)
5875 e590 b7 7e 2f           [ 5 ] getpb:  STA     POSTBYT         ; Save it
5876                               
5877                               ; Determine number of additional bytes for indexed addressing based on
5878                               ; postbyte. If most significant bit is 0, there are no additional
5879                               ; bytes and we can skip the rest of the check.
5880                               
5881 e593 2a 0e              [ 3 ]         BPL     NotIndexed      ; Branch of MSB is zero
5882                               
5883                               ; Else if most significant bit is 1, mask off all but low order 5 bits
5884                               ; and look up length in table.
5885                               
5886 e595 84 1f              [ 2 ]         ANDA    #%00011111      ; Mask off bits
5887 e597 30 8d 07 51        [ 9 ]         LEAX    POSTBYTES,PCR   ; Lookup table of lengths
5888 e59b a6 86              [ 5 ]         LDA     A,X             ; Get table entry
5889 e59d bb 7e 30           [ 5 ]         ADDA    LENG            ; Add to instruction length
5890 e5a0 b7 7e 30           [ 5 ]         STA     LENG            ; Save new length
5891                               
5892                               NotIndexed:
5893 e5a3 39                 [ 5 ]         rts
5894                               
5895                               ; Disassemble instruction at address ADRS. On return, ADRS points to
5896                               ; next instruction so it can be called again.
5897                               
5898 e5a4 bd e4 a4           [ 8 ] DISASM: JSR     Decode          ; Decode the instruction
5899                               
5900                               ; Print address followed by a space
5901 e5a7 ae 8d 98 7f        [10 ]         LDX     ADRS,PCR
5902 e5ab 17 fe e1           [ 9 ]         LBSR    PrintAddress
5903                               
5904                               ; Print one more space
5905                               
5906 e5ae 17 fe ae           [ 9 ]         LBSR    PrintSpace
5907                               
5908                               ; Print the op code bytes based on the instruction length
5909                               
5910 e5b1 f6 7e 30           [ 5 ]         LDB     LENG            ; Number of bytes in instruction
5911 e5b4 ae 8d 98 72        [10 ]         LDX     ADRS,PCR        ; Pointer to start of instruction
5912 e5b8 a6 80              [ 6 ] opby:   LDA     ,X+             ; Get instruction byte and increment pointer
5913 e5ba 17 fe c4           [ 9 ]         LBSR    PrintByte       ; Print it, followed by a space
5914 e5bd 5a                 [ 2 ]         DECB                    ; Decrement byte count
5915 e5be 26 f8              [ 3 ]         BNE     opby            ; Repeat until done
5916                               
5917                               ; Print needed remaining spaces to pad out to correct column
5918                               
5919 e5c0 30 8d 07 24        [ 9 ]         LEAX    PADDING,PCR     ; Pointer to start of lookup table
5920 e5c4 b6 7e 30           [ 5 ]         LDA     LENG            ; Number of bytes in instruction
5921 e5c7 4a                 [ 2 ]         DECA                    ; Subtract 1 since table starts at 1, not 0
5922 e5c8 a6 86              [ 5 ]         LDA     A,X             ; Get number of spaces to print
5923 e5ca 17 fe a0           [ 9 ]         LBSR    PrintSpaces
5924                               
5925                               ; If a page2/3 instruction, advance ADRS to the next byte which points
5926                               ; to the real op code.
5927                               
5928 e5cd 7d 7e 36           [ 7 ]         TST     PAGE23          ; Flag set
5929 e5d0 27 09              [ 3 ]         BEQ     noinc           ; Branch if not
5930 e5d2 fc 7e 2a           [ 6 ]         LDD     ADRS            ; Increment 16-bit address
5931 e5d5 c3 00 01           [ 4 ]         ADDD    #1
5932 e5d8 fd 7e 2a           [ 6 ]         STD     ADRS
5933                               
5934                               ; Get and print mnemonic (4 chars)
5935                               
5936 e5db f6 7e 2e           [ 5 ] noinc   LDB     OPTYPE          ; Get instruction type to index into table
5937 e5de 4f                 [ 2 ]         CLRA                    ; Clear MSB of D
5938 e5df 58                 [ 2 ]         ASLB                    ; 16-bit shift of D: Rotate B, MSB into Carry
5939 e5e0 49                 [ 2 ]         ROLA                    ; Rotate A, Carry into LSB
5940 e5e1 58                 [ 2 ]         ASLB                    ; Do it twice to multiple by four
5941 e5e2 49                 [ 2 ]         ROLA                    ;
5942 e5e3 30 8d 04 e4        [ 9 ]         LEAX    MNEMONICS,PCR   ; Pointer to start of table
5943 e5e7 b7 7e 33           [ 5 ]         STA     TEMP1           ; Save value of A
5944 e5ea a6 8b              [ 8 ]         LDA     D,X             ; Get first char of mnemonic
5945 e5ec 17 fe 8c           [ 9 ]         LBSR    PrintChar       ; Print it
5946 e5ef b6 7e 33           [ 5 ]         LDA     TEMP1           ; Restore value of A
5947 e5f2 5c                 [ 2 ]         INCB                    ; Advance pointer
5948 e5f3 a6 8b              [ 8 ]         LDA     D,X             ; Get second char of mnemonic
5949 e5f5 17 fe 83           [ 9 ]         LBSR    PrintChar       ; Print it
5950 e5f8 b6 7e 33           [ 5 ]         LDA     TEMP1           ; Restore value of A
5951 e5fb 5c                 [ 2 ]         INCB                    ; Advance pointer
5952 e5fc a6 8b              [ 8 ]         LDA     D,X             ; Get third char of mnemonic
5953 e5fe 17 fe 7a           [ 9 ]         LBSR    PrintChar       ; Print it
5954 e601 b6 7e 33           [ 5 ]         LDA     TEMP1           ; Restore value of A
5955 e604 5c                 [ 2 ]         INCB                    ; Advance pointer
5956 e605 a6 8b              [ 8 ]         LDA     D,X             ; Get fourth char of mnemonic
5957 e607 17 fe 71           [ 9 ]         LBSR    PrintChar       ; Print it
5958                               
5959                               ; Display any operands based on addressing mode and call appropriate
5960                               ; routine. TODO: Could use a lookup table for this.
5961                               
5962 e60a b6 7e 2d           [ 5 ]         LDA     AM              ; Get addressing mode
5963 e60d 81 00              [ 2 ]         CMPA    #AM_INVALID
5964 e60f 27 2e              [ 3 ]         BEQ     DO_INVALID
5965 e611 81 01              [ 2 ]         CMPA    #AM_INHERENT
5966 e613 27 39              [ 3 ]         BEQ     DO_INHERENT
5967 e615 81 02              [ 2 ]         CMPA    #AM_IMMEDIATE8
5968 e617 27 38              [ 3 ]         BEQ     DO_IMMEDIATE8
5969 e619 81 03              [ 2 ]         CMPA    #AM_IMMEDIATE16
5970 e61b 10 27 01 af        [ 6 ]         LBEQ    DO_IMMEDIATE16
5971 e61f 81 04              [ 2 ]         CMPA    #AM_DIRECT
5972 e621 10 27 01 c4        [ 6 ]         LBEQ    DO_DIRECT
5973 e625 81 05              [ 2 ]         CMPA    #AM_EXTENDED
5974 e627 10 27 01 d0        [ 6 ]         LBEQ    DO_EXTENDED
5975 e62b 81 06              [ 2 ]         CMPA    #AM_RELATIVE8
5976 e62d 10 27 01 e0        [ 6 ]         LBEQ    DO_RELATIVE8
5977 e631 81 07              [ 2 ]         CMPA    #AM_RELATIVE16
5978 e633 10 27 01 f5        [ 6 ]         LBEQ    DO_RELATIVE16
5979 e637 81 08              [ 2 ]         CMPA    #AM_INDEXED
5980 e639 10 27 02 09        [ 6 ]         LBEQ    DO_INDEXED
5981 e63d 20 00              [ 3 ]         BRA     DO_INVALID      ; Should never be reached
5982                               
5983                               DO_INVALID:                     ; Display "   ; INVALID"
5984 e63f 86 0f              [ 2 ]         LDA     #15             ; Want 15 spaces
5985 e641 17 fe 29           [ 9 ]         LBSR    PrintSpaces
5986 e644 30 8d 09 53        [ 9 ]         LEAX    MSG1,PCR
5987 e648 17 fe 52           [ 9 ]         LBSR    PrintString
5988 e64b 16 04 67           [ 5 ]         LBRA    done
5989                               
5990                               DO_INHERENT:                    ; Nothing else to do
5991 e64e 16 04 64           [ 5 ]         LBRA    done
5992                               
5993                               DO_IMMEDIATE8:
5994 e651 b6 7e 2e           [ 5 ]         LDA     OPTYPE          ; Get opcode type
5995 e654 81 81              [ 2 ]         CMPA    #OP_TFR         ; Is is TFR?
5996 e656 27 33              [ 3 ]         BEQ     XFREXG          ; Handle special case of TFR
5997 e658 81 37              [ 2 ]         CMPA    #OP_EXG         ; Is is EXG?
5998 e65a 27 2f              [ 3 ]         BEQ     XFREXG          ; Handle special case of EXG
5999                               
6000 e65c 81 66              [ 2 ]         CMPA    #OP_PULS        ; Is is PULS?
6001 e65e 10 27 00 ad        [ 6 ]         LBEQ    PULPSH
6002 e662 81 67              [ 2 ]         CMPA    #OP_PULU        ; Is is PULU?
6003 e664 10 27 00 a7        [ 6 ]         LBEQ    PULPSH
6004 e668 81 64              [ 2 ]         CMPA    #OP_PSHS        ; Is is PSHS?
6005 e66a 10 27 00 a1        [ 6 ]         LBEQ    PULPSH
6006 e66e 81 65              [ 2 ]         CMPA    #OP_PSHU        ; Is is PSHU?
6007 e670 10 27 00 9b        [ 6 ]         LBEQ    PULPSH
6008                               
6009                                                               ; Display "  #$nn"
6010 e674 17 fd eb           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6011 e677 86 23              [ 2 ]         LDA     #'#             ; Number sign
6012 e679 17 fd ff           [ 9 ]         LBSR    PrintChar
6013 e67c 17 fd bc           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6014 e67f ae 8d 97 a7        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6015 e683 a6 01              [ 5 ]         LDA     1,X             ; Get next byte (immediate data)
6016 e685 17 fd f9           [ 9 ]         LBSR    PrintByte       ; Print as hex value
6017 e688 16 04 2a           [ 5 ]         LBRA    done
6018                               
6019                               XFREXG:                         ; Handle special case of TFR and EXG
6020                                                               ; Display "  r1,r2"
6021 e68b 17 fd d4           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6022 e68e ae 8d 97 98        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6023 e692 a6 01              [ 5 ]         LDA     1,X             ; Get next byte (postbyte)
6024 e694 84 f0              [ 2 ]         ANDA    #%11110000      ; Mask out source register bits
6025 e696 44                 [ 2 ]         LSRA                    ; Shift into low order bits
6026 e697 44                 [ 2 ]         LSRA
6027 e698 44                 [ 2 ]         LSRA
6028 e699 44                 [ 2 ]         LSRA
6029 e69a 8d 0e              [ 7 ]         BSR     TFREXGRegister  ; Print source register name
6030 e69c 86 2c              [ 2 ]         LDA     #',             ; Print comma
6031 e69e 17 fd da           [ 9 ]         LBSR    PrintChar
6032 e6a1 a6 01              [ 5 ]         LDA     1,X             ; Get postbyte again
6033 e6a3 84 0f              [ 2 ]         ANDA    #%00001111      ; Mask out destination register bits
6034 e6a5 8d 03              [ 7 ]         BSR     TFREXGRegister  ; Print destination register name
6035 e6a7 16 04 0b           [ 5 ]         LBRA    done
6036                               
6037                               ; Look up register name (in A) from Transfer/Exchange postbyte. 4 LSB
6038                               ; bits determine the register name. Value is printed. Invalid value
6039                               ; is shown as '?'.
6040                               ; Value:    0 1 2 3 4 5  8 9 10 11
6041                               ; Register: D X Y U S PC A B CC DP
6042                               
6043                               TFREXGRegister:
6044 e6aa 81 00              [ 2 ]         CMPA    #0
6045 e6ac 26 04              [ 3 ]         BNE     Try1
6046 e6ae 86 44              [ 2 ]         LDA     #'D
6047 e6b0 20 50              [ 3 ]         BRA     Print1Reg
6048 e6b2 81 01              [ 2 ] Try1:   CMPA    #1
6049 e6b4 26 04              [ 3 ]         BNE     Try2
6050 e6b6 86 58              [ 2 ]         LDA     #'X
6051 e6b8 20 48              [ 3 ]         BRA     Print1Reg
6052 e6ba 81 02              [ 2 ] Try2:   CMPA    #2
6053 e6bc 26 04              [ 3 ]         BNE     Try3
6054 e6be 86 59              [ 2 ]         LDA     #'Y
6055 e6c0 20 40              [ 3 ]         BRA     Print1Reg
6056 e6c2 81 03              [ 2 ] Try3:   CMPA    #3
6057 e6c4 26 04              [ 3 ]         BNE     Try4
6058 e6c6 86 55              [ 2 ]         LDA     #'U
6059 e6c8 20 38              [ 3 ]         BRA     Print1Reg
6060 e6ca 81 04              [ 2 ] Try4:   CMPA    #4
6061 e6cc 26 04              [ 3 ]         BNE     Try5
6062 e6ce 86 53              [ 2 ]         LDA     #'S
6063 e6d0 20 30              [ 3 ]         BRA     Print1Reg
6064 e6d2 81 05              [ 2 ] Try5:   CMPA    #5
6065 e6d4 26 06              [ 3 ]         BNE     Try8
6066 e6d6 86 50              [ 2 ]         LDA     #'P
6067 e6d8 c6 43              [ 2 ]         LDB     #'C
6068 e6da 20 2a              [ 3 ]         BRA     Print2Reg
6069 e6dc 81 08              [ 2 ] Try8:   CMPA    #8
6070 e6de 26 04              [ 3 ]         BNE     Try9
6071 e6e0 86 41              [ 2 ]         LDA     #'A
6072 e6e2 20 1e              [ 3 ]         BRA     Print1Reg
6073 e6e4 81 09              [ 2 ] Try9:   CMPA    #9
6074 e6e6 26 04              [ 3 ]         BNE     Try10
6075 e6e8 86 42              [ 2 ]         LDA     #'B
6076 e6ea 20 16              [ 3 ]         BRA     Print1Reg
6077 e6ec 81 0a              [ 2 ] Try10:  CMPA    #10
6078 e6ee 26 06              [ 3 ]         BNE     Try11
6079 e6f0 86 43              [ 2 ]         LDA     #'C
6080 e6f2 c6 43              [ 2 ]         LDB     #'C
6081 e6f4 20 10              [ 3 ]         BRA     Print2Reg
6082 e6f6 81 0b              [ 2 ] Try11:  CMPA    #11
6083 e6f8 26 06              [ 3 ]         BNE     Inv
6084 e6fa 86 44              [ 2 ]         LDA     #'D
6085 e6fc c6 50              [ 2 ]         LDB     #'P
6086 e6fe 20 06              [ 3 ]         BRA     Print2Reg
6087 e700 86 3f              [ 2 ] Inv:    LDA     #'?             ; Invalid
6088                                                               ; Fall through
6089                               Print1Reg:
6090 e702 17 fd 76           [ 9 ]         LBSR   PrintChar        ; Print character
6091 e705 39                 [ 5 ]         RTS
6092                               Print2Reg:
6093 e706 17 fd 72           [ 9 ]         LBSR   PrintChar        ; Print first character
6094 e709 1f 98              [ 6 ]         TFR    B,A
6095 e70b 17 fd 6d           [ 9 ]         LBSR   PrintChar        ; Print second character
6096 e70e 39                 [ 5 ]         RTS
6097                               
6098                               ; Handle PSHS/PSHU/PULS/PULU instruction operands
6099                               ; Format is a register list, eg; "  A,B,X"
6100                               
6101                               PULPSH:
6102 e70f 17 fd 50           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6103 e712 86 01              [ 2 ]         LDA     #1
6104 e714 b7 7e 35           [ 5 ]         STA     FIRST           ; Flag set before any items printed
6105 e717 ae 8d 97 0f        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6106 e71b a6 01              [ 5 ]         LDA     1,X             ; Get next byte (postbyte)
6107                               
6108                               ; Postbyte bits indicate registers to push/pull when 1.
6109                               ; 7  6   5 4 3  2 1 0
6110                               ; PC S/U Y X DP B A CC
6111                               
6112                               ; TODO: Could simplify this with shifting and lookup table.
6113                               
6114 e71d 85 80              [ 2 ]         BITA    #%10000000      ; Bit 7 set?
6115 e71f 27 0d              [ 3 ]         BEQ     bit6
6116 e721 34 06              [ 7 ]         PSHS    A,B
6117 e723 86 50              [ 2 ]         LDA     #'P
6118 e725 c6 43              [ 2 ]         LDB     #'C
6119 e727 8d dd              [ 7 ]         BSR     Print2Reg       ; Print PC
6120 e729 7f 7e 35           [ 7 ]         CLR     FIRST
6121 e72c 35 06              [ 7 ]         PULS    A,B
6122 e72e 85 40              [ 2 ] bit6:   BITA    #%01000000      ; Bit 6 set?
6123 e730 27 21              [ 3 ]         BEQ     bit5
6124                               
6125                               ; Need to show S or U depending on instruction
6126                               
6127 e732 34 02              [ 6 ]         PSHS    A               ; Save postbyte
6128 e734 b6 7e 2e           [ 5 ]         LDA     OPTYPE          ; Get opcode type
6129 e737 81 66              [ 2 ]         CMPA    #OP_PULS
6130 e739 27 12              [ 3 ]         BEQ     printu
6131 e73b 81 64              [ 2 ]         CMPA    #OP_PSHS
6132 e73d 27 0e              [ 3 ]         BEQ     printu
6133 e73f 17 00 81           [ 9 ]         LBSR    PrintCommaIfNotFirst
6134 e742 86 53              [ 2 ]         LDA     #'S             ; Print S
6135 e744 8d bc              [ 7 ] pr1     BSR     Print1Reg
6136 e746 7f 7e 35           [ 7 ]         CLR     FIRST
6137 e749 35 02              [ 6 ]         PULS    A
6138 e74b 20 06              [ 3 ]         bra     bit5
6139 e74d 8d 74              [ 7 ] printu: BSR     PrintCommaIfNotFirst
6140 e74f 86 55              [ 2 ]         LDA     #'U             ; Print U
6141 e751 20 f1              [ 3 ]         bra     pr1
6142 e753 85 20              [ 2 ] bit5:   BITA    #%00100000      ; Bit 5 set?
6143 e755 27 0d              [ 3 ]         BEQ     bit4
6144 e757 34 02              [ 6 ]         PSHS    A
6145 e759 8d 68              [ 7 ]         BSR     PrintCommaIfNotFirst
6146 e75b 86 59              [ 2 ]         LDA     #'Y
6147 e75d 8d a3              [ 7 ]         BSR     Print1Reg       ; Print Y
6148 e75f 7f 7e 35           [ 7 ]         CLR     FIRST
6149 e762 35 02              [ 6 ]         PULS    A
6150 e764 85 10              [ 2 ] bit4:   BITA    #%00010000      ; Bit 4 set?
6151 e766 27 0d              [ 3 ]         BEQ     bit3
6152 e768 34 02              [ 6 ]         PSHS    A
6153 e76a 8d 57              [ 7 ]         BSR     PrintCommaIfNotFirst
6154 e76c 86 58              [ 2 ]         LDA     #'X
6155 e76e 8d 92              [ 7 ]         BSR     Print1Reg       ; Print X
6156 e770 7f 7e 35           [ 7 ]         CLR     FIRST
6157 e773 35 02              [ 6 ]         PULS    A
6158 e775 85 08              [ 2 ] bit3:   BITA    #%00001000      ; Bit 3 set?
6159 e777 27 0f              [ 3 ]         BEQ     bit2
6160 e779 34 06              [ 7 ]         PSHS    A,B
6161 e77b 8d 46              [ 7 ]         BSR     PrintCommaIfNotFirst
6162 e77d 86 44              [ 2 ]         LDA     #'D
6163 e77f c6 50              [ 2 ]         LDB     #'P
6164 e781 8d 83              [ 7 ]         BSR     Print2Reg       ; Print DP
6165 e783 7f 7e 35           [ 7 ]         CLR     FIRST
6166 e786 35 06              [ 7 ]         PULS    A,B
6167 e788 85 04              [ 2 ] bit2:   BITA    #%00000100      ; Bit 2 set?
6168 e78a 27 0e              [ 3 ]         BEQ     bit1
6169 e78c 34 02              [ 6 ]         PSHS    A
6170 e78e 8d 33              [ 7 ]         BSR     PrintCommaIfNotFirst
6171 e790 86 42              [ 2 ]         LDA     #'B
6172 e792 17 ff 6d           [ 9 ]         LBSR    Print1Reg       ; Print B
6173 e795 7f 7e 35           [ 7 ]         CLR     FIRST
6174 e798 35 02              [ 6 ]         PULS    A
6175 e79a 85 02              [ 2 ] bit1:   BITA    #%00000010      ; Bit 1 set?
6176 e79c 27 0e              [ 3 ]         BEQ     bit0
6177 e79e 34 02              [ 6 ]         PSHS    A
6178 e7a0 8d 21              [ 7 ]         BSR     PrintCommaIfNotFirst
6179 e7a2 86 41              [ 2 ]         LDA     #'A
6180 e7a4 17 ff 5b           [ 9 ]         LBSR    Print1Reg       ; Print A
6181 e7a7 7f 7e 35           [ 7 ]         CLR     FIRST
6182 e7aa 35 02              [ 6 ]         PULS    A
6183 e7ac 85 01              [ 2 ] bit0:   BITA    #%00000001      ; Bit 0 set?
6184 e7ae 27 10              [ 3 ]         BEQ     done1
6185 e7b0 34 06              [ 7 ]         PSHS    A,B
6186 e7b2 8d 0f              [ 7 ]         BSR     PrintCommaIfNotFirst
6187 e7b4 86 43              [ 2 ]         LDA     #'C
6188 e7b6 c6 43              [ 2 ]         LDB     #'C
6189 e7b8 17 ff 4b           [ 9 ]         LBSR    Print2Reg       ; Print CC
6190 e7bb 7f 7e 35           [ 7 ]         CLR     FIRST
6191 e7be 35 06              [ 7 ]         PULS    A,B
6192 e7c0 16 02 f2           [ 5 ] done1   LBRA    done
6193                               
6194                               ; Print comma if FIRST flag is not set.
6195                               PrintCommaIfNotFirst:
6196 e7c3 7d 7e 35           [ 7 ]         TST     FIRST
6197 e7c6 26 05              [ 3 ]         BNE     ret1
6198 e7c8 86 2c              [ 2 ]         LDA     #',
6199 e7ca 17 fc ae           [ 9 ]         LBSR    PrintChar
6200 e7cd 39                 [ 5 ] ret1:   RTS
6201                               
6202                               DO_IMMEDIATE16:                 ; Display "  #$nnnn"
6203 e7ce 17 fc 91           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6204 e7d1 86 23              [ 2 ]         LDA     #'#             ; Number sign
6205 e7d3 17 fc a5           [ 9 ]         LBSR    PrintChar
6206 e7d6 17 fc 62           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6207 e7d9 ae 8d 96 4d        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6208 e7dd a6 01              [ 5 ]         LDA     1,X             ; Get first byte (immediate data MSB)
6209 e7df e6 02              [ 5 ]         LDB     2,X             ; Get second byte (immediate data LSB)
6210 e7e1 1f 01              [ 6 ]         TFR     D,X             ; Put in X to print
6211 e7e3 17 fc a9           [ 9 ]         LBSR    PrintAddress    ; Print as hex value
6212 e7e6 16 02 cc           [ 5 ]         LBRA    done
6213                               
6214                               DO_DIRECT:                      ; Display "  $nn"
6215 e7e9 17 fc 76           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6216 e7ec 17 fc 4c           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6217 e7ef ae 8d 96 37        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6218 e7f3 a6 01              [ 5 ]         LDA     1,X             ; Get next byte (byte data)
6219 e7f5 17 fc 89           [ 9 ]         LBSR    PrintByte       ; Print as hex value
6220 e7f8 16 02 ba           [ 5 ]         LBRA    done
6221                               
6222                               DO_EXTENDED:                    ; Display "  $nnnn"
6223 e7fb 17 fc 64           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6224 e7fe 17 fc 3a           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6225 e801 ae 8d 96 25        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6226 e805 a6 01              [ 5 ]         LDA     1,X             ; Get first byte (address MSB)
6227 e807 e6 02              [ 5 ]         LDB     2,X             ; Get second byte (address LSB)
6228 e809 1f 01              [ 6 ]         TFR     D,X             ; Put in X to print
6229 e80b 17 fc 81           [ 9 ]         LBSR    PrintAddress    ; Print as hex value
6230 e80e 16 02 a4           [ 5 ]         LBRA    done
6231                               
6232                               DO_RELATIVE8:                   ; Display "  $nnnn"
6233 e811 17 fc 4e           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6234 e814 17 fc 24           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6235                               
6236                               ; Destination address for relative branch is address of opcode + (sign
6237                               ; extended)offset + 2, e.g.
6238                               ;   $1015 + $(FF)FC + 2 = $1013
6239                               ;   $101B + $(00)27 + 2 = $1044
6240                               
6241 e817 ae 8d 96 0f        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6242 e81b e6 01              [ 5 ]         LDB     1,X             ; Get first byte (8-bit branch offset)
6243 e81d 1d                 [ 2 ]         SEX                     ; Sign extend to 16 bits
6244 e81e f3 7e 2a           [ 7 ]         ADDD    ADRS            ; Add address of op code
6245 e821 c3 00 02           [ 4 ]         ADDD    #2              ; Add 2
6246 e824 1f 01              [ 6 ]         TFR     D,X             ; Put in X to print
6247 e826 17 fc 66           [ 9 ]         LBSR    PrintAddress    ; Print as hex value
6248 e829 16 02 89           [ 5 ]         LBRA    done
6249                               
6250                               DO_RELATIVE16:                  ; Display "  $nnnn"
6251 e82c 17 fc 33           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6252 e82f 17 fc 09           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6253                               
6254                               ; Destination address calculation is similar to above, except offset
6255                               ; is 16 bits and need to add 3.
6256                               
6257 e832 ae 8d 95 f4        [10 ]         LDX     ADRS,PCR        ; Get address of op code
6258 e836 ec 01              [ 6 ]         LDD     1,X             ; Get next 2 bytes (16-bit branch offset)
6259 e838 f3 7e 2a           [ 7 ]         ADDD    ADRS            ; Add address of op code
6260 e83b c3 00 03           [ 4 ]         ADDD    #3              ; Add 3
6261 e83e 1f 01              [ 6 ]         TFR     D,X             ; Put in X to print
6262 e840 17 fc 4c           [ 9 ]         LBSR    PrintAddress    ; Print as hex value
6263 e843 16 02 6f           [ 5 ]         LBRA    done
6264                               
6265                               DO_INDEXED:
6266 e846 17 fc 19           [ 9 ]         LBSR    Print2Spaces    ; Two spaces
6267                               
6268                               ; Addressing modes are determined by the postbyte:
6269                               ;
6270                               ; Postbyte  Format  Additional Bytes
6271                               ; --------  ------  ----------------
6272                               ; 0RRnnnnn  n,R     0
6273                               ; 1RR00100  ,R      0
6274                               ; 1RR01000  n,R     1
6275                               ; 1RR01001  n,R     2
6276                               ; 1RR00110  A,R     0
6277                               ; 1RR00101  B,R     0
6278                               ; 1RR01011  D,R     0
6279                               ; 1RR00000  ,R+     0
6280                               ; 1RR00001  ,R++    0
6281                               ; 1RR00010  ,-R     0
6282                               ; 1RR00011  ,--R    0
6283                               ; 1xx01100  n,PCR   1
6284                               ; 1xx01101  n,PCR   2
6285                               ; 1RR10100  [,R]    0
6286                               ; 1RR11000  [n,R]   1
6287                               ; 1RR11001  [n,R]   2
6288                               ; 1RR10110  [A,R]   0
6289                               ; 1RR10101  [B,R]   0
6290                               ; 1RR11011  [D,R]   0
6291                               ; 1RR10001  [,R++]  0
6292                               ; 1RR10011  [,--R]  0
6293                               ; 1xx11100  [n,PCR] 1
6294                               ; 1xx11101  [n,PCR] 2
6295                               ; 10011111  [n]     2
6296                               ;
6297                               ; Where RR: 00=X 01=Y 10=U 11=S
6298                               
6299 e849 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte
6300 e84c 2b 14              [ 3 ]         BMI     ind2            ; Branch if MSB is 1
6301                               
6302                                                               ; Format is 0RRnnnnn  n,R
6303 e84e 84 1f              [ 2 ]         ANDA    #%00011111      ; Get 5-bit offset
6304 e850 17 fb e8           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6305 e853 17 fc 2b           [ 9 ]         LBSR    PrintByte       ; Print offset
6306 e856 17 fb eb           [ 9 ]         LBSR    PrintComma      ; Print comma
6307 e859 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6308 e85c 17 02 35           [ 9 ]         LBSR    PrintRegister   ; Print register name
6309 e85f 16 02 53           [ 5 ]         LBRA    done
6310                               ind2:
6311 e862 84 9f              [ 2 ]         ANDA    #%10011111      ; Mask out register bits
6312 e864 81 84              [ 2 ]         CMPA    #%10000100      ; Check against pattern
6313 e866 26 0c              [ 3 ]         BNE     ind3
6314                                                               ; Format is 1RR00100  ,R
6315 e868 17 fb d9           [ 9 ]         LBSR    PrintComma      ; Print comma
6316 e86b b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6317 e86e 17 02 23           [ 9 ]         LBSR    PrintRegister   ; Print register name
6318 e871 16 02 41           [ 5 ]         LBRA    done
6319                               ind3:
6320 e874 81 88              [ 2 ]         CMPA    #%10001000      ; Check against pattern
6321 e876 26 18              [ 3 ]         BNE     ind4
6322                                                               ; Format is 1RR01000  n,R
6323 e878 ae 8d 95 ae        [10 ]         LDX     ADRS,PCR
6324 e87c a6 02              [ 5 ]         LDA     2,X             ; Get 8-bit offset
6325 e87e 17 fb ba           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6326 e881 17 fb fd           [ 9 ]         LBSR    PrintByte       ; Display it
6327 e884 17 fb bd           [ 9 ]         LBSR    PrintComma      ; Print comma
6328 e887 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6329 e88a 17 02 07           [ 9 ]         LBSR    PrintRegister   ; Print register name
6330 e88d 16 02 25           [ 5 ]         LBRA    done
6331                               ind4:
6332 e890 81 89              [ 2 ]         CMPA    #%10001001      ; Check against pattern
6333 e892 26 1a              [ 3 ]         BNE     ind5
6334                                                               ; Format is 1RR01001  n,R
6335 e894 ae 8d 95 92        [10 ]         LDX     ADRS,PCR
6336 e898 ec 02              [ 6 ]         LDD     2,X             ; Get 16-bit offset
6337 e89a 1f 01              [ 6 ]         TFR     D,X
6338 e89c 17 fb 9c           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6339 e89f 17 fb ed           [ 9 ]         LBSR    PrintAddress    ; Display it
6340 e8a2 17 fb 9f           [ 9 ]         LBSR    PrintComma      ; Print comma
6341 e8a5 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6342 e8a8 17 01 e9           [ 9 ]         LBSR    PrintRegister   ; Print register name
6343 e8ab 16 02 07           [ 5 ]         LBRA    done
6344                               ind5:
6345 e8ae 81 86              [ 2 ]         CMPA    #%10000110      ; Check against pattern
6346 e8b0 26 11              [ 3 ]         BNE     ind6
6347                                                               ; Format is 1RR00110  A,R
6348 e8b2 86 41              [ 2 ]         LDA     #'A
6349 e8b4 17 fb c4           [ 9 ]         LBSR    PrintChar       ; Print A
6350 e8b7 17 fb 8a           [ 9 ] commar: LBSR    PrintComma      ; Print comma
6351 e8ba b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6352 e8bd 17 01 d4           [ 9 ]         LBSR    PrintRegister   ; Print register name
6353 e8c0 16 01 f2           [ 5 ]         LBRA    done
6354                               ind6:
6355 e8c3 81 85              [ 2 ]         CMPA    #%10000101      ; Check against pattern
6356 e8c5 26 07              [ 3 ]         BNE     ind7
6357                                                               ; Format is 1RR00101  B,R
6358 e8c7 86 42              [ 2 ]         LDA     #'B
6359 e8c9 17 fb af           [ 9 ]         LBSR    PrintChar
6360 e8cc 20 e9              [ 3 ]         BRA     commar
6361                               ind7:
6362 e8ce 81 8b              [ 2 ]         CMPA    #%10001011      ; Check against pattern
6363 e8d0 26 07              [ 3 ]         BNE     ind8
6364                                                               ; Format is 1RR01011  D,R
6365 e8d2 86 44              [ 2 ]         LDA     #'D
6366 e8d4 17 fb a4           [ 9 ]         LBSR    PrintChar
6367 e8d7 20 de              [ 3 ]         BRA     commar
6368                               ind8:
6369 e8d9 81 80              [ 2 ]         CMPA    #%10000000      ; Check against pattern
6370 e8db 26 11              [ 3 ]         BNE     ind9
6371                                                               ; Format is 1RR00000  ,R+
6372 e8dd 17 fb 64           [ 9 ]         LBSR    PrintComma      ; Print comma
6373 e8e0 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6374 e8e3 17 01 ae           [ 9 ]         LBSR    PrintRegister   ; Print register name
6375 e8e6 86 2b              [ 2 ]         LDA     #'+             ; Print plus
6376 e8e8 17 fb 90           [ 9 ]         LBSR    PrintChar
6377 e8eb 16 01 c7           [ 5 ]         LBRA    done
6378                               ind9:
6379 e8ee 81 81              [ 2 ]         CMPA    #%10000001      ; Check against pattern
6380 e8f0 26 14              [ 3 ]         BNE     ind10
6381                                                               ; Format is 1RR00001  ,R++
6382 e8f2 17 fb 4f           [ 9 ]         LBSR    PrintComma      ; Print comma
6383 e8f5 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6384 e8f8 17 01 99           [ 9 ]         LBSR    PrintRegister   ; Print register name
6385 e8fb 86 2b              [ 2 ]         LDA     #'+             ; Print plus twice
6386 e8fd 17 fb 7b           [ 9 ]         LBSR    PrintChar
6387 e900 17 fb 78           [ 9 ]         LBSR    PrintChar
6388 e903 16 01 af           [ 5 ]         LBRA    done
6389                               ind10:
6390 e906 81 82              [ 2 ]         CMPA    #%10000010      ; Check against pattern
6391 e908 26 11              [ 3 ]         BNE     ind11
6392                                                               ; Format is 1RR00010  ,-R
6393 e90a 17 fb 37           [ 9 ]         LBSR    PrintComma      ; Print comma
6394 e90d 86 2d              [ 2 ]         LDA     #'-             ; Print minus
6395 e90f 17 fb 69           [ 9 ]         LBSR    PrintChar
6396 e912 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6397 e915 17 01 7c           [ 9 ]         LBSR    PrintRegister   ; Print register name
6398 e918 16 01 9a           [ 5 ]         LBRA    done
6399                               ind11:
6400 e91b 81 83              [ 2 ]         CMPA    #%10000011      ; Check against pattern
6401 e91d 26 14              [ 3 ]         BNE     ind12
6402                                                               ; Format is 1RR00011  ,--R
6403 e91f 17 fb 22           [ 9 ]         LBSR    PrintComma      ; Print comma
6404 e922 86 2d              [ 2 ]         LDA     #'-             ; Print minus twice
6405 e924 17 fb 54           [ 9 ]         LBSR    PrintChar
6406 e927 17 fb 51           [ 9 ]         LBSR    PrintChar
6407 e92a b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6408 e92d 17 01 64           [ 9 ]         LBSR    PrintRegister   ; Print register name
6409 e930 16 01 82           [ 5 ]         LBRA    done
6410                               ind12:
6411 e933 81 8c              [ 2 ]         CMPA    #%10001100      ; Check against pattern
6412 e935 26 15              [ 3 ]         BNE     ind13
6413                                                               ; Format is 1xx01100  n,PCR
6414 e937 ae 8d 94 ef        [10 ]         LDX     ADRS,PCR
6415 e93b a6 02              [ 5 ]         LDA     2,X             ; Get 8-bit offset
6416 e93d 17 fa fb           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6417 e940 17 fb 3e           [ 9 ]         LBSR    PrintByte       ; Display it
6418 e943 17 fa fe           [ 9 ]         LBSR    PrintComma      ; Print comma
6419 e946 17 01 64           [ 9 ]         LBSR    PrintPCR        ; Print PCR
6420 e949 16 01 69           [ 5 ]         LBRA    done
6421                               ind13:
6422 e94c 81 8d              [ 2 ]         CMPA    #%10001101      ; Check against pattern
6423 e94e 26 17              [ 3 ]         BNE     ind14
6424                                                               ; Format is 1xx01101  n,PCR
6425 e950 ae 8d 94 d6        [10 ]         LDX     ADRS,PCR
6426 e954 ec 02              [ 6 ]         LDD     2,X             ; Get 16-bit offset
6427 e956 1f 01              [ 6 ]         TFR     D,X
6428 e958 17 fa e0           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6429 e95b 17 fb 31           [ 9 ]         LBSR    PrintAddress    ; Display it
6430 e95e 17 fa e3           [ 9 ]         LBSR    PrintComma      ; Print comma
6431 e961 17 01 49           [ 9 ]         LBSR    PrintPCR        ; Print PCR
6432 e964 16 01 4e           [ 5 ]         LBRA    done
6433                               ind14:
6434 e967 81 94              [ 2 ]         CMPA    #%10010100      ; Check against pattern
6435 e969 26 12              [ 3 ]         BNE     ind15
6436                                                               ; Format is 1RR10100  [,R]
6437 e96b 17 fa df           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6438 e96e 17 fa d3           [ 9 ]         LBSR    PrintComma      ; Print comma
6439 e971 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6440 e974 17 01 1d           [ 9 ]         LBSR    PrintRegister   ; Print register name
6441 e977 17 fa dc           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6442 e97a 16 01 38           [ 5 ]         LBRA    done
6443                               ind15:
6444 e97d 81 98              [ 2 ]         CMPA    #%10011000      ; Check against pattern
6445 e97f 26 1e              [ 3 ]         BNE     ind16
6446                                                               ; Format is 1RR11000  [n,R]
6447 e981 17 fa c9           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6448 e984 ae 8d 94 a2        [10 ]         LDX     ADRS,PCR
6449 e988 a6 02              [ 5 ]         LDA     2,X             ; Get 8-bit offset
6450 e98a 17 fa ae           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6451 e98d 17 fa f1           [ 9 ]         LBSR    PrintByte       ; Display it
6452 e990 17 fa b1           [ 9 ]         LBSR    PrintComma      ; Print comma
6453 e993 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6454 e996 17 00 fb           [ 9 ]         LBSR    PrintRegister   ; Print register name
6455 e999 17 fa ba           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6456 e99c 16 01 16           [ 5 ]         LBRA    done
6457                               ind16:
6458 e99f 81 99              [ 2 ]         CMPA    #%10011001      ; Check against pattern
6459 e9a1 26 20              [ 3 ]         BNE     ind17
6460                                                               ; Format is 1RR11001  [n,R]
6461 e9a3 17 fa a7           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6462 e9a6 ae 8d 94 80        [10 ]         LDX     ADRS,PCR
6463 e9aa ec 02              [ 6 ]         LDD     2,X             ; Get 16-bit offset
6464 e9ac 1f 01              [ 6 ]         TFR     D,X
6465 e9ae 17 fa 8a           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6466 e9b1 17 fa db           [ 9 ]         LBSR    PrintAddress    ; Display it
6467 e9b4 17 fa 8d           [ 9 ]         LBSR    PrintComma      ; Print comma
6468 e9b7 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6469 e9ba 17 00 d7           [ 9 ]         LBSR    PrintRegister   ; Print register name
6470 e9bd 17 fa 96           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6471 e9c0 16 00 f2           [ 5 ]         LBRA    done
6472                               ind17:
6473 e9c3 81 96              [ 2 ]         CMPA    #%10010110      ; Check against pattern
6474 e9c5 26 17              [ 3 ]         BNE     ind18
6475                                                               ; Format is 1RR10110  [A,R]
6476 e9c7 17 fa 83           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6477 e9ca 86 41              [ 2 ]         LDA     #'A
6478 e9cc 17 fa ac           [ 9 ]         LBSR    PrintChar       ; Print A
6479 e9cf 17 fa 72           [ 9 ] comrb:  LBSR    PrintComma      ; Print comma
6480 e9d2 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6481 e9d5 17 00 bc           [ 9 ]         LBSR    PrintRegister   ; Print register name
6482 e9d8 17 fa 7b           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6483 e9db 16 00 d7           [ 5 ]         LBRA    done
6484                               ind18:
6485 e9de 81 95              [ 2 ]         CMPA    #%10010101      ; Check against pattern
6486 e9e0 26 0a              [ 3 ]         BNE     ind19
6487                                                               ; Format is 1RR10101  [B,R]
6488 e9e2 17 fa 68           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6489 e9e5 86 42              [ 2 ]         LDA     #'B
6490 e9e7 17 fa 91           [ 9 ]         LBSR    PrintChar
6491 e9ea 20 e3              [ 3 ]         BRA     comrb
6492                               ind19:
6493 e9ec 81 9b              [ 2 ]         CMPA    #%10011011      ; Check against pattern
6494 e9ee 26 0a              [ 3 ]         BNE     ind20
6495                                                               ; Format is 1RR11011  [D,R]
6496 e9f0 17 fa 5a           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6497 e9f3 86 44              [ 2 ]         LDA     #'D
6498 e9f5 17 fa 83           [ 9 ]         LBSR    PrintChar
6499 e9f8 20 d5              [ 3 ]         BRA     comrb
6500                               ind20:
6501 e9fa 81 91              [ 2 ]         CMPA    #%10010001      ; Check against pattern
6502 e9fc 26 1a              [ 3 ]         BNE     ind21
6503                                                               ; Format is 1RR10001  [,R++]
6504 e9fe 17 fa 4c           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6505 ea01 17 fa 40           [ 9 ]         LBSR    PrintComma      ; Print comma
6506 ea04 b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6507 ea07 17 00 8a           [ 9 ]         LBSR    PrintRegister   ; Print register name
6508 ea0a 86 2b              [ 2 ]         LDA     #'+             ; Print plus twice
6509 ea0c 17 fa 6c           [ 9 ]         LBSR    PrintChar
6510 ea0f 17 fa 69           [ 9 ]         LBSR    PrintChar
6511 ea12 17 fa 41           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6512 ea15 16 00 9d           [ 5 ]         LBRA    done
6513                               ind21:
6514 ea18 81 93              [ 2 ]         CMPA    #%10010011      ; Check against pattern
6515 ea1a 26 1a              [ 3 ]         BNE     ind22
6516                                                               ; Format is 1RR10011  [,--R]
6517 ea1c 17 fa 2e           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6518 ea1f 17 fa 22           [ 9 ]         LBSR    PrintComma      ; Print comma
6519 ea22 86 2d              [ 2 ]         LDA     #'-             ; Print minus twice
6520 ea24 17 fa 54           [ 9 ]         LBSR    PrintChar
6521 ea27 17 fa 51           [ 9 ]         LBSR    PrintChar
6522 ea2a b6 7e 2f           [ 5 ]         LDA     POSTBYT         ; Get postbyte again
6523 ea2d 17 00 64           [ 9 ]         LBSR    PrintRegister   ; Print register name
6524 ea30 17 fa 23           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6525 ea33 16 00 7f           [ 5 ]         LBRA    done
6526                               ind22:
6527 ea36 81 9c              [ 2 ]         CMPA    #%10011100      ; Check against pattern
6528 ea38 26 1b              [ 3 ]         BNE     ind23
6529                                                               ; Format is 1xx11100  [n,PCR]
6530 ea3a 17 fa 10           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6531 ea3d ae 8d 93 e9        [10 ]         LDX     ADRS,PCR
6532 ea41 a6 02              [ 5 ]         LDA     2,X             ; Get 8-bit offset
6533 ea43 17 f9 f5           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6534 ea46 17 fa 38           [ 9 ]         LBSR    PrintByte       ; Display it
6535 ea49 17 f9 f8           [ 9 ]         LBSR    PrintComma      ; Print comma
6536 ea4c 17 00 5e           [ 9 ]         LBSR    PrintPCR        ; Print PCR
6537 ea4f 17 fa 04           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6538 ea52 16 00 60           [ 5 ]         LBRA    done
6539                               ind23:
6540 ea55 81 9d              [ 2 ]         CMPA    #%10011101      ; Check against pattern
6541 ea57 26 1d              [ 3 ]         BNE     ind24
6542                                                               ; Format is 1xx11101  [n,PCR]
6543 ea59 17 f9 f1           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6544 ea5c ae 8d 93 ca        [10 ]         LDX     ADRS,PCR
6545 ea60 ec 02              [ 6 ]         LDD     2,X             ; Get 16-bit offset
6546 ea62 1f 01              [ 6 ]         TFR     D,X
6547 ea64 17 f9 d4           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6548 ea67 17 fa 25           [ 9 ]         LBSR    PrintAddress    ; Display it
6549 ea6a 17 f9 d7           [ 9 ]         LBSR    PrintComma      ; Print comma
6550 ea6d 17 00 3d           [ 9 ]         LBSR    PrintPCR        ; Print PCR
6551 ea70 17 f9 e3           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6552 ea73 16 00 3f           [ 5 ]         LBRA    done
6553                               ind24:
6554 ea76 81 9f              [ 2 ]         CMPA    #%10011111      ; Check against pattern
6555 ea78 26 17              [ 3 ]         BNE     ind25
6556                                                               ; Format is 1xx11111  [n]
6557 ea7a 17 f9 d0           [ 9 ]         LBSR    PrintLBracket   ; Print left bracket
6558 ea7d ae 8d 93 a9        [10 ]         LDX     ADRS,PCR
6559 ea81 ec 02              [ 6 ]         LDD     2,X             ; Get 16-bit offset
6560 ea83 1f 01              [ 6 ]         TFR     D,X
6561 ea85 17 f9 b3           [ 9 ]         LBSR    PrintDollar     ; Dollar sign
6562 ea88 17 fa 04           [ 9 ]         LBSR    PrintAddress    ; Display it
6563 ea8b 17 f9 c8           [ 9 ]         LBSR    PrintRBracket   ; Print right bracket
6564 ea8e 16 00 24           [ 5 ]         LBRA    done
6565                               ind25:                          ; Should never be reached
6566 ea91 16 00 21           [ 5 ]         LBRA    done
6567                               
6568                               ; Print register name encoded in bits 5 and 6 of A for indexed
6569                               ; addressing: xRRxxxxx where RR: 00=X 01=Y 10=U 11=S
6570                               ; Registers changed: X
6571                               PrintRegister:
6572 ea94 34 02              [ 6 ]         PSHS    A               ; Save A
6573 ea96 84 60              [ 2 ]         ANDA    #%01100000      ; Mask out other bits
6574 ea98 44                 [ 2 ]         LSRA                    ; Shift into 2 LSB
6575 ea99 44                 [ 2 ]         LSRA
6576 ea9a 44                 [ 2 ]         LSRA
6577 ea9b 44                 [ 2 ]         LSRA
6578 ea9c 44                 [ 2 ]         LSRA
6579 ea9d 30 8d 00 08        [ 9 ]         LEAX    REGTABLE,PCR    ; Lookup table of register name characters
6580 eaa1 a6 86              [ 5 ]         LDA     A,X             ; Get character
6581 eaa3 17 f9 d5           [ 9 ]         LBSR    PrintChar       ; Print it
6582 eaa6 35 02              [ 6 ]         PULS    A               ; Restore A
6583 eaa8 39                 [ 5 ]         RTS                     ; Return
6584                               REGTABLE:
6585 eaa9 58 59 55 53                      FCC     "XYUS"
6586                               
6587                               
6588                               ; Print the string "PCR" on the console.
6589                               ; Registers changed: X
6590                               PrintPCR:
6591 eaad 30 8d 05 1c        [ 9 ]         LEAX    MSG3,PCR        ; "PCR" string
6592 eab1 17 f9 e9           [ 9 ]         LBSR    PrintString
6593 eab4 39                 [ 5 ]         RTS
6594                               
6595                               ; Print final CR
6596                               
6597 eab5 17 f9 76           [ 9 ] done:   LBSR    PrintCR
6598                               
6599                               ; Update address to next instruction
6600                               ; If it was a page 2/3 instruction, we need to subtract one from the
6601                               ; length to account for ADRS being moved to the second byte of the
6602                               ; instruction.
6603                               
6604 eab8 7d 7e 36           [ 7 ]         TST     PAGE23          ; Flag set
6605 eabb 27 03              [ 3 ]         BEQ     not23           ; Branch if not
6606 eabd 7a 7e 30           [ 7 ]         DEC     LENG            ; Decrement length
6607 eac0 4f                 [ 2 ] not23:  CLRA                    ; Clear MSB of D
6608 eac1 f6 7e 30           [ 5 ]         LDB     LENG            ; Get length byte in LSB of D
6609 eac4 f3 7e 2a           [ 7 ]         ADDD    ADRS            ; Add to address
6610 eac7 fd 7e 2a           [ 6 ]         STD     ADRS            ; Write new address
6611                               
6612                               ; Return
6613 eaca 39                 [ 5 ]         RTS
6614                               
6615                               ; *** DATA
6616                               
6617                               ; Table of instruction strings. 4 bytes per table entry
6618                               MNEMONICS:
6619 eacb 3f 3f 3f 20                      FCC     "??? "          ; $00
6620 eacf 41 42 58 20                      FCC     "ABX "          ; $01
6621 ead3 41 44 43 41                      FCC     "ADCA"          ; $02
6622 ead7 41 44 43 42                      FCC     "ADCB"          ; $03
6623 eadb 41 44 44 41                      FCC     "ADDA"          ; $04
6624 eadf 41 44 44 42                      FCC     "ADDB"          ; $05
6625 eae3 41 44 44 44                      FCC     "ADDD"          ; $06
6626 eae7 41 4e 44 41                      FCC     "ANDA"          ; $07
6627 eaeb 41 4e 44 42                      FCC     "ANDB"          ; $08
6628 eaef 41 4e 44 43                      FCC     "ANDC"          ; $09 Should really  be "ANDCC"
6629 eaf3 41 53 4c 20                      FCC     "ASL "          ; $0A
6630 eaf7 41 53 4c 41                      FCC     "ASLA"          ; $0B
6631 eafb 41 53 4c 42                      FCC     "ASLB"          ; $0C
6632 eaff 41 53 52 20                      FCC     "ASR "          ; $0D
6633 eb03 41 53 52 41                      FCC     "ASRA"          ; $0E
6634 eb07 41 53 52 42                      FCC     "ASRB"          ; $0F
6635 eb0b 42 43 43 20                      FCC     "BCC "          ; $10
6636 eb0f 42 43 53 20                      FCC     "BCS "          ; $11
6637 eb13 42 45 51 20                      FCC     "BEQ "          ; $12
6638 eb17 42 47 45 20                      FCC     "BGE "          ; $13
6639 eb1b 42 47 54 20                      FCC     "BGT "          ; $14
6640 eb1f 42 48 49 20                      FCC     "BHI "          ; $15
6641 eb23 42 49 54 41                      FCC     "BITA"          ; $16
6642 eb27 42 49 54 42                      FCC     "BITB"          ; $17
6643 eb2b 42 4c 45 20                      FCC     "BLE "          ; $18
6644 eb2f 42 4c 53 20                      FCC     "BLS "          ; $19
6645 eb33 42 4c 54 20                      FCC     "BLT "          ; $1A
6646 eb37 42 4d 49 20                      FCC     "BMI "          ; $1B
6647 eb3b 42 4e 45 20                      FCC     "BNE "          ; $1C
6648 eb3f 42 50 4c 20                      FCC     "BPL "          ; $1D
6649 eb43 42 52 41 20                      FCC     "BRA "          ; $1E
6650 eb47 42 52 4e 20                      FCC     "BRN "          ; $1F
6651 eb4b 42 53 52 20                      FCC     "BSR "          ; $20
6652 eb4f 42 56 43 20                      FCC     "BVC "          ; $21
6653 eb53 42 56 53 20                      FCC     "BVS "          ; $22
6654 eb57 43 4c 52 20                      FCC     "CLR "          ; $23
6655 eb5b 43 4c 52 41                      FCC     "CLRA"          ; $24
6656 eb5f 43 4c 52 42                      FCC     "CLRB"          ; $25
6657 eb63 43 4d 50 41                      FCC     "CMPA"          ; $26
6658 eb67 43 4d 50 42                      FCC     "CMPB"          ; $27
6659 eb6b 43 4d 50 44                      FCC     "CMPD"          ; $28
6660 eb6f 43 4d 50 53                      FCC     "CMPS"          ; $29
6661 eb73 43 4d 50 55                      FCC     "CMPU"          ; $2A
6662 eb77 43 4d 50 58                      FCC     "CMPX"          ; $2B
6663 eb7b 43 4d 50 59                      FCC     "CMPY"          ; $2C
6664 eb7f 43 4f 4d 41                      FCC     "COMA"          ; $2D
6665 eb83 43 4f 4d 42                      FCC     "COMB"          ; $2E
6666 eb87 43 4f 4d 20                      FCC     "COM "          ; $2F
6667 eb8b 43 57 41 49                      FCC     "CWAI"          ; $30
6668 eb8f 44 41 41 20                      FCC     "DAA "          ; $31
6669 eb93 44 45 43 20                      FCC     "DEC "          ; $32
6670 eb97 44 45 43 41                      FCC     "DECA"          ; $33
6671 eb9b 44 45 43 42                      FCC     "DECB"          ; $34
6672 eb9f 45 4f 52 41                      FCC     "EORA"          ; $35
6673 eba3 45 4f 52 42                      FCC     "EORB"          ; $36
6674 eba7 45 58 47 20                      FCC     "EXG "          ; $37
6675 ebab 49 4e 43 20                      FCC     "INC "          ; $38
6676 ebaf 49 4e 43 41                      FCC     "INCA"          ; $39
6677 ebb3 49 4e 43 42                      FCC     "INCB"          ; $3A
6678 ebb7 4a 4d 50 20                      FCC     "JMP "          ; $3B
6679 ebbb 4a 53 52 20                      FCC     "JSR "          ; $3C
6680 ebbf 4c 42 43 43                      FCC     "LBCC"          ; $3D
6681 ebc3 4c 42 43 53                      FCC     "LBCS"          ; $3E
6682 ebc7 4c 42 45 51                      FCC     "LBEQ"          ; $3F
6683 ebcb 4c 42 47 45                      FCC     "LBGE"          ; $40
6684 ebcf 4c 42 47 54                      FCC     "LBGT"          ; $41
6685 ebd3 4c 42 48 49                      FCC     "LBHI"          ; $42
6686 ebd7 4c 42 4c 45                      FCC     "LBLE"          ; $43
6687 ebdb 4c 42 4c 53                      FCC     "LBLS"          ; $44
6688 ebdf 4c 42 4c 54                      FCC     "LBLT"          ; $45
6689 ebe3 4c 42 4d 49                      FCC     "LBMI"          ; $46
6690 ebe7 4c 42 4e 45                      FCC     "LBNE"          ; $47
6691 ebeb 4c 42 50 4c                      FCC     "LBPL"          ; $48
6692 ebef 4c 42 52 41                      FCC     "LBRA"          ; $49
6693 ebf3 4c 42 52 4e                      FCC     "LBRN"          ; $4A
6694 ebf7 4c 42 53 52                      FCC     "LBSR"          ; $4B
6695 ebfb 4c 42 56 43                      FCC     "LBVC"          ; $4C
6696 ebff 4c 42 56 53                      FCC     "LBVS"          ; $4D
6697 ec03 4c 44 41 20                      FCC     "LDA "          ; $4E
6698 ec07 4c 44 42 20                      FCC     "LDB "          ; $4F
6699 ec0b 4c 44 44 20                      FCC     "LDD "          ; $50
6700 ec0f 4c 44 53 20                      FCC     "LDS "          ; $51
6701 ec13 4c 44 55 20                      FCC     "LDU "          ; $52
6702 ec17 4c 44 58 20                      FCC     "LDX "          ; $53
6703 ec1b 4c 44 59 20                      FCC     "LDY "          ; $54
6704 ec1f 4c 45 41 53                      FCC     "LEAS"          ; $55
6705 ec23 4c 45 41 55                      FCC     "LEAU"          ; $56
6706 ec27 4c 45 41 58                      FCC     "LEAX"          ; $57
6707 ec2b 4c 45 41 59                      FCC     "LEAY"          ; $58
6708 ec2f 4c 53 52 20                      FCC     "LSR "          ; $59
6709 ec33 4c 53 52 41                      FCC     "LSRA"          ; $5A
6710 ec37 4c 53 52 42                      FCC     "LSRB"          ; $5B
6711 ec3b 4d 55 4c 20                      FCC     "MUL "          ; $5C
6712 ec3f 4e 45 47 20                      FCC     "NEG "          ; $5D
6713 ec43 4e 45 47 41                      FCC     "NEGA"          ; $5E
6714 ec47 4e 45 47 42                      FCC     "NEGB"          ; $5F
6715 ec4b 4e 4f 50 20                      FCC     "NOP "          ; $60
6716 ec4f 4f 52 41 20                      FCC     "ORA "          ; $61
6717 ec53 4f 52 42 20                      FCC     "ORB "          ; $62
6718 ec57 4f 52 43 43                      FCC     "ORCC"          ; $63
6719 ec5b 50 53 48 53                      FCC     "PSHS"          ; $64
6720 ec5f 50 53 48 55                      FCC     "PSHU"          ; $65
6721 ec63 50 55 4c 53                      FCC     "PULS"          ; $66
6722 ec67 50 55 4c 55                      FCC     "PULU"          ; $67
6723 ec6b 52 4f 4c 20                      FCC     "ROL "          ; $68
6724 ec6f 52 4f 4c 41                      FCC     "ROLA"          ; $69
6725 ec73 52 4f 4c 42                      FCC     "ROLB"          ; $6A
6726 ec77 52 4f 52 20                      FCC     "ROR "          ; $6B
6727 ec7b 52 4f 52 41                      FCC     "RORA"          ; $6C
6728 ec7f 52 4f 52 42                      FCC     "RORB"          ; $6D
6729 ec83 52 54 49 20                      FCC     "RTI "          ; $6E
6730 ec87 52 54 53 20                      FCC     "RTS "          ; $6F
6731 ec8b 53 42 43 41                      FCC     "SBCA"          ; $70
6732 ec8f 53 42 43 42                      FCC     "SBCB"          ; $71
6733 ec93 53 45 58 20                      FCC     "SEX "          ; $72
6734 ec97 53 54 41 20                      FCC     "STA "          ; $73
6735 ec9b 53 54 42 20                      FCC     "STB "          ; $74
6736 ec9f 53 54 44 20                      FCC     "STD "          ; $75
6737 eca3 53 54 53 20                      FCC     "STS "          ; $76
6738 eca7 53 54 55 20                      FCC     "STU "          ; $77
6739 ecab 53 54 58 20                      FCC     "STX "          ; $78
6740 ecaf 53 54 59 20                      FCC     "STY "          ; $79
6741 ecb3 53 55 42 41                      FCC     "SUBA"          ; $7A
6742 ecb7 53 55 42 42                      FCC     "SUBB"          ; $7B
6743 ecbb 53 55 42 44                      FCC     "SUBD"          ; $7C
6744 ecbf 53 57 49 20                      FCC     "SWI "          ; $7D
6745 ecc3 53 57 49 32                      FCC     "SWI2"          ; $7E
6746 ecc7 53 57 49 33                      FCC     "SWI3"          ; $7F
6747 eccb 53 59 4e 43                      FCC     "SYNC"          ; $80
6748 eccf 54 46 52 20                      FCC     "TFR "          ; $81
6749 ecd3 54 53 54 20                      FCC     "TST "          ; $82
6750 ecd7 54 53 54 41                      FCC     "TSTA"          ; $83
6751 ecdb 54 53 54 42                      FCC     "TSTB"          ; $84
6752                               
6753                               ; Lengths of instructions given an addressing mode. Matches values of
6754                               ; AM_* Indexed addessing instructions length can increase due to post
6755                               ; byte.
6756                               LENGTHS:
6757 ecdf 01                               FCB     1               ; 0 AM_INVALID
6758 ece0 01                               FCB     1               ; 1 AM_INHERENT
6759 ece1 02                               FCB     2               ; 2 AM_IMMEDIATE8
6760 ece2 03                               FCB     3               ; 3 AM_IMMEDIATE16
6761 ece3 02                               FCB     2               ; 4 AM_DIRECT
6762 ece4 03                               FCB     3               ; 5 AM_EXTENDED
6763 ece5 02                               FCB     2               ; 6 AM_RELATIVE8
6764 ece6 03                               FCB     3               ; 7 AM_RELATIVE16
6765 ece7 02                               FCB     2               ; 8 AM_INDEXED
6766                               
6767                               ; Lookup table to return needed remaining spaces to print to pad out
6768                               ; instruction to correct column in disassembly.
6769                               ; # bytes: 1 2 3 4
6770                               ; Padding: 9 6 3 0
6771                               PADDING:
6772 ece8 0a 07 04 01                      FCB     10, 7, 4, 1
6773                               
6774                               ; Lookup table to return number of additional bytes for indexed
6775                               ; addressing based on low order 5 bits of postbyte. Based on
6776                               ; detailed list of values below.
6777                               
6778                               POSTBYTES:
6779 ecec 00 00 00 00 00 00                FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
6780 ecf4 01 02 00 00 01 02                FCB     1, 2, 0, 0, 1, 2, 0, 0
     00 00
6781 ecfc 00 00 00 00 00 00                FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
6782 ed04 01 02 00 00 01 02                FCB     1, 2, 0, 0, 1, 2, 0, 2
     00 02
6783                               
6784                               ; Pattern:  # Extra bytes:
6785                               ; --------  --------------
6786                               ; 0XXXXXXX   0
6787                               ; 1XX00000   0
6788                               ; 1XX00001   0
6789                               ; 1XX00010   0
6790                               ; 1XX00011   0
6791                               ; 1XX00100   0
6792                               ; 1X000101   0
6793                               ; 1XX00110   0
6794                               ; 1XX00111   0 (INVALID)
6795                               ; 1XX01000   1
6796                               ; 1XX01001   2
6797                               ; 1XX01010   0 (INVALID)
6798                               ; 1XX01011   0
6799                               ; 1XX01100   1
6800                               ; 1XX01101   2
6801                               ; 1XX01110   0 (INVALID)
6802                               ; 1XX01111   0 (INVALID)
6803                               ; 1XX10000   0 (INVALID)
6804                               ; 1XX10001   0
6805                               ; 1XX10010   0 (INVALID)
6806                               ; 1XX10011   0
6807                               ; 1XX10100   0
6808                               ; 1XX10101   0
6809                               ; 1XX10110   0
6810                               ; 1XX10111   0 (INVALID)
6811                               ; 1XX11000   1
6812                               ; 1XX11001   2
6813                               ; 1XX11010   0 (INVALID)
6814                               ; 1XX11011   0
6815                               ; 1XX11100   1
6816                               ; 1XX11101   2
6817                               ; 1XX11110   0 (INVALID)
6818                               ; 1XX11111   2
6819                               
6820                               ; Opcodes. Listed in order indexed by op code. Defines the mnemonic.
6821                               OPCODES:
6822 ed0c 5d                               FCB     OP_NEG          ; 00
6823 ed0d 00                               FCB     OP_INV          ; 01
6824 ed0e 00                               FCB     OP_INV          ; 02
6825 ed0f 2e                               FCB     OP_COMB         ; 03
6826 ed10 59                               FCB     OP_LSR          ; 04
6827 ed11 00                               FCB     OP_INV          ; 05
6828 ed12 6b                               FCB     OP_ROR          ; 06
6829 ed13 0d                               FCB     OP_ASR          ; 07
6830 ed14 0a                               FCB     OP_ASL          ; 08
6831 ed15 68                               FCB     OP_ROL          ; 09
6832 ed16 32                               FCB     OP_DEC          ; 0A
6833 ed17 00                               FCB     OP_INV          ; 0B
6834 ed18 38                               FCB     OP_INC          ; 0C
6835 ed19 82                               FCB     OP_TST          ; 0D
6836 ed1a 3b                               FCB     OP_JMP          ; 0E
6837 ed1b 23                               FCB     OP_CLR          ; 0F
6838                               
6839 ed1c 00                               FCB     OP_INV          ; 10 Page 2 extended opcodes (see other table)
6840 ed1d 00                               FCB     OP_INV          ; 11 Page 3 extended opcodes (see other table)
6841 ed1e 60                               FCB     OP_NOP          ; 12
6842 ed1f 80                               FCB     OP_SYNC         ; 13
6843 ed20 00                               FCB     OP_INV          ; 14
6844 ed21 00                               FCB     OP_INV          ; 15
6845 ed22 49                               FCB     OP_LBRA         ; 16
6846 ed23 4b                               FCB     OP_LBSR         ; 17
6847 ed24 00                               FCB     OP_INV          ; 18
6848 ed25 31                               FCB     OP_DAA          ; 19
6849 ed26 63                               FCB     OP_ORCC         ; 1A
6850 ed27 00                               FCB     OP_INV          ; 1B
6851 ed28 09                               FCB     OP_ANDCC        ; 1C
6852 ed29 72                               FCB     OP_SEX          ; 1D
6853 ed2a 37                               FCB     OP_EXG          ; 1E
6854 ed2b 81                               FCB     OP_TFR          ; 1F
6855                               
6856 ed2c 1e                               FCB     OP_BRA          ; 20
6857 ed2d 1f                               FCB     OP_BRN          ; 21
6858 ed2e 15                               FCB     OP_BHI          ; 22
6859 ed2f 19                               FCB     OP_BLS          ; 23
6860 ed30 10                               FCB     OP_BCC          ; 24
6861 ed31 11                               FCB     OP_BCS          ; 25
6862 ed32 1c                               FCB     OP_BNE          ; 26
6863 ed33 12                               FCB     OP_BEQ          ; 27
6864 ed34 21                               FCB     OP_BVC          ; 28
6865 ed35 22                               FCB     OP_BVS          ; 29
6866 ed36 1d                               FCB     OP_BPL          ; 2A
6867 ed37 1b                               FCB     OP_BMI          ; 2B
6868 ed38 13                               FCB     OP_BGE          ; 2C
6869 ed39 1a                               FCB     OP_BLT          ; 2D
6870 ed3a 14                               FCB     OP_BGT          ; 2E
6871 ed3b 18                               FCB     OP_BLE          ; 2F
6872                               
6873 ed3c 57                               FCB     OP_LEAX         ; 30
6874 ed3d 58                               FCB     OP_LEAY         ; 31
6875 ed3e 55                               FCB     OP_LEAS         ; 32
6876 ed3f 56                               FCB     OP_LEAU         ; 33
6877 ed40 64                               FCB     OP_PSHS         ; 34
6878 ed41 66                               FCB     OP_PULS         ; 35
6879 ed42 65                               FCB     OP_PSHU         ; 36
6880 ed43 67                               FCB     OP_PULU         ; 37
6881 ed44 00                               FCB     OP_INV          ; 38
6882 ed45 6f                               FCB     OP_RTS          ; 39
6883 ed46 01                               FCB     OP_ABX          ; 3A
6884 ed47 6e                               FCB     OP_RTI          ; 3B
6885 ed48 30                               FCB     OP_CWAI         ; 3C
6886 ed49 5c                               FCB     OP_MUL          ; 3D
6887 ed4a 00                               FCB     OP_INV          ; 3E
6888 ed4b 7d                               FCB     OP_SWI          ; 3F
6889                               
6890 ed4c 5e                               FCB     OP_NEGA         ; 40
6891 ed4d 00                               FCB     OP_INV          ; 41
6892 ed4e 00                               FCB     OP_INV          ; 42
6893 ed4f 2d                               FCB     OP_COMA         ; 43
6894 ed50 5a                               FCB     OP_LSRA         ; 44
6895 ed51 00                               FCB     OP_INV          ; 45
6896 ed52 6c                               FCB     OP_RORA         ; 46
6897 ed53 0e                               FCB     OP_ASRA         ; 47
6898 ed54 0b                               FCB     OP_ASLA         ; 48
6899 ed55 69                               FCB     OP_ROLA         ; 49
6900 ed56 33                               FCB     OP_DECA         ; 4A
6901 ed57 00                               FCB     OP_INV          ; 4B
6902 ed58 39                               FCB     OP_INCA         ; 4C
6903 ed59 83                               FCB     OP_TSTA         ; 4D
6904 ed5a 00                               FCB     OP_INV          ; 4E
6905 ed5b 24                               FCB     OP_CLRA         ; 4F
6906                               
6907 ed5c 5f                               FCB     OP_NEGB         ; 50
6908 ed5d 00                               FCB     OP_INV          ; 51
6909 ed5e 00                               FCB     OP_INV          ; 52
6910 ed5f 2e                               FCB     OP_COMB         ; 53
6911 ed60 5b                               FCB     OP_LSRB         ; 54
6912 ed61 00                               FCB     OP_INV          ; 55
6913 ed62 6d                               FCB     OP_RORB         ; 56
6914 ed63 0f                               FCB     OP_ASRB         ; 57
6915 ed64 0c                               FCB     OP_ASLB         ; 58
6916 ed65 6a                               FCB     OP_ROLB         ; 59
6917 ed66 34                               FCB     OP_DECB         ; 5A
6918 ed67 00                               FCB     OP_INV          ; 5B
6919 ed68 3a                               FCB     OP_INCB         ; 5C
6920 ed69 84                               FCB     OP_TSTB         ; 5D
6921 ed6a 00                               FCB     OP_INV          ; 5E
6922 ed6b 25                               FCB     OP_CLRB         ; 5F
6923                               
6924 ed6c 5d                               FCB     OP_NEG          ; 60
6925 ed6d 00                               FCB     OP_INV          ; 61
6926 ed6e 00                               FCB     OP_INV          ; 62
6927 ed6f 2f                               FCB     OP_COM          ; 63
6928 ed70 59                               FCB     OP_LSR          ; 64
6929 ed71 00                               FCB     OP_INV          ; 65
6930 ed72 6b                               FCB     OP_ROR          ; 66
6931 ed73 0d                               FCB     OP_ASR          ; 67
6932 ed74 0a                               FCB     OP_ASL          ; 68
6933 ed75 68                               FCB     OP_ROL          ; 69
6934 ed76 32                               FCB     OP_DEC          ; 6A
6935 ed77 00                               FCB     OP_INV          ; 6B
6936 ed78 38                               FCB     OP_INC          ; 6C
6937 ed79 82                               FCB     OP_TST          ; 6D
6938 ed7a 3b                               FCB     OP_JMP          ; 6E
6939 ed7b 23                               FCB     OP_CLR          ; 6F
6940                               
6941 ed7c 5d                               FCB     OP_NEG          ; 70
6942 ed7d 00                               FCB     OP_INV          ; 71
6943 ed7e 00                               FCB     OP_INV          ; 72
6944 ed7f 2f                               FCB     OP_COM          ; 73
6945 ed80 59                               FCB     OP_LSR          ; 74
6946 ed81 00                               FCB     OP_INV          ; 75
6947 ed82 6b                               FCB     OP_ROR          ; 76
6948 ed83 0d                               FCB     OP_ASR          ; 77
6949 ed84 0a                               FCB     OP_ASL          ; 78
6950 ed85 68                               FCB     OP_ROL          ; 79
6951 ed86 32                               FCB     OP_DEC          ; 7A
6952 ed87 00                               FCB     OP_INV          ; 7B
6953 ed88 38                               FCB     OP_INC          ; 7C
6954 ed89 82                               FCB     OP_TST          ; 7D
6955 ed8a 3b                               FCB     OP_JMP          ; 7E
6956 ed8b 23                               FCB     OP_CLR          ; 7F
6957                               
6958 ed8c 7a                               FCB     OP_SUBA         ; 80
6959 ed8d 26                               FCB     OP_CMPA         ; 81
6960 ed8e 70                               FCB     OP_SBCA         ; 82
6961 ed8f 7c                               FCB     OP_SUBD         ; 83
6962 ed90 07                               FCB     OP_ANDA         ; 84
6963 ed91 16                               FCB     OP_BITA         ; 85
6964 ed92 4e                               FCB     OP_LDA          ; 86
6965 ed93 00                               FCB     OP_INV          ; 87
6966 ed94 35                               FCB     OP_EORA         ; 88
6967 ed95 02                               FCB     OP_ADCA         ; 89
6968 ed96 61                               FCB     OP_ORA          ; 8A
6969 ed97 04                               FCB     OP_ADDA         ; 8B
6970 ed98 2b                               FCB     OP_CMPX         ; 8C
6971 ed99 20                               FCB     OP_BSR          ; 8D
6972 ed9a 53                               FCB     OP_LDX          ; 8E
6973 ed9b 00                               FCB     OP_INV          ; 8F
6974                               
6975 ed9c 7a                               FCB     OP_SUBA         ; 90
6976 ed9d 26                               FCB     OP_CMPA         ; 91
6977 ed9e 70                               FCB     OP_SBCA         ; 92
6978 ed9f 7c                               FCB     OP_SUBD         ; 93
6979 eda0 07                               FCB     OP_ANDA         ; 94
6980 eda1 16                               FCB     OP_BITA         ; 95
6981 eda2 4e                               FCB     OP_LDA          ; 96
6982 eda3 73                               FCB     OP_STA          ; 97
6983 eda4 35                               FCB     OP_EORA         ; 98
6984 eda5 02                               FCB     OP_ADCA         ; 99
6985 eda6 61                               FCB     OP_ORA          ; 9A
6986 eda7 04                               FCB     OP_ADDA         ; 9B
6987 eda8 2b                               FCB     OP_CMPX         ; 9C
6988 eda9 3c                               FCB     OP_JSR          ; 9D
6989 edaa 53                               FCB     OP_LDX          ; 9E
6990 edab 78                               FCB     OP_STX          ; 9F
6991                               
6992 edac 7a                               FCB     OP_SUBA         ; A0
6993 edad 26                               FCB     OP_CMPA         ; A1
6994 edae 70                               FCB     OP_SBCA         ; A2
6995 edaf 7c                               FCB     OP_SUBD         ; A3
6996 edb0 07                               FCB     OP_ANDA         ; A4
6997 edb1 16                               FCB     OP_BITA         ; A5
6998 edb2 4e                               FCB     OP_LDA          ; A6
6999 edb3 73                               FCB     OP_STA          ; A7
7000 edb4 35                               FCB     OP_EORA         ; A8
7001 edb5 02                               FCB     OP_ADCA         ; A9
7002 edb6 61                               FCB     OP_ORA          ; AA
7003 edb7 04                               FCB     OP_ADDA         ; AB
7004 edb8 2b                               FCB     OP_CMPX         ; AC
7005 edb9 3c                               FCB     OP_JSR          ; AD
7006 edba 53                               FCB     OP_LDX          ; AE
7007 edbb 78                               FCB     OP_STX          ; AF
7008                               
7009 edbc 7a                               FCB     OP_SUBA         ; B0
7010 edbd 26                               FCB     OP_CMPA         ; B1
7011 edbe 70                               FCB     OP_SBCA         ; B2
7012 edbf 7c                               FCB     OP_SUBD         ; B3
7013 edc0 07                               FCB     OP_ANDA         ; B4
7014 edc1 16                               FCB     OP_BITA         ; B5
7015 edc2 4e                               FCB     OP_LDA          ; B6
7016 edc3 73                               FCB     OP_STA          ; B7
7017 edc4 35                               FCB     OP_EORA         ; B8
7018 edc5 02                               FCB     OP_ADCA         ; B9
7019 edc6 61                               FCB     OP_ORA          ; BA
7020 edc7 04                               FCB     OP_ADDA         ; BB
7021 edc8 2b                               FCB     OP_CMPX         ; BC
7022 edc9 3c                               FCB     OP_JSR          ; BD
7023 edca 53                               FCB     OP_LDX          ; BE
7024 edcb 78                               FCB     OP_STX          ; BF
7025                               
7026 edcc 7b                               FCB     OP_SUBB         ; C0
7027 edcd 27                               FCB     OP_CMPB         ; C1
7028 edce 71                               FCB     OP_SBCB         ; C2
7029 edcf 06                               FCB     OP_ADDD         ; C3
7030 edd0 08                               FCB     OP_ANDB         ; C4
7031 edd1 17                               FCB     OP_BITB         ; C5
7032 edd2 4f                               FCB     OP_LDB          ; C6
7033 edd3 00                               FCB     OP_INV          ; C7
7034 edd4 36                               FCB     OP_EORB         ; C8
7035 edd5 03                               FCB     OP_ADCB         ; C9
7036 edd6 62                               FCB     OP_ORB          ; CA
7037 edd7 05                               FCB     OP_ADDB         ; CB
7038 edd8 50                               FCB     OP_LDD          ; CC
7039 edd9 00                               FCB     OP_INV          ; CD
7040 edda 52                               FCB     OP_LDU          ; CE
7041 eddb 00                               FCB     OP_INV          ; CF
7042                               
7043 eddc 7b                               FCB     OP_SUBB         ; D0
7044 eddd 27                               FCB     OP_CMPB         ; D1
7045 edde 71                               FCB     OP_SBCB         ; D2
7046 eddf 06                               FCB     OP_ADDD         ; D3
7047 ede0 08                               FCB     OP_ANDB         ; D4
7048 ede1 17                               FCB     OP_BITB         ; D5
7049 ede2 4f                               FCB     OP_LDB          ; D6
7050 ede3 74                               FCB     OP_STB          ; D7
7051 ede4 36                               FCB     OP_EORB         ; D8
7052 ede5 03                               FCB     OP_ADCB         ; D9
7053 ede6 62                               FCB     OP_ORB          ; DA
7054 ede7 05                               FCB     OP_ADDB         ; DB
7055 ede8 50                               FCB     OP_LDD          ; DC
7056 ede9 75                               FCB     OP_STD          ; DD
7057 edea 52                               FCB     OP_LDU          ; DE
7058 edeb 77                               FCB     OP_STU          ; DF
7059                               
7060 edec 7b                               FCB     OP_SUBB         ; E0
7061 eded 27                               FCB     OP_CMPB         ; E1
7062 edee 71                               FCB     OP_SBCB         ; E2
7063 edef 06                               FCB     OP_ADDD         ; E3
7064 edf0 08                               FCB     OP_ANDB         ; E4
7065 edf1 17                               FCB     OP_BITB         ; E5
7066 edf2 4f                               FCB     OP_LDB          ; E6
7067 edf3 74                               FCB     OP_STB          ; E7
7068 edf4 36                               FCB     OP_EORB         ; E8
7069 edf5 03                               FCB     OP_ADCB         ; E9
7070 edf6 62                               FCB     OP_ORB          ; EA
7071 edf7 05                               FCB     OP_ADDB         ; EB
7072 edf8 50                               FCB     OP_LDD          ; EC
7073 edf9 75                               FCB     OP_STD          ; ED
7074 edfa 52                               FCB     OP_LDU          ; EE
7075 edfb 77                               FCB     OP_STU          ; EF
7076                               
7077 edfc 7b                               FCB     OP_SUBB         ; F0
7078 edfd 27                               FCB     OP_CMPB         ; F1
7079 edfe 71                               FCB     OP_SBCB         ; F2
7080 edff 06                               FCB     OP_ADDD         ; F3
7081 ee00 08                               FCB     OP_ANDB         ; F4
7082 ee01 17                               FCB     OP_BITB         ; F5
7083 ee02 4f                               FCB     OP_LDB          ; F6
7084 ee03 74                               FCB     OP_STB          ; F7
7085 ee04 36                               FCB     OP_EORB         ; F8
7086 ee05 03                               FCB     OP_ADCB         ; F9
7087 ee06 62                               FCB     OP_ORB          ; FA
7088 ee07 05                               FCB     OP_ADDB         ; FB
7089 ee08 50                               FCB     OP_LDD          ; FC
7090 ee09 75                               FCB     OP_STD          ; FD
7091 ee0a 52                               FCB     OP_LDU          ; FE
7092 ee0b 77                               FCB     OP_STU          ; FF
7093                               
7094                               ; Table of addressing modes. Listed in order,indexed by op code.
7095                               MODES:
7096 ee0c 04                               FCB     AM_DIRECT       ; 00
7097 ee0d 00                               FCB     AM_INVALID      ; 01
7098 ee0e 00                               FCB     AM_INVALID      ; 02
7099 ee0f 04                               FCB     AM_DIRECT       ; 03
7100 ee10 04                               FCB     AM_DIRECT       ; 04
7101 ee11 00                               FCB     AM_INVALID      ; 05
7102 ee12 04                               FCB     AM_DIRECT       ; 06
7103 ee13 04                               FCB     AM_DIRECT       ; 07
7104 ee14 04                               FCB     AM_DIRECT       ; 08
7105 ee15 04                               FCB     AM_DIRECT       ; 09
7106 ee16 04                               FCB     AM_DIRECT       ; 0A
7107 ee17 00                               FCB     AM_INVALID      ; 0B
7108 ee18 04                               FCB     AM_DIRECT       ; 0C
7109 ee19 04                               FCB     AM_DIRECT       ; 0D
7110 ee1a 04                               FCB     AM_DIRECT       ; 0E
7111 ee1b 04                               FCB     AM_DIRECT       ; 0F
7112                               
7113 ee1c 00                               FCB     AM_INVALID      ; 10 Page 2 extended opcodes (see other table)
7114 ee1d 00                               FCB     AM_INVALID      ; 11 Page 3 extended opcodes (see other table)
7115 ee1e 01                               FCB     AM_INHERENT     ; 12
7116 ee1f 01                               FCB     AM_INHERENT     ; 13
7117 ee20 00                               FCB     AM_INVALID      ; 14
7118 ee21 00                               FCB     AM_INVALID      ; 15
7119 ee22 07                               FCB     AM_RELATIVE16   ; 16
7120 ee23 07                               FCB     AM_RELATIVE16   ; 17
7121 ee24 00                               FCB     AM_INVALID      ; 18
7122 ee25 01                               FCB     AM_INHERENT     ; 19
7123 ee26 02                               FCB     AM_IMMEDIATE8   ; 1A
7124 ee27 00                               FCB     AM_INVALID      ; 1B
7125 ee28 02                               FCB     AM_IMMEDIATE8   ; 1C
7126 ee29 01                               FCB     AM_INHERENT     ; 1D
7127 ee2a 02                               FCB     AM_IMMEDIATE8   ; 1E
7128 ee2b 02                               FCB     AM_IMMEDIATE8   ; 1F
7129                               
7130 ee2c 06                               FCB     AM_RELATIVE8    ; 20
7131 ee2d 06                               FCB     AM_RELATIVE8    ; 21
7132 ee2e 06                               FCB     AM_RELATIVE8    ; 22
7133 ee2f 06                               FCB     AM_RELATIVE8    ; 23
7134 ee30 06                               FCB     AM_RELATIVE8    ; 24
7135 ee31 06                               FCB     AM_RELATIVE8    ; 25
7136 ee32 06                               FCB     AM_RELATIVE8    ; 26
7137 ee33 06                               FCB     AM_RELATIVE8    ; 27
7138 ee34 06                               FCB     AM_RELATIVE8    ; 28
7139 ee35 06                               FCB     AM_RELATIVE8    ; 29
7140 ee36 06                               FCB     AM_RELATIVE8    ; 2A
7141 ee37 06                               FCB     AM_RELATIVE8    ; 2B
7142 ee38 06                               FCB     AM_RELATIVE8    ; 2C
7143 ee39 06                               FCB     AM_RELATIVE8    ; 2D
7144 ee3a 06                               FCB     AM_RELATIVE8    ; 2E
7145 ee3b 06                               FCB     AM_RELATIVE8    ; 2F
7146                               
7147 ee3c 08                               FCB     AM_INDEXED      ; 30
7148 ee3d 08                               FCB     AM_INDEXED      ; 31
7149 ee3e 08                               FCB     AM_INDEXED      ; 32
7150 ee3f 08                               FCB     AM_INDEXED      ; 33
7151 ee40 02                               FCB     AM_IMMEDIATE8   ; 34
7152 ee41 02                               FCB     AM_IMMEDIATE8   ; 35
7153 ee42 02                               FCB     AM_IMMEDIATE8   ; 36
7154 ee43 02                               FCB     AM_IMMEDIATE8   ; 37
7155 ee44 00                               FCB     AM_INVALID      ; 38
7156 ee45 01                               FCB     AM_INHERENT     ; 39
7157 ee46 01                               FCB     AM_INHERENT     ; 3A
7158 ee47 01                               FCB     AM_INHERENT     ; 3B
7159 ee48 02                               FCB     AM_IMMEDIATE8   ; 3C
7160 ee49 01                               FCB     AM_INHERENT     ; 3D
7161 ee4a 00                               FCB     AM_INVALID      ; 3E
7162 ee4b 01                               FCB     AM_INHERENT     ; 3F
7163                               
7164 ee4c 01                               FCB     AM_INHERENT     ; 40
7165 ee4d 00                               FCB     AM_INVALID      ; 41
7166 ee4e 00                               FCB     AM_INVALID      ; 42
7167 ee4f 01                               FCB     AM_INHERENT     ; 43
7168 ee50 01                               FCB     AM_INHERENT     ; 44
7169 ee51 00                               FCB     AM_INVALID      ; 45
7170 ee52 01                               FCB     AM_INHERENT     ; 46
7171 ee53 01                               FCB     AM_INHERENT     ; 47
7172 ee54 01                               FCB     AM_INHERENT     ; 48
7173 ee55 01                               FCB     AM_INHERENT     ; 49
7174 ee56 01                               FCB     AM_INHERENT     ; 4A
7175 ee57 00                               FCB     AM_INVALID      ; 4B
7176 ee58 01                               FCB     AM_INHERENT     ; 4C
7177 ee59 01                               FCB     AM_INHERENT     ; 4D
7178 ee5a 00                               FCB     AM_INVALID      ; 4E
7179 ee5b 01                               FCB     AM_INHERENT     ; 4F
7180                               
7181 ee5c 01                               FCB     AM_INHERENT     ; 50
7182 ee5d 00                               FCB     AM_INVALID      ; 51
7183 ee5e 00                               FCB     AM_INVALID      ; 52
7184 ee5f 01                               FCB     AM_INHERENT     ; 53
7185 ee60 01                               FCB     AM_INHERENT     ; 54
7186 ee61 00                               FCB     AM_INVALID      ; 55
7187 ee62 01                               FCB     AM_INHERENT     ; 56
7188 ee63 01                               FCB     AM_INHERENT     ; 57
7189 ee64 01                               FCB     AM_INHERENT     ; 58
7190 ee65 01                               FCB     AM_INHERENT     ; 59
7191 ee66 01                               FCB     AM_INHERENT     ; 5A
7192 ee67 00                               FCB     AM_INVALID      ; 5B
7193 ee68 01                               FCB     AM_INHERENT     ; 5C
7194 ee69 01                               FCB     AM_INHERENT     ; 5D
7195 ee6a 00                               FCB     AM_INVALID      ; 5E
7196 ee6b 01                               FCB     AM_INHERENT     ; 5F
7197                               
7198 ee6c 08                               FCB     AM_INDEXED      ; 60
7199 ee6d 00                               FCB     AM_INVALID      ; 61
7200 ee6e 00                               FCB     AM_INVALID      ; 62
7201 ee6f 08                               FCB     AM_INDEXED      ; 63
7202 ee70 08                               FCB     AM_INDEXED      ; 64
7203 ee71 00                               FCB     AM_INVALID      ; 65
7204 ee72 08                               FCB     AM_INDEXED      ; 66
7205 ee73 08                               FCB     AM_INDEXED      ; 67
7206 ee74 08                               FCB     AM_INDEXED      ; 68
7207 ee75 08                               FCB     AM_INDEXED      ; 69
7208 ee76 08                               FCB     AM_INDEXED      ; 6A
7209 ee77 00                               FCB     AM_INVALID      ; 6B
7210 ee78 08                               FCB     AM_INDEXED      ; 6C
7211 ee79 08                               FCB     AM_INDEXED      ; 6D
7212 ee7a 08                               FCB     AM_INDEXED      ; 6E
7213 ee7b 08                               FCB     AM_INDEXED      ; 6F
7214                               
7215 ee7c 05                               FCB     AM_EXTENDED     ; 70
7216 ee7d 00                               FCB     AM_INVALID      ; 71
7217 ee7e 00                               FCB     AM_INVALID      ; 72
7218 ee7f 05                               FCB     AM_EXTENDED     ; 73
7219 ee80 05                               FCB     AM_EXTENDED     ; 74
7220 ee81 00                               FCB     AM_INVALID      ; 75
7221 ee82 05                               FCB     AM_EXTENDED     ; 76
7222 ee83 05                               FCB     AM_EXTENDED     ; 77
7223 ee84 05                               FCB     AM_EXTENDED     ; 78
7224 ee85 05                               FCB     AM_EXTENDED     ; 79
7225 ee86 05                               FCB     AM_EXTENDED     ; 7A
7226 ee87 00                               FCB     AM_INVALID      ; 7B
7227 ee88 05                               FCB     AM_EXTENDED     ; 7C
7228 ee89 05                               FCB     AM_EXTENDED     ; 7D
7229 ee8a 05                               FCB     AM_EXTENDED     ; 7E
7230 ee8b 05                               FCB     AM_EXTENDED     ; 7F
7231                               
7232 ee8c 02                               FCB     AM_IMMEDIATE8   ; 80
7233 ee8d 02                               FCB     AM_IMMEDIATE8   ; 81
7234 ee8e 02                               FCB     AM_IMMEDIATE8   ; 82
7235 ee8f 03                               FCB     AM_IMMEDIATE16  ; 83
7236 ee90 02                               FCB     AM_IMMEDIATE8   ; 84
7237 ee91 02                               FCB     AM_IMMEDIATE8   ; 85
7238 ee92 02                               FCB     AM_IMMEDIATE8   ; 86
7239 ee93 00                               FCB     AM_INVALID      ; 87
7240 ee94 02                               FCB     AM_IMMEDIATE8   ; 88
7241 ee95 02                               FCB     AM_IMMEDIATE8   ; 89
7242 ee96 02                               FCB     AM_IMMEDIATE8   ; 8A
7243 ee97 02                               FCB     AM_IMMEDIATE8   ; 8B
7244 ee98 03                               FCB     AM_IMMEDIATE16  ; 8C
7245 ee99 06                               FCB     AM_RELATIVE8    ; 8D
7246 ee9a 03                               FCB     AM_IMMEDIATE16  ; 8E
7247 ee9b 00                               FCB     AM_INVALID      ; 8F
7248                               
7249 ee9c 04                               FCB     AM_DIRECT       ; 90
7250 ee9d 04                               FCB     AM_DIRECT       ; 91
7251 ee9e 04                               FCB     AM_DIRECT       ; 92
7252 ee9f 04                               FCB     AM_DIRECT       ; 93
7253 eea0 04                               FCB     AM_DIRECT       ; 94
7254 eea1 04                               FCB     AM_DIRECT       ; 95
7255 eea2 04                               FCB     AM_DIRECT       ; 96
7256 eea3 04                               FCB     AM_DIRECT       ; 97
7257 eea4 04                               FCB     AM_DIRECT       ; 98
7258 eea5 04                               FCB     AM_DIRECT       ; 99
7259 eea6 04                               FCB     AM_DIRECT       ; 9A
7260 eea7 04                               FCB     AM_DIRECT       ; 9B
7261 eea8 04                               FCB     AM_DIRECT       ; 9C
7262 eea9 04                               FCB     AM_DIRECT       ; 9D
7263 eeaa 04                               FCB     AM_DIRECT       ; 9E
7264 eeab 04                               FCB     AM_DIRECT       ; 9F
7265                               
7266 eeac 08                               FCB     AM_INDEXED      ; A0
7267 eead 08                               FCB     AM_INDEXED      ; A1
7268 eeae 08                               FCB     AM_INDEXED      ; A2
7269 eeaf 08                               FCB     AM_INDEXED      ; A3
7270 eeb0 08                               FCB     AM_INDEXED      ; A4
7271 eeb1 08                               FCB     AM_INDEXED      ; A5
7272 eeb2 08                               FCB     AM_INDEXED      ; A6
7273 eeb3 08                               FCB     AM_INDEXED      ; A7
7274 eeb4 08                               FCB     AM_INDEXED      ; A8
7275 eeb5 08                               FCB     AM_INDEXED      ; A9
7276 eeb6 08                               FCB     AM_INDEXED      ; AA
7277 eeb7 08                               FCB     AM_INDEXED      ; AB
7278 eeb8 08                               FCB     AM_INDEXED      ; AC
7279 eeb9 08                               FCB     AM_INDEXED      ; AD
7280 eeba 08                               FCB     AM_INDEXED      ; AE
7281 eebb 08                               FCB     AM_INDEXED      ; AF
7282                               
7283 eebc 05                               FCB     AM_EXTENDED     ; B0
7284 eebd 05                               FCB     AM_EXTENDED     ; B1
7285 eebe 05                               FCB     AM_EXTENDED     ; B2
7286 eebf 05                               FCB     AM_EXTENDED     ; B3
7287 eec0 05                               FCB     AM_EXTENDED     ; B4
7288 eec1 05                               FCB     AM_EXTENDED     ; B5
7289 eec2 05                               FCB     AM_EXTENDED     ; B6
7290 eec3 05                               FCB     AM_EXTENDED     ; B7
7291 eec4 05                               FCB     AM_EXTENDED     ; B8
7292 eec5 05                               FCB     AM_EXTENDED     ; B9
7293 eec6 05                               FCB     AM_EXTENDED     ; BA
7294 eec7 05                               FCB     AM_EXTENDED     ; BB
7295 eec8 05                               FCB     AM_EXTENDED     ; BC
7296 eec9 05                               FCB     AM_EXTENDED     ; BD
7297 eeca 05                               FCB     AM_EXTENDED     ; BE
7298 eecb 05                               FCB     AM_EXTENDED     ; BF
7299                               
7300 eecc 02                               FCB     AM_IMMEDIATE8   ; C0
7301 eecd 02                               FCB     AM_IMMEDIATE8   ; C1
7302 eece 02                               FCB     AM_IMMEDIATE8   ; C2
7303 eecf 03                               FCB     AM_IMMEDIATE16  ; C3
7304 eed0 02                               FCB     AM_IMMEDIATE8   ; C4
7305 eed1 02                               FCB     AM_IMMEDIATE8   ; C5
7306 eed2 02                               FCB     AM_IMMEDIATE8   ; C6
7307 eed3 00                               FCB     AM_INVALID      ; C7
7308 eed4 02                               FCB     AM_IMMEDIATE8   ; C8
7309 eed5 02                               FCB     AM_IMMEDIATE8   ; C9
7310 eed6 02                               FCB     AM_IMMEDIATE8   ; CA
7311 eed7 02                               FCB     AM_IMMEDIATE8   ; CB
7312 eed8 03                               FCB     AM_IMMEDIATE16  ; CC
7313 eed9 01                               FCB     AM_INHERENT     ; CD
7314 eeda 03                               FCB     AM_IMMEDIATE16  ; CE
7315 eedb 00                               FCB     AM_INVALID      ; CF
7316                               
7317 eedc 04                               FCB     AM_DIRECT       ; D0
7318 eedd 04                               FCB     AM_DIRECT       ; D1
7319 eede 04                               FCB     AM_DIRECT       ; D2
7320 eedf 04                               FCB     AM_DIRECT       ; D3
7321 eee0 04                               FCB     AM_DIRECT       ; D4
7322 eee1 04                               FCB     AM_DIRECT       ; D5
7323 eee2 04                               FCB     AM_DIRECT       ; D6
7324 eee3 04                               FCB     AM_DIRECT       ; D7
7325 eee4 04                               FCB     AM_DIRECT       ; D8
7326 eee5 04                               FCB     AM_DIRECT       ; D9
7327 eee6 04                               FCB     AM_DIRECT       ; DA
7328 eee7 04                               FCB     AM_DIRECT       ; DB
7329 eee8 04                               FCB     AM_DIRECT       ; DC
7330 eee9 04                               FCB     AM_DIRECT       ; DD
7331 eeea 04                               FCB     AM_DIRECT       ; DE
7332 eeeb 04                               FCB     AM_DIRECT       ; DF
7333                               
7334 eeec 08                               FCB     AM_INDEXED      ; E0
7335 eeed 08                               FCB     AM_INDEXED      ; E1
7336 eeee 08                               FCB     AM_INDEXED      ; E2
7337 eeef 08                               FCB     AM_INDEXED      ; E3
7338 eef0 08                               FCB     AM_INDEXED      ; E4
7339 eef1 08                               FCB     AM_INDEXED      ; E5
7340 eef2 08                               FCB     AM_INDEXED      ; E6
7341 eef3 08                               FCB     AM_INDEXED      ; E7
7342 eef4 08                               FCB     AM_INDEXED      ; E8
7343 eef5 08                               FCB     AM_INDEXED      ; E9
7344 eef6 08                               FCB     AM_INDEXED      ; EA
7345 eef7 08                               FCB     AM_INDEXED      ; EB
7346 eef8 08                               FCB     AM_INDEXED      ; EC
7347 eef9 08                               FCB     AM_INDEXED      ; ED
7348 eefa 08                               FCB     AM_INDEXED      ; EE
7349 eefb 08                               FCB     AM_INDEXED      ; EF
7350                               
7351 eefc 05                               FCB     AM_EXTENDED     ; F0
7352 eefd 05                               FCB     AM_EXTENDED     ; F1
7353 eefe 05                               FCB     AM_EXTENDED     ; F2
7354 eeff 05                               FCB     AM_EXTENDED     ; F3
7355 ef00 05                               FCB     AM_EXTENDED     ; F4
7356 ef01 05                               FCB     AM_EXTENDED     ; F5
7357 ef02 05                               FCB     AM_EXTENDED     ; F6
7358 ef03 05                               FCB     AM_EXTENDED     ; F7
7359 ef04 05                               FCB     AM_EXTENDED     ; F8
7360 ef05 05                               FCB     AM_EXTENDED     ; F9
7361 ef06 05                               FCB     AM_EXTENDED     ; FA
7362 ef07 05                               FCB     AM_EXTENDED     ; FB
7363 ef08 05                               FCB     AM_EXTENDED     ; FC
7364 ef09 05                               FCB     AM_EXTENDED     ; FD
7365 ef0a 05                               FCB     AM_EXTENDED     ; FE
7366 ef0b 05                               FCB     AM_EXTENDED     ; FF
7367                               
7368                               ; Special table for page 2 instructions prefixed by $10.
7369                               ; Format: opcode (less 10), instruction, addressing mode
7370                               
7371                               PAGE2:
7372 ef0c 21 4a 07                         FCB     $21, OP_LBRN,  AM_RELATIVE16
7373 ef0f 22 42 07                         FCB     $22, OP_LBHI,  AM_RELATIVE16
7374 ef12 23 44 07                         FCB     $23, OP_LBLS,  AM_RELATIVE16
7375 ef15 24 3d 07                         FCB     $24, OP_LBCC,  AM_RELATIVE16
7376 ef18 25 3e 07                         FCB     $25, OP_LBCS,  AM_RELATIVE16
7377 ef1b 26 47 07                         FCB     $26, OP_LBNE,  AM_RELATIVE16
7378 ef1e 27 3f 07                         FCB     $27, OP_LBEQ,  AM_RELATIVE16
7379 ef21 28 4c 07                         FCB     $28, OP_LBVC,  AM_RELATIVE16
7380 ef24 29 4d 07                         FCB     $29, OP_LBVS,  AM_RELATIVE16
7381 ef27 2a 48 07                         FCB     $2A, OP_LBPL,  AM_RELATIVE16
7382 ef2a 2b 46 07                         FCB     $2B, OP_LBMI,  AM_RELATIVE16
7383 ef2d 2c 40 07                         FCB     $2C, OP_LBGE,  AM_RELATIVE16
7384 ef30 2d 45 07                         FCB     $2D, OP_LBLT,  AM_RELATIVE16
7385 ef33 2e 41 07                         FCB     $2E, OP_LBGT,  AM_RELATIVE16
7386 ef36 2f 43 07                         FCB     $2F, OP_LBLE,  AM_RELATIVE16
7387 ef39 3f 7e 01                         FCB     $3F, OP_SWI2,  AM_INHERENT
7388 ef3c 83 28 03                         FCB     $83, OP_CMPD,  AM_IMMEDIATE16
7389 ef3f 8c 2c 03                         FCB     $8C, OP_CMPY,  AM_IMMEDIATE16
7390 ef42 8e 54 03                         FCB     $8E, OP_LDY,   AM_IMMEDIATE16
7391 ef45 93 28 04                         FCB     $93, OP_CMPD,  AM_DIRECT
7392 ef48 9c 2c 04                         FCB     $9C, OP_CMPY,  AM_DIRECT
7393 ef4b 9e 54 04                         FCB     $9E, OP_LDY,   AM_DIRECT
7394 ef4e 9d 79 04                         FCB     $9D, OP_STY,   AM_DIRECT
7395 ef51 a3 28 08                         FCB     $A3, OP_CMPD,  AM_INDEXED
7396 ef54 ac 2c 08                         FCB     $AC, OP_CMPY,  AM_INDEXED
7397 ef57 ae 54 08                         FCB     $AE, OP_LDY,   AM_INDEXED
7398 ef5a af 79 08                         FCB     $AF, OP_STY,   AM_INDEXED
7399 ef5d b3 28 05                         FCB     $B3, OP_CMPD,  AM_EXTENDED
7400 ef60 bc 2c 05                         FCB     $BC, OP_CMPY,  AM_EXTENDED
7401 ef63 be 54 05                         FCB     $BE, OP_LDY,   AM_EXTENDED
7402 ef66 bf 79 05                         FCB     $BF, OP_STY,   AM_EXTENDED
7403 ef69 ce 51 03                         FCB     $CE, OP_LDS,   AM_IMMEDIATE16
7404 ef6c de 51 04                         FCB     $DE, OP_LDS,   AM_DIRECT
7405 ef6f dd 76 04                         FCB     $DD, OP_STS,   AM_DIRECT
7406 ef72 ee 51 08                         FCB     $EE, OP_LDS,   AM_INDEXED
7407 ef75 ef 76 08                         FCB     $EF, OP_STS,   AM_INDEXED
7408 ef78 fe 51 05                         FCB     $FE, OP_LDS,   AM_EXTENDED
7409 ef7b ff 76 05                         FCB     $FF, OP_STS,   AM_EXTENDED
7410 ef7e 00                               FCB     0                             ; indicates end of table
7411                               
7412                               ; Special table for page 3 instructions prefixed by $11.
7413                               ; Same format as table above.
7414                               
7415                               PAGE3:
7416 ef7f 3f 7f 01                         FCB     $3F, OP_SWI3,  AM_INHERENT
7417 ef82 83 2a 03                         FCB     $83, OP_CMPU,  AM_IMMEDIATE16
7418 ef85 8c 29 03                         FCB     $8C, OP_CMPS,  AM_IMMEDIATE16
7419 ef88 93 2a 04                         FCB     $93, OP_CMPU,  AM_DIRECT
7420 ef8b 9c 29 04                         FCB     $9C, OP_CMPS,  AM_DIRECT
7421 ef8e a3 2a 08                         FCB     $A3, OP_CMPU,  AM_INDEXED
7422 ef91 ac 29 08                         FCB     $AC, OP_CMPS,  AM_INDEXED
7423 ef94 b3 2a 05                         FCB     $B3, OP_CMPU,  AM_EXTENDED
7424 ef97 bc 29 05                         FCB     $BC, OP_CMPS,  AM_EXTENDED
7425 ef9a 00                               FCB     0                             ; indicates end of table
7426                               
7427                               ; Display strings. Should be terminated in EOT character.
7428                               
7429 ef9b 3b 20 49 4e 56 41        MSG1:   FCC     "; INVALID"
     4c 49 44
7430 efa4 04                               FCB     EOT
7431                               
7432 efa5 50 52 45 53 53 20        MSG2:   FCC     "PRESS <SPACE> TO CONTINUE, <Q> TO QUIT "
     3c 53 50 41 43 45
     3e 20 54 4f 20 43
     4f 4e 54 49 4e 55
     45 2c 20 3c 51 3e
     20 54 4f 20 51 55
     49 54 20
7433 efcc 04                               FCB     EOT
7434                               
7435 efcd 50 43 52                 MSG3:   FCC     "PCR"
7436 efd0 04                               FCB     EOT
7437                               
7438                               ; ========================================================================
7439                               ;
7440                               ; 6809 Trace Utility
7441                               ;
7442                               ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
7443                               ;
7444                               ; Licensed under the Apache License, Version 2.0 (the "License");
7445                               ; you may not use this file except in compliance with the License.
7446                               ; You may obtain a copy of the License at
7447                               ;
7448                               ;   http://www.apache.org/licenses/LICENSE-2.0
7449                               ;
7450                               ; Unless required by applicable law or agreed to in writing, software
7451                               ; distributed under the License is distributed on an "AS IS" BASIS,
7452                               ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
7453                               ; See the License for the specific language governing permissions and
7454                               ; limitations under the License.
7455                               
7456                               ; Start address for RAM variables
7457 7e3a                                  ORG     $7E3A
7458                               
7459                               ; Variables
7460                               
7461 7e3a                          SAVE_CC RMB     1               ; Saved register values
7462 7e3b                          SAVE_A  RMB     1
7463 7e3c                          SAVE_B  RMB     1
7464 7e3b                          SAVE_D  equ     SAVE_A          ; Synonym for SAVE_A and SAVE_B
7465 7e3d                          SAVE_DP RMB     1
7466 7e3e                          SAVE_X  RMB     2
7467 7e40                          SAVE_Y  RMB     2
7468 7e42                          SAVE_U  RMB     2
7469 7e44                          SAVE_S  RMB     2
7470 7e46                          SAVE_PC RMB     2
7471 7e48                          OURS    RMB     2               ; This program's user stack pointer
7472 7e4a                          OURU    RMB     2               ; This program's system stack pointer
7473 7e4c                          BUFFER  RMB     10              ; Buffer holding traced instruction (up to 10 bytes)
7474                               
7475 f000                                  ORG     $F000
7476                               
7477                               ;------------------------------------------------------------------------
7478                               ; Trace Command.
7479                               ; Accepts a start address on the command line. Traces and disassembles
7480                               ; an instruction. Pressing Q or q will go to monitor, any other key
7481                               ; will trace another instruction.
7482                               
7483 f000 17 0e 5d           [ 9 ] TRACE   lbsr    CDNUM           ; Parse command line, return 16-bit number in D
7484 f003 fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store it
7485 f006 8d 1a              [ 7 ] loop    bsr     step            ; Step one instruction
7486 f008 30 8c 9a           [ 5 ]         leax    MSG2,pcr        ; Display message to press a key
7487 f00b 17 f4 8f           [ 9 ]         lbsr    PrintString
7488 f00e 17 f4 6d           [ 9 ]         lbsr    GetChar         ; Wait for a key press
7489 f011 17 f4 1a           [ 9 ]         lbsr    PrintCR
7490 f014 81 51              [ 2 ]         cmpa    #'Q'            ; Check for Q
7491 f016 27 06              [ 3 ]         beq     quit            ; If so, quit
7492 f018 81 71              [ 2 ]         cmpa    #'q'            ; Check for q
7493 f01a 27 02              [ 3 ]         beq     quit            ; If so, quit
7494 f01c 20 e8              [ 3 ]         bra     loop            ; If not, continue
7495 f01e 6e 9f ff fe        [ 8 ] quit    jmp     [$fffe]         ; Go back to ASSIST09 via reset vector
7496                               
7497                               ;------------------------------------------------------------------------
7498                               ; Step: Step one instruction
7499                               ; Disassemble next instruction
7500                               ; Call Trace
7501                               ; Display register values
7502                               ; Return
7503                               
7504 f022 17 06 c3           [ 9 ] step    lbsr    Disassemble     ; Disassemble the instruction
7505 f025 8d 04              [ 7 ]         bsr     Trace           ; Trace/execute the instruction
7506 f027 17 05 98           [ 9 ]         lbsr    DisplayRegs     ; Display register values
7507 f02a 39                 [ 5 ]         rts
7508                               
7509                               ;------------------------------------------------------------------------
7510                               ; Trace one instruction.
7511                               ; Input: Address of instruction in SAVE_PC
7512                               ; Returns: Updates saved register values.
7513                               
7514                               Trace
7515                               
7516                               ; At this point we have set: OPCODE, OPTYPE, LENG, AM, PAGE23, POSTBYT
7517                               ; Now check for special instructions that change flow of control or otherwise
7518                               ; need special handling rather than being directly executed.
7519                               
7520                               ; Invalid op code?
7521 f02b b6 7e 2e           [ 5 ]         lda     OPTYPE          ; Get op code type
7522 f02e 81 00              [ 2 ]         cmpa    #OP_INV         ; Is it an invalid instruction?
7523 f030 10 27 05 83        [ 6 ]         lbeq    update          ; If so, nothing to do (length is 1 byte)
7524                               
7525                               ; Check for PC relative indexed addressing modes that we don't
7526                               ; currently handle. If so, display a warning but still trace the
7527                               ; instruction.
7528                               
7529 f034 b6 7e 2d           [ 5 ]         lda    AM               ; Get address mode
7530 f037 81 08              [ 2 ]         cmpa   #AM_INDEXED      ; Indexed addressing
7531 f039 26 13              [ 3 ]         bne    trysync          ; Branch if not
7532 f03b b6 7e 2f           [ 5 ]         lda    POSTBYT          ; Get the post byte
7533                               
7534                               ; It is a PCR mode if the post byte has the pattern 1xxx110x
7535                               
7536 f03e 84 8e              [ 2 ]         anda   #%10001110       ; Mask bits we want to check
7537 f040 81 8c              [ 2 ]         cmpa   #%10001100       ; Check for pattern
7538 f042 26 0a              [ 3 ]         bne    trysync          ; Branch if no match
7539                               
7540                               ; Display "Warning: instruction not supported, expect incorrect results."
7541                               
7542 f044 30 8d 06 62        [ 9 ]         leax    TMSG12,PCR      ; Message string
7543 f048 17 f4 52           [ 9 ]         lbsr    PrintString     ; Display it
7544 f04b 17 f3 e0           [ 9 ]         lbsr    PrintCR
7545                               
7546                               ; SYNC instruction. Continue (emulate interrupt and then RTI
7547                               ; happenning or mask interrupt and instruction continuing).
7548                               
7549 f04e b6 7e 2e           [ 5 ] trysync lda     OPTYPE          ; Get op code type
7550 f051 81 80              [ 2 ]         cmpa    #OP_SYNC        ; Is it a SYNC instruction?
7551 f053 10 27 05 60        [ 6 ]         lbeq    update          ; If so, nothing to do (length is 1 byte)
7552                               
7553                               ; CWAI #$XX instruction. AND operand with CC. Set E flag in CC. Continue (emulate interrupt and then RTI happenning).
7554                               
7555 f057 b6 7e 2e           [ 5 ]         lda     OPTYPE          ; Get op code type
7556 f05a 81 30              [ 2 ]         cmpa    #OP_CWAI        ; Is it a CWAI instruction?
7557 f05c 26 10              [ 3 ]         bne     tryswi
7558 f05e be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7559 f061 a6 01              [ 5 ]         lda     1,x             ; Get operand
7560 f063 8a 80              [ 2 ]         ora     #%10000000      ; Set E bit
7561 f065 ba 7e 3a           [ 5 ]         ora     SAVE_CC         ; Or with CC
7562 f068 b7 7e 3a           [ 5 ]         sta     SAVE_CC         ; Save CC
7563 f06b 16 05 49           [ 5 ]         lbra    update          ; Done
7564                               
7565                               ; SWI instruction. Increment PC. Save all registers except S on hardware stack.
7566                               ; Set I and F in CC. Set new PC to [FFFA,FFFB].
7567                               
7568 f06e 81 7d              [ 2 ] tryswi  cmpa    #OP_SWI
7569 f070 26 4e              [ 3 ]         bne     tryswi2
7570 f072 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7571 f075 30 01              [ 5 ]         leax    1,x             ; Add one
7572 f077 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Save new PC
7573                               
7574                               ; push CC, A, B, DP, X, Y, U, PC
7575                               
7576 f07a 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save our SP
7577 f07e 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Use program's SP to push
7578                               
7579 f082 b6 7e 3a           [ 5 ]         lda     SAVE_CC
7580 f085 34 02              [ 6 ]         pshs    a
7581 f087 8a 50              [ 2 ]         ora     #%01010000      ; Set I and F bits
7582 f089 b7 7e 3a           [ 5 ]         sta     SAVE_CC
7583 f08c b6 7e 3b           [ 5 ]         lda     SAVE_A
7584 f08f 34 02              [ 6 ]         pshs    a
7585 f091 b6 7e 3c           [ 5 ]         lda     SAVE_B
7586 f094 34 02              [ 6 ]         pshs    a
7587 f096 b6 7e 3d           [ 5 ]         lda     SAVE_DP
7588 f099 34 02              [ 6 ]         pshs    a
7589 f09b be 7e 3e           [ 6 ]         ldx     SAVE_X
7590 f09e 34 10              [ 7 ]         pshs    x
7591 f0a0 be 7e 40           [ 6 ]         ldx     SAVE_Y
7592 f0a3 34 10              [ 7 ]         pshs    x
7593 f0a5 be 7e 42           [ 6 ]         ldx     SAVE_U
7594 f0a8 34 10              [ 7 ]         pshs    x
7595 f0aa be 7e 46           [ 6 ]         ldx     SAVE_PC
7596 f0ad 34 10              [ 7 ]         pshs    x
7597 f0af 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save new value of SP
7598 f0b3 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our SP
7599                               
7600 f0b7 be ff fa           [ 6 ]         ldx     $FFFA           ; Get address of SWI vector
7601 f0ba bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new address
7602                               
7603 f0bd 16 05 01           [ 5 ]         lbra    don             ; Done
7604                               
7605                               ; SWI2 instruction. Increment PC. Save all registers except S on
7606                               ; stack. Set new PC to [FFF4,FFF5].
7607                               
7608 f0c0 81 7e              [ 2 ] tryswi2 cmpa    #OP_SWI2
7609 f0c2 26 49              [ 3 ]         bne     tryswi3
7610 f0c4 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7611 f0c7 30 01              [ 5 ]         leax    1,x             ; Add one
7612 f0c9 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Save new PC
7613                               
7614                               ; push CC, A, B, DP, X, Y, U, PC
7615                               
7616 f0cc 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save our SP
7617 f0d0 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Use program's SP to push
7618                               
7619 f0d4 b6 7e 3a           [ 5 ]         lda     SAVE_CC
7620 f0d7 34 02              [ 6 ]         pshs    a
7621 f0d9 b6 7e 3b           [ 5 ]         lda     SAVE_A
7622 f0dc 34 02              [ 6 ]         pshs    a
7623 f0de b6 7e 3c           [ 5 ]         lda     SAVE_B
7624 f0e1 34 02              [ 6 ]         pshs    a
7625 f0e3 b6 7e 3d           [ 5 ]         lda     SAVE_DP
7626 f0e6 34 02              [ 6 ]         pshs    a
7627 f0e8 be 7e 3e           [ 6 ]         ldx     SAVE_X
7628 f0eb 34 10              [ 7 ]         pshs    x
7629 f0ed be 7e 40           [ 6 ]         ldx     SAVE_Y
7630 f0f0 34 10              [ 7 ]         pshs    x
7631 f0f2 be 7e 42           [ 6 ]         ldx     SAVE_U
7632 f0f5 34 10              [ 7 ]         pshs    x
7633 f0f7 be 7e 46           [ 6 ]         ldx     SAVE_PC
7634 f0fa 34 10              [ 7 ]         pshs    x
7635 f0fc 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save new value of SP
7636 f100 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our SP
7637                               
7638 f104 be ff f4           [ 6 ]         ldx     $FFF4           ; Get address of SWI2 vector
7639 f107 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new address
7640                               
7641 f10a 16 04 b4           [ 5 ]         lbra    don             ; Done
7642                               
7643                               ; SWI3 instruction. Increment PC. Save all registers except S on
7644                               ; stack. Set new PC to [FFF2,FFF3].
7645                               
7646 f10d 81 7f              [ 2 ] tryswi3 cmpa    #OP_SWI3
7647 f10f 26 49              [ 3 ]         bne     tryjmp
7648 f111 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7649 f114 30 01              [ 5 ]         leax    1,x             ; Add one
7650 f116 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Save new PC
7651                               
7652                               ; push CC, A, B, DP, X, Y, U, PC
7653                               
7654 f119 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save our SP
7655 f11d 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Use program's SP to push
7656                               
7657 f121 b6 7e 3a           [ 5 ]         lda     SAVE_CC
7658 f124 34 02              [ 6 ]         pshs    a
7659 f126 b6 7e 3b           [ 5 ]         lda     SAVE_A
7660 f129 34 02              [ 6 ]         pshs    a
7661 f12b b6 7e 3c           [ 5 ]         lda     SAVE_B
7662 f12e 34 02              [ 6 ]         pshs    a
7663 f130 b6 7e 3d           [ 5 ]         lda     SAVE_DP
7664 f133 34 02              [ 6 ]         pshs    a
7665 f135 be 7e 3e           [ 6 ]         ldx     SAVE_X
7666 f138 34 10              [ 7 ]         pshs    x
7667 f13a be 7e 40           [ 6 ]         ldx     SAVE_Y
7668 f13d 34 10              [ 7 ]         pshs    x
7669 f13f be 7e 42           [ 6 ]         ldx     SAVE_U
7670 f142 34 10              [ 7 ]         pshs    x
7671 f144 be 7e 46           [ 6 ]         ldx     SAVE_PC
7672 f147 34 10              [ 7 ]         pshs    x
7673 f149 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save new value of SP
7674 f14d 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our SP
7675                               
7676 f151 be ff f2           [ 6 ]         ldx     $FFF2           ; Get address of SWI3 vector
7677 f154 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new address
7678                               
7679 f157 16 04 67           [ 5 ]         lbra    don             ; Done
7680                               
7681                               ; JMP instruction. Next PC is operand effective address. Need to
7682                               ; handle extended, direct, and indexed modes.
7683                               
7684 f15a 81 3b              [ 2 ] tryjmp  cmpa    #OP_JMP         ; Is it a JMP instruction?
7685 f15c 10 26 00 7b        [ 6 ]         lbne    tryjsr          ; Branch if not.
7686 f160 b6 7e 2c           [ 5 ]         lda     OPCODE          ; Get the actual op code
7687 f163 81 7e              [ 2 ]         cmpa    #$7E            ; Extended, e.g. JMP $XXXX ?
7688 f165 26 0b              [ 3 ]         bne     jmp1
7689 f167 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7690 f16a ae 01              [ 6 ]         ldx     1,x             ; Get 16-bit operand (JMP destination)
7691 f16c bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new instruction address
7692 f16f 16 04 4f           [ 5 ]         lbra    don             ; Done
7693                               
7694 f172 81 0e              [ 2 ] jmp1    cmpa    #$0E            ; Direct, e.g. JMP $XX ?
7695 f174 26 0e              [ 3 ]         bne     jmp2
7696 f176 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7697 f179 e6 01              [ 5 ]         ldb     1,x             ; Get 8-bit operand (JMP destination)
7698 f17b b6 7e 3d           [ 5 ]         lda     SAVE_DP         ; Get DP register
7699 f17e fd 7e 46           [ 6 ]         std     SAVE_PC         ; Full address is DP (in A) + operand (in B)
7700 f181 16 04 3d           [ 5 ]         lbra    don             ; Done
7701                               
7702                               ; Must be indexed, e.g. JMP 1,X. Can't get effective address directly
7703                               ; from instruction. Instead we use this trick: Run a LEAU instruction
7704                               ; with the same indexed operand. Then examine value of X, which should
7705                               ; be the new PC. Need to run it with the current index register values
7706                               ; of X, Y, U, and S.
7707                               ; TODO: Not handled: addressing modes that change U register like JMP ,U++.
7708                               ; TODO: Not handled correctly: PCR modes like JMP 10,PCR
7709                               
7710 f184 be 7e 46           [ 6 ] jmp2    ldx     SAVE_PC         ; Address of instruction
7711 f187 10 8e 7e 4c        [ 4 ]         ldy     #BUFFER         ; Address of buffer
7712 f18b c6 33              [ 2 ]         ldb     #$33            ; LEAU instruction
7713 f18d 4f                 [ 2 ]         clra                    ; Loop counter and index
7714 f18e e7 a6              [ 5 ]         stb     a,y             ; Write LEAU instruction to buffer
7715 f190 4c                 [ 2 ]         inca                    ; Move to next byte
7716 f191 e6 86              [ 5 ] copy1   ldb     a,x             ; Get instruction byte
7717 f193 e7 a6              [ 5 ]         stb     a,y             ; Write to buffer
7718 f195 4c                 [ 2 ]         inca                    ; Increment counter
7719 f196 b1 7e 30           [ 5 ]         cmpa    LENG            ; Copied all bytes?
7720 f199 26 f6              [ 3 ]         bne     copy1
7721                               
7722                               ; Add a jump after the instruction to where we want to go after it is executed (ReturnFromJump).
7723                               
7724 f19b c6 7e              [ 2 ]         ldb     #$7E            ; JMP $XXXX instruction
7725 f19d e7 a6              [ 5 ]         stb     a,y             ; Store in buffer
7726 f19f 4c                 [ 2 ]         inca                    ; Advance buffer
7727 f1a0 8e f1 c3           [ 3 ]         ldx     #ReturnFromJump ; Destination address of JMP
7728 f1a3 af a6              [ 6 ]         stx     a,y             ; Store in buffer
7729                               
7730                               ; Restore registers from saved values.
7731                               
7732 f1a5 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointers
7733 f1a9 ff 7e 4a           [ 6 ]         stu     OURU
7734                               
7735 f1ac b6 7e 3b           [ 5 ]         lda     SAVE_A
7736 f1af f6 7e 3c           [ 5 ]         ldb     SAVE_B
7737 f1b2 be 7e 3e           [ 6 ]         ldx     SAVE_X
7738 f1b5 10 be 7e 40        [ 7 ]         ldy     SAVE_Y
7739 f1b9 10 fe 7e 44        [ 7 ]         lds     SAVE_S
7740 f1bd fe 7e 42           [ 6 ]         ldu     SAVE_U
7741                               
7742                               ; Call instruction in buffer. It is followed by a JMP ReturnFromJump so we get back.
7743                               
7744 f1c0 7e 7e 4c           [ 4 ]         jmp     BUFFER
7745                               
7746                               ReturnFromJump
7747                               
7748                               ; Restore saved registers (except U and PC).
7749                               
7750 f1c3 bf 7e 3e           [ 6 ]         stx     SAVE_X
7751 f1c6 10 bf 7e 40        [ 7 ]         sty     SAVE_Y
7752 f1ca 10 ff 7e 44        [ 7 ]         sts     SAVE_S
7753                               
7754                               ; Restore this program's stack pointers so RTS etc. will still work.
7755                               
7756 f1ce 10 fe 7e 48        [ 7 ]         lds     OURS
7757 f1d2 fe 7e 4a           [ 6 ]         ldu     OURU
7758                               
7759                               ; Value of X is new PC
7760                               
7761 f1d5 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new instruction address
7762 f1d8 16 03 e6           [ 5 ]         lbra    don             ; Done
7763                               
7764                               ; JSR instruction. Next PC is operand effective address. Push return
7765                               ; address on stack. Need to handle extended, direct, and indexed
7766                               ; modes.
7767                               
7768 f1db 81 3c              [ 2 ] tryjsr  cmpa    #OP_JSR         ; Is it a JSR instruction?
7769 f1dd 10 26 00 72        [ 6 ]         lbne    tryrts          ; Branch if not.
7770 f1e1 b6 7e 2c           [ 5 ]         lda     OPCODE          ; Get the actual op code
7771 f1e4 81 bd              [ 2 ]         cmpa    #$BD            ; Extended, e.g. JSR $XXXX ?
7772 f1e6 26 24              [ 3 ]         bne     jsr1
7773                               
7774 f1e8 4f                 [ 2 ]         clra                    ; Set MSB to zero
7775 f1e9 f6 7e 30           [ 5 ]         ldb     LENG            ; Get instruction length (byte)
7776 f1ec f3 7e 46           [ 7 ]         addd    SAVE_PC         ; 16-bit add
7777                               
7778 f1ef 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7779 f1f3 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7780 f1f7 34 06              [ 7 ]         pshs    d               ; Push return address
7781 f1f9 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7782 f1fd 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7783                               
7784 f201 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7785 f204 ae 01              [ 6 ]         ldx     1,x             ; Get 16-bit operand (JSR destination)
7786 f206 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new instruction address
7787 f209 16 03 b5           [ 5 ]         lbra    don             ; Done
7788                               
7789 f20c 81 9d              [ 2 ] jsr1    cmpa    #$9D            ; Direct, e.g. JSR $XX ?
7790 f20e 26 27              [ 3 ]         bne     jsr2
7791                               
7792 f210 4f                 [ 2 ]         clra                    ; Set MSB to zero
7793 f211 f6 7e 30           [ 5 ]         ldb     LENG            ; Get instruction length (byte)
7794 f214 f3 7e 46           [ 7 ]         addd    SAVE_PC         ; 16-bit add
7795                               
7796 f217 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7797 f21b 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7798 f21f 34 06              [ 7 ]         pshs    d               ; Push return address
7799 f221 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7800 f225 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7801                               
7802 f229 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7803 f22c e6 01              [ 5 ]         ldb     1,x             ; Get 8-bit operand (JSR destination)
7804 f22e b6 7e 3d           [ 5 ]         lda     SAVE_DP         ; Get DP register
7805 f231 fd 7e 46           [ 6 ]         std     SAVE_PC         ; Full address is DP (in A) + operand (in B)
7806 f234 16 03 8a           [ 5 ]         lbra    don             ; Done
7807                               
7808                               ; Must be indexed, e.g. JSR 1,X. Use same LEAU trick as for JMP.
7809                               ; TODO: Not handled: addressing modes that change U register like JSR ,U++.
7810                               ; TODO: Not handled correctly: PCR modes like JSR 10,PCR
7811                               
7812 f237 4f                 [ 2 ] jsr2    clra                    ; Set MSB to zero
7813 f238 f6 7e 30           [ 5 ]         ldb     LENG            ; Get instruction length (byte)
7814 f23b f3 7e 46           [ 7 ]         addd    SAVE_PC         ; 16-bit add
7815                               
7816 f23e 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7817 f242 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7818 f246 34 06              [ 7 ]         pshs    d               ; Push return address
7819 f248 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7820 f24c 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7821                               
7822 f250 16 ff 31           [ 5 ]         lbra    jmp2            ; Rest of code is shared with JMP routine
7823                               
7824                               ; RTS instruction. Pop PC from stack and set it to next address.
7825                               
7826 f253 81 6f              [ 2 ] tryrts  cmpa    #OP_RTS         ; Is it a RTS instruction?
7827 f255 26 18              [ 3 ]         bne     tryrti          ; Branch if not.
7828 f257 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7829 f25b 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7830 f25f 35 10              [ 7 ]         puls    x               ; Pull return address
7831 f261 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7832 f265 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7833 f269 bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new instruction address
7834 f26c 16 03 52           [ 5 ]         lbra    don             ; Done
7835                               
7836                               ; RTI instruction.
7837                               ; If E flag is not set, pop PC and CC.
7838                               ; If E flag is set, pop PC, U, Y, X, DP, B, A, and CC.
7839                               ; Set next instruction to PC.
7840                               
7841 f26f 81 6e              [ 2 ] tryrti  cmpa    #OP_RTI         ; Is it a RTI instruction?
7842 f271 26 40              [ 3 ]         bne     trybsr          ; Branch if not.
7843 f273 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7844 f277 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7845 f27b 35 10              [ 7 ]         puls    x               ; Pull PC
7846 f27d bf 7e 46           [ 6 ]         stx     SAVE_PC         ; Set as new instruction address
7847                               
7848 f280 b6 7e 3a           [ 5 ]         lda     SAVE_CC         ; Test CC
7849 f283 2a 1e              [ 3 ]         bpl     notEntire       ; Branch if Entire bit (MSB is not set)
7850 f285 35 10              [ 7 ]         puls    x               ; Pull U
7851 f287 bf 7e 42           [ 6 ]         stx     SAVE_U
7852 f28a 35 10              [ 7 ]         puls    x               ; Pull Y
7853 f28c bf 7e 40           [ 6 ]         stx     SAVE_Y
7854 f28f 35 10              [ 7 ]         puls    x               ; Pull X
7855 f291 bf 7e 3e           [ 6 ]         stx     SAVE_X
7856 f294 35 02              [ 6 ]         puls    a               ; Pull DP
7857 f296 b7 7e 3d           [ 5 ]         sta     SAVE_DP
7858 f299 35 02              [ 6 ]         puls    a               ; Pull B
7859 f29b b7 7e 3c           [ 5 ]         sta     SAVE_B
7860 f29e 35 02              [ 6 ]         puls    a               ; Pull A
7861 f2a0 b7 7e 3b           [ 5 ]         sta     SAVE_A
7862                               notEntire
7863 f2a3 35 02              [ 6 ]         puls    a               ; Pull CC
7864 f2a5 b7 7e 3a           [ 5 ]         sta     SAVE_CC
7865                               
7866 f2a8 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7867 f2ac 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7868 f2b0 16 03 0e           [ 5 ]         lbra    don             ; Done
7869                               
7870                               ; BSR instruction. Similar to JSR but EA is relative.
7871                               
7872 f2b3 81 20              [ 2 ] trybsr  cmpa    #OP_BSR         ; Is it a BSR instruction?
7873 f2b5 26 2c              [ 3 ]         bne     trylbsr         ; Branch if not.
7874                               
7875                               ; Push return address on stack.
7876                               
7877 f2b7 4f                 [ 2 ]         clra                    ; Set MSB to zero
7878 f2b8 f6 7e 30           [ 5 ]         ldb     LENG            ; Get instruction length (byte)
7879 f2bb f3 7e 46           [ 7 ]         addd    SAVE_PC         ; 16-bit add
7880                               
7881 f2be 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7882 f2c2 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7883 f2c6 34 06              [ 7 ]         pshs    d               ; Push return address
7884 f2c8 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7885 f2cc 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7886                               
7887                               ; Next PC is PC plus instruction length (2) plus offset operand.
7888                               
7889 f2d0 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7890 f2d3 4f                 [ 2 ]         clra                    ; Clear MSB
7891 f2d4 e6 01              [ 5 ]         ldb     1,x             ; Get 8-bit signed branch offset
7892 f2d6 1d                 [ 2 ]         sex                     ; Sign extend to 16-bits
7893 f2d7 c3 00 02           [ 4 ]         addd    #2              ; Add instruction length (2)
7894 f2da f3 7e 46           [ 7 ]         addd    SAVE_PC         ; Add to address
7895 f2dd fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store new address value
7896 f2e0 16 02 de           [ 5 ]         lbra    don             ; Done
7897                               
7898                               ; LBSR instruction. Similar to BSR above.
7899                               
7900 f2e3 81 4b              [ 2 ] trylbsr cmpa    #OP_LBSR        ; Is it a LBSR instruction?
7901 f2e5 26 2a              [ 3 ]         bne     trybxx          ; Branch if not.
7902                               
7903                               ; Push return address on stack.
7904                               
7905 f2e7 4f                 [ 2 ]         clra                    ; Set MSB to zero
7906 f2e8 f6 7e 30           [ 5 ]         ldb     LENG            ; Get instruction length (byte)
7907 f2eb f3 7e 46           [ 7 ]         addd    SAVE_PC         ; 16-bit add
7908                               
7909 f2ee 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointer
7910 f2f2 10 fe 7e 44        [ 7 ]         lds     SAVE_S          ; Get program's stack pointer
7911 f2f6 34 06              [ 7 ]         pshs    d               ; Push return address
7912 f2f8 10 ff 7e 44        [ 7 ]         sts     SAVE_S          ; Save program's new stack pointer
7913 f2fc 10 fe 7e 48        [ 7 ]         lds     OURS            ; Restore our stack pointer
7914                               
7915                               ; Next PC is PC plus instruction length (3) plus 16-bit offset operand.
7916                               
7917 f300 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7918 f303 ec 01              [ 6 ]         ldd     1,x             ; Get 16-bit signed branch offset
7919 f305 c3 00 03           [ 4 ]         addd    #3              ; Add instruction length (3)
7920 f308 f3 7e 46           [ 7 ]         addd    SAVE_PC         ; Add to address
7921 f30b fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store new address value
7922 f30e 16 02 b0           [ 5 ]         lbra    don             ; Done
7923                               
7924                               ; Bxx instructions.
7925                               ; These are executed but we change the destination of the branch so we
7926                               ; catch whether they are taken or not.
7927                               ; The code in the buffer will look like this:
7928                               ;
7929                               ;       JMP BUFFER
7930                               ;       ...
7931                               ; XXXX XX 03           Bxx $03 (Taken)         ; Instruction being traced
7932                               ; XXXX 7E XX XX        JMP BranchNotTaken
7933                               ; XXXX 7E XX XX Taken  JMP BranchTaken
7934                               ;        ...
7935                               ;
7936                               ; If we come back via BranchNotTaken, next PC is instruction after the branch (PC plus 2).
7937                               ; If we come back via BranchTaken, next PC is PC plus offset plus 2.
7938                               ; Need to set CC to program's value before the branch is executed.
7939                               
7940 f311 b6 7e 2d           [ 5 ] trybxx  lda     AM              ; Get addressing mode
7941 f314 81 06              [ 2 ]         cmpa    #AM_RELATIVE8   ; Is it a relative branch?
7942 f316 26 4b              [ 3 ]         bne     trylbxx
7943                               
7944 f318 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Address of instruction
7945 f31b 10 8e 7e 4c        [ 4 ]         ldy     #BUFFER         ; Address of buffer
7946 f31f a6 84              [ 4 ]         lda     ,x              ; Get branch instruction
7947 f321 a7 a4              [ 4 ]         sta     ,y              ; Store in buffer
7948 f323 86 03              [ 2 ]         lda     #3              ; Branch offset (Taken)
7949 f325 a7 21              [ 5 ]         sta     1,y             ; Store in buffer
7950 f327 86 7e              [ 2 ]         lda     #$7E            ; JMP $XXXX instruction
7951 f329 a7 22              [ 5 ]         sta     2,y             ; Store in buffer
7952 f32b 8e f3 54           [ 3 ]         ldx     #BranchNotTaken ; Address for branch
7953 f32e af 23              [ 6 ]         stx     3,y             ; Store in buffer
7954 f330 86 7e              [ 2 ]         lda     #$7E            ; JMP $XXXX instruction
7955 f332 a7 25              [ 5 ]         sta     5,y             ; Store in buffer
7956 f334 8e f3 41           [ 3 ]         ldx     #BranchTaken    ; Address for branch
7957 f337 af 26              [ 6 ]         stx     6,y             ; Store in buffer
7958                               
7959                               ; Restore CC from saved value.
7960                               
7961 f339 b6 7e 3a           [ 5 ]         lda     SAVE_CC
7962 f33c 1f 8a              [ 6 ]         tfr     a,cc
7963                               
7964                               ; Call instruction in buffer. It is followed by a JMP so we get back.
7965                               
7966 f33e 7e 7e 4c           [ 4 ]         jmp     BUFFER
7967                               
7968                               BranchTaken                     ; Next PC is PC plus offset plus 2.
7969                               
7970 f341 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
7971 f344 4f                 [ 2 ]         clra                    ; Clear MSB
7972 f345 e6 01              [ 5 ]         ldb     1,x             ; Get 8-bit signed branch offset
7973 f347 1d                 [ 2 ]         sex                     ; Sign extend to 16-bits
7974 f348 c3 00 02           [ 4 ]         addd    #2              ; Add instruction length (2)
7975 f34b f3 7e 46           [ 7 ]         addd    SAVE_PC         ; Add to address
7976 f34e fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store new address value
7977 f351 16 02 6d           [ 5 ]         lbra    don             ; Done
7978                               
7979                               BranchNotTaken                  ; Next PC is instruction after the branch (PC plus 2).
7980                               
7981 f354 fc 7e 46           [ 6 ]         ldd     SAVE_PC         ; Get address of instruction
7982 f357 c3 00 02           [ 4 ]         addd    #2              ; Add instruction length (2)
7983 f35a fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store new address value
7984 f35d fd 7e 46           [ 6 ]         std     SAVE_PC
7985 f360 16 02 5e           [ 5 ]         lbra    don             ; Done
7986                               
7987                               ; LBxx instructions. Similar to Bxx above.
7988                               
7989 f363 81 07              [ 2 ] trylbxx cmpa    #AM_RELATIVE16  ; Is it a long relative branch?
7990 f365 10 26 00 85        [ 6 ]         lbne    trytfr
7991                               
7992                               ; Note Long branch instructions are 4 bytes (prefixed by 10) except
7993                               ; LBRA which is only 3 bytes.
7994                               ; BUFFER in this case is:
7995                               ; XXXX 16 00 03        LBRA $0003 (Taken)   ; Instruction being traced
7996                               ; XXXX 7E XX XX        JMP  BranchNotTaken1
7997                               ; XXX  7E XX XX Taken  JMP  BranchTaken1
7998                               ;
7999                               ; Or:
8000                               ;
8001                               ; XXXX 10 XX 00 03       LBxx $0003 (Taken) ; Instruction being traced
8002                               ; XXXX 7E XX XX          JMP  BranchNotTaken1
8003                               ; XXXX 7E XX XX   Taken  JMP  BranchTaken1
8004                               
8005 f369 b6 7e 2c           [ 5 ]         lda     OPCODE          ; Get  opcode
8006 f36c 81 16              [ 2 ]         cmpa    #$16            ; Is it LBRA?
8007 f36e 26 24              [ 3 ]         bne     long            ; Branch if it is one of the other 4 byte instructions
8008                               
8009 f370 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Address of instruction
8010 f373 10 8e 7e 4c        [ 4 ]         ldy     #BUFFER         ; Address of buffer
8011 f377 a6 84              [ 4 ]         lda     ,x              ; Get branch instruction
8012 f379 a7 a4              [ 4 ]         sta     ,y              ; Store in buffer
8013 f37b 8e 00 03           [ 3 ]         ldx     #3              ; Branch offset (Taken)
8014 f37e af 21              [ 6 ]         stx     1,y             ; Store in buffer
8015 f380 86 7e              [ 2 ]         lda     #$7E            ; JMP $XXXX instruction
8016 f382 a7 23              [ 5 ]         sta     3,y             ; Store in buffer
8017 f384 8e f3 e0           [ 3 ]         ldx     #BranchNotTaken1 ; Address for branch
8018 f387 af 24              [ 6 ]         stx     4,y             ; Store in buffer
8019 f389 86 7e              [ 2 ]         lda     #$7E            ; JMP $XXXX instruction
8020 f38b a7 26              [ 5 ]         sta     6,y             ; Store in buffer
8021 f38d 8e f3 be           [ 3 ]         ldx     #BranchTaken1   ; Address for branch
8022 f390 af 27              [ 6 ]         stx     7,y             ; Store in buffer
8023 f392 20 22              [ 3 ]         bra     branch
8024                               
8025 f394 be 7e 46           [ 6 ] long    ldx     SAVE_PC         ; Address of instruction
8026 f397 10 8e 7e 4c        [ 4 ]         ldy     #BUFFER         ; Address of buffer
8027 f39b ae 84              [ 5 ]         ldx     ,x              ; Get two byte branch instruction
8028 f39d af a4              [ 5 ]         stx     ,y              ; Store in buffer
8029 f39f 8e 00 03           [ 3 ]         ldx     #3              ; Branch offset (Taken)
8030 f3a2 af 22              [ 6 ]         stx     2,y             ; Store in buffer
8031 f3a4 86 7e              [ 2 ]         lda     #$7E            ; JMP $XXXX instruction
8032 f3a6 a7 24              [ 5 ]         sta     4,y             ; Store in buffer
8033 f3a8 8e f3 e0           [ 3 ]         ldx     #BranchNotTaken1 ; Address for branch
8034 f3ab af 25              [ 6 ]         stx     5,y             ; Store in buffer
8035 f3ad 86 7e              [ 2 ]         lda     #$7E            ; JMP $XXXX instruction
8036 f3af a7 27              [ 5 ]         sta     7,y             ; Store in buffer
8037 f3b1 8e f3 be           [ 3 ]         ldx     #BranchTaken1   ; Address for branch
8038 f3b4 af 28              [ 6 ]         stx     8,y             ; Store in buffer
8039                               
8040                               ; Restore CC from saved value.
8041                               
8042 f3b6 b6 7e 3a           [ 5 ] branch  lda     SAVE_CC
8043 f3b9 1f 8a              [ 6 ]         tfr     a,cc
8044                               
8045                               ; Call instruction in buffer. It is followed by a JMP so we get back.
8046                               
8047 f3bb 7e 7e 4c           [ 4 ]         jmp     BUFFER
8048                               
8049                               BranchTaken1                    ; Next PC is PC plus offset plus instruction length (3 or 4)
8050                               
8051                               ; Offset is 1,X for LBRA (2 byte instruction) and 2,X for others (3 byte instructions)
8052                               
8053 f3be be 7e 46           [ 6 ]         ldx     SAVE_PC
8054 f3c1 b6 7e 2c           [ 5 ]         lda     OPCODE          ; Get  opcode
8055 f3c4 81 16              [ 2 ]         cmpa    #$16            ; Is it LBRA?
8056 f3c6 26 0a              [ 3 ]         bne     long1           ; Branch if it is one of the other 4 byte instructions
8057                               
8058 f3c8 fc 7e 46           [ 6 ]         ldd     SAVE_PC         ; Get address
8059 f3cb c3 00 03           [ 4 ]         addd    #3              ; Plus 3
8060 f3ce e3 01              [ 7 ]         addd    1,x             ; Add 16-bit signed branch offset
8061 f3d0 20 08              [ 3 ]         bra     upd
8062                               
8063 f3d2 fc 7e 46           [ 6 ] long1   ldd     SAVE_PC         ; Get address
8064 f3d5 c3 00 04           [ 4 ]         addd    #4              ; Plus 4
8065 f3d8 e3 02              [ 7 ]         addd    2,x             ; Add 16-bit signed branch offset
8066                               
8067 f3da fd 7e 46           [ 6 ] upd     std     SAVE_PC         ; Store new address value
8068 f3dd 16 01 e1           [ 5 ]         lbra    don             ; Done
8069                               
8070                               BranchNotTaken1                 ; Next PC is instruction after the branch (PC plus 3 or 4).
8071                               
8072 f3e0 4f                 [ 2 ]         clra                    ; Clear MSB
8073 f3e1 f6 7e 30           [ 5 ]         ldb     LENG            ; Get instruction length
8074 f3e4 1d                 [ 2 ]         sex                     ; Sign extend to 16 bits
8075 f3e5 f3 7e 46           [ 7 ]         addd    SAVE_PC         ; Add instruction address
8076 f3e8 fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store new address value
8077 f3eb 16 01 d3           [ 5 ]         lbra    don             ; Done
8078                               
8079                               ; Handle TFR instruction.
8080                               ; Need to manually handle cases where source or destination is the PC
8081                               ; since it won't run correctly from the buffer.
8082                               
8083 f3ee b6 7e 2c           [ 5 ] trytfr  lda     OPCODE          ; Get the actual op code
8084 f3f1 81 1f              [ 2 ]         cmpa    #$1F            ; Is it TFR R1,R2 ?
8085 f3f3 10 26 00 91        [ 6 ]         lbne    tryexg          ; Branch if not
8086 f3f7 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
8087 f3fa a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8088 f3fc 84 f0              [ 2 ]         anda    #%11110000      ; Mask source bits
8089 f3fe 81 50              [ 2 ]         cmpa    #%01010000      ; Is source register PC?
8090 f400 26 44              [ 3 ]         bne     checkdest       ; Branch if not
8091                               
8092 f402 10 be 7e 46        [ 7 ]         ldy     SAVE_PC         ; Get current PC
8093 f406 31 22              [ 5 ]         leay    2,y             ; Add instruction length
8094                               
8095 f408 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8096 f40a 84 0f              [ 2 ]         anda    #%00001111      ; Mask destination bits
8097 f40c 81 00              [ 2 ]         cmpa    #%00000000      ; D?
8098 f40e 27 13              [ 3 ]         beq     to_d
8099 f410 81 01              [ 2 ]         cmpa    #%00000001      ; X?
8100 f412 27 16              [ 3 ]         beq     to_x
8101 f414 81 02              [ 2 ]         cmpa    #%00000010      ; Y?
8102 f416 27 19              [ 3 ]         beq     to_y
8103 f418 81 03              [ 2 ]         cmpa    #%00000011      ; U?
8104 f41a 27 1c              [ 3 ]         beq     to_u
8105 f41c 81 04              [ 2 ]         cmpa    #%00000100      ; S?
8106 f41e 27 1f              [ 3 ]         beq     to_s
8107 f420 16 01 94           [ 5 ]         lbra    update          ; Anything else is invalid or PC to PC, so ignore
8108                               
8109 f423 10 bf 7e 3b        [ 7 ] to_d    sty     SAVE_D          ; Write new PC to D
8110 f427 16 01 8d           [ 5 ]         lbra    update          ; Done
8111 f42a 10 bf 7e 3e        [ 7 ] to_x    sty     SAVE_X          ; Write new PC to X
8112 f42e 16 01 86           [ 5 ]         lbra    update          ; Done
8113 f431 10 bf 7e 40        [ 7 ] to_y    sty     SAVE_Y          ; Write new PC to Y
8114 f435 16 01 7f           [ 5 ]         lbra    update          ; Done
8115 f438 10 bf 7e 42        [ 7 ] to_u    sty     SAVE_U          ; Write new PC to U
8116 f43c 16 01 78           [ 5 ]         lbra    update          ; Done
8117 f43f 10 bf 7e 44        [ 7 ] to_s    sty     SAVE_S          ; Write new PC to S
8118 f443 16 01 71           [ 5 ]         lbra    update          ; Done
8119                               
8120                               checkdest
8121 f446 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8122 f448 84 0f              [ 2 ]         anda    #%00001111      ; Mask destination bits
8123 f44a 81 05              [ 2 ]         cmpa    #%00000101      ; Is destination register PC?
8124 f44c 10 26 00 f7        [ 6 ]         lbne    norml           ; Branch to normal instruction handling if not
8125                               
8126 f450 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8127 f452 84 f0              [ 2 ]         anda    #%11110000      ; Mask source bits
8128 f454 81 00              [ 2 ]         cmpa    #%00000000      ; D?
8129 f456 27 13              [ 3 ]         beq     from_d
8130 f458 81 10              [ 2 ]         cmpa    #%00010000      ; X?
8131 f45a 27 14              [ 3 ]         beq     from_x
8132 f45c 81 20              [ 2 ]         cmpa    #%00100000      ; Y?
8133 f45e 27 15              [ 3 ]         beq     from_y
8134 f460 81 30              [ 2 ]         cmpa    #%00110000      ; U?
8135 f462 27 16              [ 3 ]         beq     from_u
8136 f464 81 40              [ 2 ]         cmpa    #%01000000      ; S?
8137 f466 27 17              [ 3 ]         beq     from_s
8138 f468 16 01 4c           [ 5 ]         lbra    update          ; Anything else is invalid or PC to PC, so ignore
8139                               
8140 f46b be 7e 3b           [ 6 ] from_d  ldx     SAVE_D          ; Get D
8141 f46e 20 12              [ 3 ]         bra     write
8142 f470 be 7e 3e           [ 6 ] from_x  ldx     SAVE_X          ; Get X
8143 f473 20 0d              [ 3 ]         bra     write
8144 f475 be 7e 40           [ 6 ] from_y  ldx     SAVE_Y          ; Get Y
8145 f478 20 08              [ 3 ]         bra     write
8146 f47a be 7e 42           [ 6 ] from_u  ldx     SAVE_U          ; Get U
8147 f47d 20 03              [ 3 ]         bra     write
8148 f47f be 7e 44           [ 6 ] from_s  ldx     SAVE_S          ; Get S
8149                               
8150 f482 bf 7e 46           [ 6 ] write   stx     SAVE_PC
8151 f485 16 01 39           [ 5 ]         lbra    don
8152                               
8153                               ; Handle EXG instruction.
8154                               ; Need to manually handle cases where source or destination is the PC
8155                               ; since it won't run correctly from the buffer.
8156                               
8157 f488 b6 7e 2c           [ 5 ] tryexg  lda     OPCODE          ; Get the actual op code
8158 f48b 81 1e              [ 2 ]         cmpa    #$1E            ; Is it EXG R1,R2 ?
8159 f48d 26 75              [ 3 ]         bne     trypul          ; Branch if not
8160                               
8161 f48f be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
8162 f492 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8163 f494 84 f0              [ 2 ]         anda    #%11110000      ; Mask source bits
8164 f496 81 50              [ 2 ]         cmpa    #%01010000      ; Is source register PC?
8165 f498 26 06              [ 3 ]         bne     checkdest1      ; Branch if not
8166 f49a a6 01              [ 5 ]         lda     1,x             ; Get operand byte again
8167 f49c 84 0f              [ 2 ]         anda    #%00001111      ; Mask destination bits
8168 f49e 20 16              [ 3 ]         bra     doexg           ; Do the exchange
8169                               checkdest1
8170 f4a0 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8171 f4a2 84 0f              [ 2 ]         anda    #%00001111      ; Mask destination bits
8172 f4a4 81 05              [ 2 ]         cmpa    #%00000101      ; Is destination register PC?
8173 f4a6 10 26 00 9d        [ 6 ]         lbne    norml           ; Branch and execute normally if not
8174 f4aa a6 01              [ 5 ]         lda     1,x             ; Get operand byte again
8175 f4ac 84 f0              [ 2 ]         anda    #%11110000      ; Mask source bits
8176 f4ae 04 00              [ 6 ]         lsr                     ; Shift into low nybble
8177 f4b0 04 00              [ 6 ]         lsr
8178 f4b2 04 00              [ 6 ]         lsr
8179 f4b4 04 00              [ 6 ]         lsr                     ; And fall thru to code below
8180                               
8181 f4b6 10 be 7e 46        [ 7 ] doexg   ldy     SAVE_PC         ; Get current PC
8182 f4ba 31 22              [ 5 ]         leay    2,y             ; Add instruction length
8183                               
8184 f4bc 81 00              [ 2 ]         cmpa    #%00000000      ; Exchange D?
8185 f4be 27 13              [ 3 ]         beq     exg_d
8186 f4c0 81 01              [ 2 ]         cmpa    #%00000001      ; Exchange X?
8187 f4c2 27 19              [ 3 ]         beq     exg_x
8188 f4c4 81 02              [ 2 ]         cmpa    #%00000010      ; Exchange Y?
8189 f4c6 27 1d              [ 3 ]         beq     exg_y
8190 f4c8 81 03              [ 2 ]         cmpa    #%00000011      ; Exchange U?
8191 f4ca 27 21              [ 3 ]         beq     exg_u
8192 f4cc 81 04              [ 2 ]         cmpa    #%00000100      ; Exchange S?
8193 f4ce 27 25              [ 3 ]         beq     exg_s
8194 f4d0 16 00 e4           [ 5 ]         lbra    update          ; Anything else is invalid or PC to PC, so ignore
8195                               
8196                               ; At this point Y contains PC
8197                               
8198                               exg_d                           ; Swap PC and D
8199 f4d3 be 7e 3b           [ 6 ]         ldx     SAVE_D
8200 f4d6 1e 12              [ 8 ]         exg     x,y
8201 f4d8 bf 7e 3b           [ 6 ]         stx     SAVE_D
8202 f4db 20 20              [ 3 ]         bra     fin
8203 f4dd be 7e 3e           [ 6 ] exg_x   ldx     SAVE_X          ; Swap PC and X
8204 f4e0 1e 12              [ 8 ]         exg     x,y
8205 f4e2 bf 7e 3e           [ 6 ]         stx     SAVE_X
8206 f4e5 be 7e 40           [ 6 ] exg_y   ldx     SAVE_Y          ; Swap PC and Y
8207 f4e8 1e 12              [ 8 ]         exg     x,y
8208 f4ea bf 7e 40           [ 6 ]         stx     SAVE_Y
8209 f4ed be 7e 42           [ 6 ] exg_u   ldx     SAVE_U          ; Swap PC and U
8210 f4f0 1e 12              [ 8 ]         exg     x,y
8211 f4f2 bf 7e 42           [ 6 ]         stx     SAVE_U
8212 f4f5 be 7e 44           [ 6 ] exg_s   ldx     SAVE_S          ; Swap PC and S
8213 f4f8 1e 12              [ 8 ]         exg     x,y
8214 f4fa bf 7e 44           [ 6 ]         stx     SAVE_S
8215 f4fd 10 bf 7e 46        [ 7 ] fin     sty     SAVE_PC
8216 f501 16 00 bd           [ 5 ]         lbra    don
8217                               
8218                               ; Handle PULS/PULU PC,r,r,r
8219                               ; Could support it, but handling all the combinations of registers
8220                               ; would take a lot of code. For now, just generate warning that
8221                               ; instruction is unsupported and being ignored.
8222                               
8223 f504 b6 7e 2c           [ 5 ] trypul  lda     OPCODE          ; Get the actual op code
8224 f507 81 35              [ 2 ]         cmpa    #$35            ; Is it PULS ?
8225 f509 27 04              [ 3 ]         beq     pull            ; If so, handle it.
8226 f50b 81 37              [ 2 ]         cmpa    #$37            ; Is it PULU ?
8227 f50d 26 18              [ 3 ]         bne     trypush         ; If no, skip
8228                               
8229 f50f be 7e 46           [ 6 ] pull    ldx     SAVE_PC         ; Get address of instruction
8230 f512 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8231 f514 84 80              [ 2 ]         anda    #%10000000      ; Mask PC bit
8232 f516 81 80              [ 2 ]         cmpa    #%10000000      ; Is PC bit set?
8233 f518 26 2d              [ 3 ]         bne     norml           ; If not, handle nornmally
8234                               
8235                               ; Display "Warning: instruction not supported, skipping."
8236                               
8237 f51a 30 8d 01 5e        [ 9 ]         leax    TMSG11,PCR      ; Message string
8238 f51e 17 ef 7c           [ 9 ]         lbsr    PrintString     ; Display it
8239 f521 17 ef 0a           [ 9 ]         lbsr    PrintCR
8240 f524 16 00 90           [ 5 ]         lbra    update          ; Don't execute it
8241                               
8242                               ; Handle PSHS/PSHU PC,r,r,r
8243                               ; Could support it, but handling all the combinations of registers
8244                               ; would take a lot of code. For now just generate warning that
8245                               ; instruction is unsupported and results will be incorrect.
8246                               ; Still execute the instruction.
8247                               
8248 f527 b6 7e 2c           [ 5 ] trypush lda     OPCODE          ; Get the actual op code
8249 f52a 81 34              [ 2 ]         cmpa    #$34            ; Is it PSHS ?
8250 f52c 27 04              [ 3 ]         beq     push            ; If so, handle it.
8251 f52e 81 36              [ 2 ]         cmpa    #$36            ; Is it PSHU ?
8252 f530 26 15              [ 3 ]         bne     norml           ; If no, skip
8253                               
8254 f532 be 7e 46           [ 6 ] push    ldx     SAVE_PC         ; Get address of instruction
8255 f535 a6 01              [ 5 ]         lda     1,x             ; Get operand byte
8256 f537 84 80              [ 2 ]         anda    #%10000000      ; Mask PC bit
8257 f539 81 80              [ 2 ]         cmpa    #%10000000      ; Is PC bit set?
8258 f53b 26 0a              [ 3 ]         bne     norml           ; If not, handle nornmally
8259                               
8260                               ; Display "Warning: instruction not supported, expect incorrect results."
8261                               
8262 f53d 30 8d 01 69        [ 9 ]         leax    TMSG12,PCR      ; Message string
8263 f541 17 ef 59           [ 9 ]         lbsr    PrintString     ; Display it
8264 f544 17 ee e7           [ 9 ]         lbsr    PrintCR
8265                                                               ; Fall through and execute it
8266                               
8267                               ; Otherwise:
8268                               ; Not a special instruction. We execute it from the buffer.
8269                               ; Copy instruction and operands to RAM buffer (based on LEN, can be 1 to 5 bytes)
8270                               ; TODO: Handle PC relative instructions.
8271                               
8272                               
8273                               ; Thoughts on handling PC relative modes:
8274                               ; Original code:
8275                               ; 2013  A6 8D 00 14                lda     tbl,pcr
8276                               ; 202B  01 02 03 04 05     tbl     fcb     1,2,3,4,5
8277                               ; Offset $0014 = $202B - ($2013 + 4)
8278                               ;
8279                               ; When running in buffer:
8280                               ; 101C  A6 8D 10 0B                lda     tbl,pcr
8281                               ; Offset should be $202B - ($101C + 4) = $100B
8282                               ; Change offset by $100B - $0014 = $0FF7
8283                               ; Original Address - Buffer Address = $2013 - $101C - $0FF7
8284                               ; Should be able to fix up offset to run in buffer.
8285                               ; Can't handle case where offset is 8 bits but won't reach buffer.
8286                               
8287                               
8288 f547 be 7e 46           [ 6 ] norml   ldx     SAVE_PC         ; Address of instruction
8289 f54a 10 8e 7e 4c        [ 4 ]         ldy     #BUFFER         ; Address of buffer
8290 f54e 4f                 [ 2 ]         clra                    ; Loop counter and index
8291 f54f e6 86              [ 5 ] copy    ldb     a,x             ; Get instruction byte
8292 f551 e7 a6              [ 5 ]         stb     a,y             ; Write to buffer
8293 f553 4c                 [ 2 ]         inca                    ; Increment counter
8294 f554 b1 7e 30           [ 5 ]         cmpa    LENG            ; Copied all bytes?
8295 f557 26 f6              [ 3 ]         bne     copy
8296                               
8297                               ; Add a jump after the instruction to where we want to go after it is executed (ReturnFromTrace).
8298                               
8299 f559 c6 7e              [ 2 ]         ldb     #$7E            ; JMP $XXXX instruction
8300 f55b e7 a6              [ 5 ]         stb     a,y             ; Store in buffer
8301 f55d 4c                 [ 2 ]         inca                    ; Advance buffer
8302 f55e 8e f5 8d           [ 3 ]         ldx     #ReturnFromTrace ; Destination address of JMP
8303 f561 af a6              [ 6 ]         stx     a,y             ; Store in buffer
8304                               
8305                               ; Restore registers from saved values.
8306                               
8307 f563 10 ff 7e 48        [ 7 ]         sts     OURS            ; Save this program's stack pointers
8308 f567 ff 7e 4a           [ 6 ]         stu     OURU
8309                               
8310 f56a f6 7e 3c           [ 5 ]         ldb     SAVE_B
8311 f56d be 7e 3e           [ 6 ]         ldx     SAVE_X
8312 f570 10 be 7e 40        [ 7 ]         ldy     SAVE_Y
8313 f574 10 fe 7e 44        [ 7 ]         lds     SAVE_S
8314 f578 fe 7e 42           [ 6 ]         ldu     SAVE_U
8315 f57b b6 7e 3d           [ 5 ]         lda     SAVE_DP
8316 f57e 1f 8b              [ 6 ]         tfr     a,dp
8317 f580 b6 7e 3a           [ 5 ]         lda     SAVE_CC
8318 f583 36 02              [ 6 ]         pshu    a
8319 f585 b6 7e 3b           [ 5 ]         lda     SAVE_A
8320 f588 37 01              [ 6 ]         pulu    cc              ; Has to be last so CC is left unchanged
8321                               
8322                               ; Call instruction in buffer. It is followed by a JMP ReturnFromTrace so we get back.
8323                               
8324 f58a 7e 7e 4c           [ 4 ]         jmp     BUFFER
8325                               
8326                               ReturnFromTrace
8327                               
8328                               ; Restore saved registers (except PC).
8329                               
8330 f58d 36 01              [ 6 ]         pshu    cc              ; Have to save before it changes
8331 f58f b7 7e 3b           [ 5 ]         sta     SAVE_A
8332 f592 37 02              [ 6 ]         pulu    a
8333 f594 b7 7e 3a           [ 5 ]         sta     SAVE_CC
8334 f597 1f b8              [ 6 ]         tfr     dp,a
8335 f599 b7 7e 3d           [ 5 ]         sta     SAVE_DP
8336 f59c f7 7e 3c           [ 5 ]         stb     SAVE_B
8337 f59f bf 7e 3e           [ 6 ]         stx     SAVE_X
8338 f5a2 10 bf 7e 40        [ 7 ]         sty     SAVE_Y
8339 f5a6 10 ff 7e 44        [ 7 ]         sts     SAVE_S
8340 f5aa ff 7e 42           [ 6 ]         stu     SAVE_U
8341                               
8342                               ; Restore this program's stack pointers so RTS etc. will still work.
8343                               
8344 f5ad 10 fe 7e 48        [ 7 ]         lds     OURS
8345 f5b1 fe 7e 4a           [ 6 ]         ldu     OURU
8346                               
8347                               ; Set this program's DP register to zero just in case calling program changed it.
8348                               
8349 f5b4 4f                 [ 2 ]         clra
8350 f5b5 1f 8b              [ 6 ]         tfr     a,dp
8351                               
8352                               ; Update new SAVE_PC value based on instruction address and length
8353                               
8354 f5b7 4f                 [ 2 ] update  clra                    ; Set MSB to zero
8355 f5b8 f6 7e 30           [ 5 ]         ldb     LENG            ; Get length byte
8356 f5bb f3 7e 46           [ 7 ]         addd    SAVE_PC         ; 16-bit add
8357 f5be fd 7e 46           [ 6 ]         std     SAVE_PC         ; Store new address value
8358                               
8359                               ; And return.
8360                               
8361 f5c1 39                 [ 5 ] don     rts
8362                               
8363                               ;------------------------------------------------------------------------
8364                               ; Display register values
8365                               ; Uses values in SAVED_A etc.
8366                               ; e.g.
8367                               ; PC=FEED A=01 B=02 X=1234 Y=2345 S=2000 U=2000 DP=00 CC=10001101 (EFHINZVC)
8368                               
8369                               DisplayRegs
8370 f5c2 30 8d 00 8c        [ 9 ]         leax    TMSG1,PCR
8371 f5c6 17 ee d4           [ 9 ]         lbsr    PrintString
8372 f5c9 be 7e 46           [ 6 ]         ldx     SAVE_PC
8373 f5cc 17 ee c0           [ 9 ]         lbsr    PrintAddress
8374                               
8375 f5cf 30 8d 00 83        [ 9 ]         leax    TMSG2,PCR
8376 f5d3 17 ee c7           [ 9 ]         lbsr    PrintString
8377 f5d6 b6 7e 3b           [ 5 ]         lda     SAVE_A
8378 f5d9 17 ee a5           [ 9 ]         lbsr    PrintByte
8379                               
8380 f5dc 30 8d 00 79        [ 9 ]         leax    TMSG3,PCR
8381 f5e0 17 ee ba           [ 9 ]         lbsr    PrintString
8382 f5e3 b6 7e 3c           [ 5 ]         lda     SAVE_B
8383 f5e6 17 ee 98           [ 9 ]         lbsr    PrintByte
8384                               
8385 f5e9 30 8d 00 6f        [ 9 ]         leax    TMSG4,PCR
8386 f5ed 17 ee ad           [ 9 ]         lbsr    PrintString
8387 f5f0 be 7e 3e           [ 6 ]         ldx     SAVE_X
8388 f5f3 17 ee 99           [ 9 ]         lbsr    PrintAddress
8389                               
8390 f5f6 30 8d 00 65        [ 9 ]         leax    TMSG5,PCR
8391 f5fa 17 ee a0           [ 9 ]         lbsr    PrintString
8392 f5fd be 7e 40           [ 6 ]         ldx     SAVE_Y
8393 f600 17 ee 8c           [ 9 ]         lbsr    PrintAddress
8394                               
8395 f603 30 8d 00 5b        [ 9 ]         leax    TMSG6,PCR
8396 f607 17 ee 93           [ 9 ]         lbsr    PrintString
8397 f60a be 7e 44           [ 6 ]         ldx     SAVE_S
8398 f60d 17 ee 7f           [ 9 ]         lbsr    PrintAddress
8399                               
8400 f610 30 8d 00 51        [ 9 ]         leax    TMSG7,PCR
8401 f614 17 ee 86           [ 9 ]         lbsr    PrintString
8402 f617 be 7e 42           [ 6 ]         ldx     SAVE_U
8403 f61a 17 ee 72           [ 9 ]         lbsr    PrintAddress
8404                               
8405 f61d 30 8d 00 47        [ 9 ]         leax    TMSG8,PCR
8406 f621 17 ee 79           [ 9 ]         lbsr    PrintString
8407 f624 b6 7e 3d           [ 5 ]         lda     SAVE_DP
8408 f627 17 ee 57           [ 9 ]         lbsr    PrintByte
8409                               
8410 f62a 30 8d 00 3e        [ 9 ]         leax    TMSG9,PCR       ; Show CC in binary
8411 f62e 17 ee 6c           [ 9 ]         lbsr    PrintString
8412 f631 8e 00 08           [ 3 ]         ldx     #8              ; Loop counter
8413 f634 f6 7e 3a           [ 5 ]         ldb     SAVE_CC         ; Get CC byte
8414 f637 58                 [ 2 ] ploop   aslb                    ; Shift bit into carry
8415 f638 25 04              [ 3 ]         bcs     one             ; Branch if it is a one
8416 f63a 86 30              [ 2 ]         lda     #'0'            ; Print '0'
8417 f63c 20 02              [ 3 ]         bra     prn
8418 f63e 86 31              [ 2 ] one     lda     #'1'            ; Print '1'
8419 f640 bd e4 7b           [ 8 ] prn     jsr     PrintChar
8420 f643 30 1f              [ 5 ]         leax    -1,x            ; Decrement loop counter
8421 f645 26 f0              [ 3 ]         bne     ploop           ; Branch if not done
8422                               
8423 f647 30 8d 00 25        [ 9 ]         leax    TMSG10,PCR
8424 f64b 17 ee 4f           [ 9 ]         lbsr    PrintString
8425 f64e 17 ed dd           [ 9 ]         lbsr    PrintCR
8426 f651 39                 [ 5 ]         rts
8427                               
8428 f652 50 43 3d                 TMSG1   FCC     "PC="
8429 f655 04                               FCB     EOT
8430 f656 41 3d                    TMSG2   FCC     "A="
8431 f658 04                               FCB     EOT
8432 f659 42 3d                    TMSG3   FCC     "B="
8433 f65b 04                               FCB     EOT
8434 f65c 58 3d                    TMSG4   FCC     "X="
8435 f65e 04                               FCB     EOT
8436 f65f 59 3d                    TMSG5   FCC     "Y="
8437 f661 04                               FCB     EOT
8438 f662 53 3d                    TMSG6   FCC     "S="
8439 f664 04                               FCB     EOT
8440 f665 55 3d                    TMSG7   FCC     "U="
8441 f667 04                               FCB     EOT
8442 f668 44 50 3d                 TMSG8   FCC     "DP="
8443 f66b 04                               FCB     EOT
8444 f66c 43 43 3d                 TMSG9   FCC     "CC="
8445 f66f 04                               FCB     EOT
8446 f670 20 28 45 46 48 49        TMSG10  FCC     " (EFHINZVC)"
     4e 5a 56 43 29
8447 f67b 04                               FCB     EOT
8448 f67c 57 61 72 6e 69 6e        TMSG11  FCC     "Warning: instruction not supported, skipping."
     67 3a 20 69 6e 73
     74 72 75 63 74 69
     6f 6e 20 6e 6f 74
     20 73 75 70 70 6f
     72 74 65 64 2c 20
     73 6b 69 70 70 69
     6e 67 2e
8449 f6a9 04                               FCB     EOT
8450 f6aa 57 61 72 6e 69 6e        TMSG12  FCC     "Warning: instruction not supported, expect incorrect results."
     67 3a 20 69 6e 73
     74 72 75 63 74 69
     6f 6e 20 6e 6f 74
     20 73 75 70 70 6f
     72 74 65 64 2c 20
     65 78 70 65 63 74
     20 69 6e 63 6f 72
     72 65 63 74 20 72
     65 73 75 6c 74 73
     2e
8451 f6e7 04                               FCB     EOT
8452                               
8453                               ;------------------------------------------------------------------------
8454                               ; Disassemble an instruction. Uses ASSIST09 ROM code.
8455                               ; e.g.
8456                               ; 1053 2001 86 01    lda     #$01
8457                               
8458                               Disassemble
8459 f6e8 be 7e 46           [ 6 ]         ldx     SAVE_PC         ; Get address of instruction
8460 f6eb bf 7e 2a           [ 6 ]         stx     ADRS            ; Pass it to the disassembler
8461 f6ee bd e5 a4           [ 8 ]         jsr     DISASM          ; Disassemble one instruction
8462 f6f1 39                 [ 5 ]         rts
8463                               
8464                               ;========================================================================
8465                               
8466 f800                                  ORG     $F800
8467                               
8468                               *************************************
8469                               * COPYRIGHT (C) MOTOROLA, INC. 1979 *
8470                               *************************************
8471                               
8472                               *************************************
8473                               * THIS IS THE BASE ASSIST09 ROM.
8474                               * IT MAY RUN WITH OR WITHOUT THE
8475                               * EXTENSION ROM WHICH
8476                               * WHEN PRESENT WILL BE AUTOMATICALLY
8477                               * INCORPORATED BY THE BLDVTR
8478                               * SUBROUTINE.
8479                               *************************************
8480                               
8481                               *********************************************
8482                               * GLOBAL MODULE EQUATES
8483                               ********************************************
8484 f800                          ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
8485 ffff86ab                          RAMOFS  EQU     -$7955          ; ROM OFFSET TO RAM WORK PAGE
8486 0800                          ROMSIZ  EQU     2048            ; ROM SIZE
8487 f000                          ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
8488 a000                          ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
8489 0000                          PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
8490 0000                          DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
8491 0005                          DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
8492 003e                          PROMPT  EQU     '>              ; PROMPT CHARACTER
8493 0008                          NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
8494                               *********************************************
8495                               
8496                               *********************************************
8497                               * MISCELANEOUS EQUATES
8498                               *********************************************
8499 0004                          EOT     EQU     $04             ; END OF TRANSMISSION
8500 0007                          BELL    EQU     $07             ; BELL CHARACTER
8501 000a                          LF      EQU     $0A             ; LINE FEED
8502                               *CR     EQU     $0D             ; CARRIAGE RETURN
8503 0010                          DLE     EQU     $10             ; DATA LINK ESCAPE
8504 0018                          CAN     EQU     $18             ; CANCEL (CTL-X)
8505                               
8506                               * PTM ACCESS DEFINITIONS
8507 0001                          PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
8508 0000                          PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
8509 0001                          PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
8510 0002                          PTMTM1  EQU     PTM+2           ; LATCH 1
8511 0004                          PTMTM2  EQU     PTM+4           ; LATCH 2
8512 0006                          PTMTM3  EQU     PTM+6           ; LATCH 3
8513 008c                          SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
8514                               
8515                               *******************************************
8516                               * ASSIST09 MONITOR SWI FUNCTIONS
8517                               * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
8518                               * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
8519                               ******************************************
8520 0000                          INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
8521 0001                          OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
8522 0002                          PDATA1  EQU     2               ; OUTPUT STRING
8523 0003                          PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
8524 0004                          OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
8525 0005                          OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
8526 0006                          PCRLF   EQU     6               ; OUTPUT CR/LF
8527 0007                          SPACEF  EQU     7               ; OUTPUT A SPACE
8528 0008                          MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
8529 0009                          VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
8530 000a                          BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
8531 000b                          PAUSE   EQU     11              ; TASK PAUSE FUNCTION
8532 000b                          NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
8533                               
8534                               * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
8535                               * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
8536                               * RELATIVE POSITIONING MUST BE MAINTAINED
8537                               
8538 0000                          .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
8539 0002                          .CMDL1  EQU     2               ; FIRST COMMAND LIST
8540 0004                          .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
8541 0006                          .SWI3   EQU     6               ; SWI3 ROUTINE
8542 0008                          .SWI2   EQU     8               ; SWI2 ROUTINE
8543 000a                          .FIRQ   EQU     10              ; FIRQ ROUTINE
8544 000c                          .IRQ    EQU     12              ; IRQ ROUTINE
8545 000e                          .SWI    EQU     14              ; SWI ROUTINE
8546 0010                          .NMI    EQU     16              ; NMI ROUTINE
8547 0012                          .RESET  EQU     18              ; RESET ROUTINE
8548 0014                          .CION   EQU     20              ; CONSOLE ON
8549 0016                          .CIDTA  EQU     22              ; CONSOLE INPUT DATA
8550 0018                          .CIOFF  EQU     24              ; CONSOLE INPUT OFF
8551 001a                          .COON   EQU     26              ; CONSOLE OUTPUT ON
8552 001c                          .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
8553 001e                          .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
8554 0020                          .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
8555 0022                          .BSON   EQU     34              ; PUNCH/LOAD ON
8556 0024                          .BSDTA  EQU     36              ; PUNCH/LOAD DATA
8557 0026                          .BSOFF  EQU     38              ; PUNCH/LOAD OFF
8558 0028                          .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
8559 002a                          .EXPAN  EQU     42              ; EXPRESSION ANALYZER
8560 002c                          .CMDL2  EQU     44              ; SECOND COMMAND LIST
8561 002e                          .ACIA   EQU     46              ; ACIA ADDRESS
8562 0030                          .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
8563 0032                          .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
8564 0034                          .PTM    EQU     52              ; PTM ADDRESS
8565 001b                          NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
8566 0034                          HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
8567                               
8568                               ******************************************
8569                               *           WORK AREA
8570                               * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
8571                               * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
8572                               * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
8573                               * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
8574                               * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
8575                               * DEFINED HEREIN.
8576                               ******************************************
8577 7eab                          WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
8578                               *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
8579 7fab                                  ORG     WORKPG+256      ; READY PAGE DEFINITIONS
8580                               
8581                               * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
8582                               * FOR PROPER INITIALIZATION
8583 7fa7                                  ORG     *-4
8584 7fa7                          PAUSER  EQU     *               ; PAUSE ROUTINE
8585 7fa6                                  ORG     *-1
8586 7fa6                          SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
8587 7fa5                                  ORG     *-1
8588 7fa5                          BKPTCT  EQU     *               ; BREAKPOINT COUNT
8589 7fa3                                  ORG     *-2             ; SLEVEL EQU
8590 7fa3                          SLEVEL  EQU     *               ; STACK TRACE LEVEL
8591 7f6d                                  ORG     -NUMVTR*2+*
8592 7f6d                          VECTAB  EQU     *               ; VECTOR TABLE
8593 7f5d                                  ORG     -2*NUMBKP+*
8594 7f5d                          BKPTBL  EQU     *               ; BREAKPOINT TABLE
8595 7f4d                                  ORG     -2*NUMBKP+*
8596 7f4d                          BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
8597 7f4b                                  ORG     *-2
8598 7f4b                          WINDOW  EQU     *               ; WINDOW
8599 7f49                                  ORG     *-2
8600 7f49                          ADDR    EQU     *               ; ADDRESS POINTER VALUE
8601 7f48                                  ORG     *-1
8602 7f48                          BASEPG  EQU     *               ; BASE PAGE VALUE
8603 7f46                                  ORG     *-2
8604 7f46                          NUMBER  EQU     *               ; BINARY BUILD AREA
8605 7f44                                  ORG     *-2
8606 7f44                          LASTOP  EQU     *               ; LAST OPCODE TRACED
8607 7f42                                  ORG     *-2
8608 7f42                          RSTACK  EQU     *               ; RESET STACK POINTER
8609 7f40                                  ORG     *-2
8610 7f40                          PSTACK  EQU     *               ; COMMAND RECOVERY STACK
8611 7f3e                                  ORG     *-2
8612 7f3e                          PCNTER  EQU     *               ; LAST PROGRAM COUNTER
8613 7f3c                                  ORG     *-2
8614 7f3c                          TRACEC  EQU     *               ; TRACE COUNT
8615 7f3b                                  ORG     *-1
8616 7f3b                          SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
8617 7f3a                                  ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
8618 7f3a                          MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
8619 7f39                                  ORG     *-1
8620 7f39                          DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
8621 7f11                                  ORG     *-40
8622 7f11                          ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
8623 7efc                                  ORG     *-21
8624 7efc                          TSTACK  EQU     *               ; TEMPORARY STACK HOLD
8625 7efc                          STACK   EQU     *               ; START OF INITIAL STACK
8626                               
8627                               ******************************************
8628                               * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
8629                               * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
8630                               * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
8631                               * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
8632                               * FROM THE ROM BEGINNING ADDRESS.
8633                               ********************************************
8634 f800                                  ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
8635                               
8636                               *****************************************************
8637                               * BLDVTR - BUILD ASSIST09 VECTOR TABLE
8638                               * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
8639                               * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
8640                               * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
8641                               * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
8642                               * ASSIST09 EXECUTION.
8643                               * INPUT: S->VALID STACK RAM
8644                               * OUTPUT: U->VECTOR TABLE ADDRESS
8645                               * DPR->ASSIST09 WORK AREA PAGE
8646                               * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
8647                               * ALL REGISTERS VOLATILE
8648                               *************************************************
8649 f800 30 8d 87 69        [ 9 ] BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
8650 f804 1f 10              [ 6 ]         TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
8651 f806 1f 8b              [ 6 ]         TFR     A,DP            ; SETUP DPR
8652 f808 97 48              [ 4 ]         STA     <BASEPG         ; STORE FOR QUICK REFERENCE
8653 f80a 33 84              [ 4 ]         LEAU    ,X              ; RETURN TABLE TO CALLER
8654 f80c 31 8c 35           [ 5 ]         LEAY    <INITVT,PCR     ; LOAD FROM ADDR
8655 f80f ef 81              [ 8 ]         STU     ,X++            ; INIT VECTOR TABLE ADDRESS
8656 f811 c6 16              [ 2 ]         LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
8657 f813 34 04              [ 6 ]         PSHS    B               ; STORE INDEX ON STACK
8658 f815 1f 20              [ 6 ] BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
8659 f817 e3 a1              [ 9 ]         ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
8660 f819 ed 81              [ 8 ]         STD     ,X++            ; INTO VECTOR TABLE
8661 f81b 6a e4              [ 6 ]         DEC     ,S              ; COUNT DOWN
8662 f81d 26 f6              [ 3 ]         BNE     BLD2            ; BRANCH IF MORE TO INSERT
8663 f81f c6 0d              [ 2 ]         LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
8664 f821 a6 a0              [ 6 ] BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
8665 f823 a7 80              [ 6 ]         STA     ,X+             ; STORE INTO POSITION
8666 f825 5a                 [ 2 ]         DECB                    ; COUNT DOWN
8667 f826 26 f9              [ 3 ]         BNE     BLD3            ; LOOP UNTIL DONE
8668 f828 31 8d f7 d4        [ 9 ]         LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
8669 f82c 8e 20 fe           [ 3 ]         LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
8670 f82f ac a1              [ 9 ]         CMPX    ,Y++            ; ? EXTENDED ROM HERE
8671 f831 26 02              [ 3 ]         BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
8672 f833 ad a4              [ 7 ]         JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
8673 f835 35 84              [ 8 ] BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
8674                               
8675                               *****************************************************
8676                               *                RESET ENTRY POINT
8677                               * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
8678                               * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
8679                               * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
8680                               * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
8681                               * CALL.
8682                               *******************************************************
8683 f837 32 8d 86 c1        [ 9 ] RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
8684 f83b 8d c3              [ 7 ]         BSR     BLDVTR          ; BUILD VECTOR TABLE
8685 f83d 4f                 [ 2 ] RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
8686 f83e 1f 8b              [ 6 ]         TFR     A,DP            ; DEFAULT TO PAGE ZERO
8687 f840 3f                 [19 ]         SWI                     ; PERFORM MONITOR FIREUP
8688 f841 08                               FCB     MONITR          ; TO ENTER COMMAND PROCESSING
8689 f842 20 f9              [ 3 ]         BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
8690                               
8691                               ******************************************************
8692                               *        INITVT - INITIAL VECTOR TABLE
8693                               * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
8694                               * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
8695                               * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
8696                               * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
8697                               * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
8698                               ************************************************
8699 f844 01 60                    INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
8700 f846 02 92                            FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
8701 f848 02 90                            FDB     SWI3R-*         ; DEFAULT SWI3
8702 f84a 02 8e                            FDB     SWI2R-*         ; DEFAULT SWI2
8703 f84c 02 70                            FDB     FIRQR-*         ; DEFAULT FIRQ
8704 f84e 02 8a                            FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
8705 f850 00 45                            FDB     SWIR-*          ; DEFAULT SWI ROUTINE
8706 f852 02 2b                            FDB     NMIR-*          ; DEFAULT NMI ROUTINE
8707 f854 ff e3                            FDB     RESET-*         ; RESTART VECTOR
8708 f856 02 90                            FDB     CION-*          ; DEFAULT CION
8709 f858 02 84                            FDB     CIDTA-*         ; DEFAULT CIDTA
8710 f85a 02 96                            FDB     CIOFF-*         ; DEFAULT CIOFF
8711 f85c 02 8a                            FDB     COON-*          ; DEFAULT COON
8712 f85e 02 93                            FDB     CODTA-*         ; DEFAULT CODTA
8713 f860 02 90                            FDB     COOFF-*         ; DEFAULT COOFF
8714 f862 03 9a                            FDB     HSDTA-*         ; DEFAULT HSDTA
8715 f864 02 b7                            FDB     BSON-*          ; DEFAULT BSON
8716 f866 02 d2                            FDB     BSDTA-*         ; DEFAULT BSDTA
8717 f868 02 bf                            FDB     BSOFF-*         ; DEFAULT BSOFF
8718 f86a 87 3d                            FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
8719 f86c 04 7d                            FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
8720 f86e 01 2d                            FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
8721                               * CONSTANTS
8722 f870 a0 00                    INTVS   FDB     ACIA            ; DEFAULT ACIA
8723 f872 00 05                            FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
8724 f874 00 00                            FDB     0               ; DEFAULT ECHO
8725 f876 00 00                            FDB     PTM             ; DEFAULT PTM
8726 f878 00 00                            FDB     0               ; INITIAL STACK TRACE LEVEL
8727 f87a 00                               FCB     0               ; INITIAL BREAKPOINT COUNT
8728 f87b 00                               FCB     0               ; SWI BREAKPOINT LEVEL
8729 f87c 39                               FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
8730 f87d                          INTVE   EQU     *
8731                               *B
8732                               ***********************************************
8733                               *            ASSIST09 SWI HANDLER
8734                               * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
8735                               * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
8736                               * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
8737                               * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
8738                               * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
8739                               * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
8740                               * INPUT: MACHINE STATE DEFINED FOR SWI
8741                               * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
8742                               * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
8743                               * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
8744                               * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
8745                               ************************************************
8746                               * SWI FUNCTION VECTOR TABLE
8747 f87d 01 94                    SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
8748 f87f 01 b1                            FDB     ZOTCH1-SWIVTB   ; OUTCH
8749 f881 01 cb                            FDB     ZPDTA1-SWIVTB   ; PDATA1
8750 f883 01 c3                            FDB     ZPDATA-SWIVTB   ; PDATA
8751 f885 01 75                            FDB     ZOT2HS-SWIVTB   ; OUT2HS
8752 f887 01 73                            FDB     ZOT4HS-SWIVTB   ; OUT4HS
8753 f889 01 c0                            FDB     ZPCRLF-SWIVTB   ; PCRLF
8754 f88b 01 79                            FDB     ZSPACE-SWIVTB   ; SPACE
8755 f88d 00 55                            FDB     ZMONTR-SWIVTB   ; MONITR
8756 f88f 01 7d                            FDB     ZVSWTH-SWIVTB   ; VCTRSW
8757 f891 02 56                            FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
8758 f893 01 d1                            FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
8759                               
8760 f895 6a 8d 86 a2        [11 ] SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
8761 f899 17 02 25           [ 9 ]         LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
8762                               * CHECK FOR BREAKPOINT TRAP
8763 f89c ee 6a              [ 6 ]         LDU     10,S            ; LOAD PROGRAM COUNTER
8764 f89e 33 5f              [ 5 ]         LEAU    -1,U            ; BACK TO SWI ADDRESS
8765 f8a0 0d a6              [ 6 ]         TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
8766 f8a2 26 11              [ 3 ]         BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
8767 f8a4 17 06 9b           [ 9 ]         LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
8768 f8a7 50                 [ 2 ]         NEGB                    ; OBTAIN POSITIVE COUNT
8769 f8a8 5a                 [ 2 ] SWILP   DECB                    ; COUNT DOWN
8770 f8a9 2b 0a              [ 3 ]         BMI     SWIDNE          ; BRANCH WHEN DONE
8771 f8ab 11 a3 a1           [10 ]         CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
8772 f8ae 26 f8              [ 3 ]         BNE     SWILP           ; BRANCH IF NOT
8773 f8b0 ef 6a              [ 6 ]         STU     10,S            ; SET PROGRAM COUNTER BACK
8774 f8b2 16 02 1e           [ 5 ]         LBRA    ZBKPNT          ; GO DO BREAKPOINT
8775 f8b5 0f a6              [ 6 ] SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
8776 f8b7 37 06              [ 7 ]         PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
8777 f8b9 c1 0b              [ 2 ]         CMPB    #NUMFUN         ; ? TOO HIGH
8778 f8bb 10 22 02 0f        [ 6 ]         LBHI    ERROR           ; YES, DO BREAKPOINT
8779 f8bf ef 6a              [ 6 ]         STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
8780 f8c1 58                 [ 2 ]         ASLB                    ; FUNCTION CODE TIMES TWO
8781 f8c2 33 8c b8           [ 5 ]         LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
8782 f8c5 ec c5              [ 6 ]         LDD     B,U             ; LOAD OFFSET
8783 f8c7 6e cb              [ 7 ]         JMP     D,U             ; JUMP TO ROUTINE
8784                               
8785                               **********************************************
8786                               * REGISTERS TO FUNCTION ROUTINES:
8787                               *  DP-> WORK AREA PAGE
8788                               *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
8789                               *  S=AS FROM SWI INTERRUPT
8790                               *********************************************
8791                               
8792                               **************************************************
8793                               *            [SWI FUNCTION 8]
8794                               *              MONITOR ENTRY
8795                               *  FIREUP THE ASSIST09 MONITOR.
8796                               *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
8797                               *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
8798                               *   1) INITIALIZE CONSOLE I/O
8799                               *   2) OPTIONALLY PRINT SIGNON
8800                               *   3) INITIALIZE PTM FOR SINGLE STEPPING
8801                               *   4) ENTER COMMAND PROCESSOR
8802                               * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
8803                               *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
8804                               *************************************************
8805                               
8806 f8c9 41 53 53 49 53 54        SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
8807 f8d1 04                               FCB     EOT
8808 f8d2 10 df 42           [ 6 ] ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
8809 f8d5 6d 61              [ 7 ]         TST     1,S             ; ? INIT CONSOLE AND SEND MSG
8810 f8d7 26 0d              [ 3 ]         BNE     ZMONT2          ; BRANCH IF NOT
8811 f8d9 ad 9d 86 a4        [15 ]         JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
8812 f8dd ad 9d 86 a6        [15 ]         JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
8813 f8e1 30 8c e5           [ 5 ]         LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
8814 f8e4 3f                 [19 ]         SWI                     ; PERFORM
8815 f8e5 03                               FCB     PDATA           ; PRINT STRING
8816 f8e6 9e a1              [ 5 ] ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
8817 f8e8 27 0d              [ 3 ]         BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
8818 f8ea 6f 02              [ 7 ]         CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
8819 f8ec 6f 03              [ 7 ]         CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
8820 f8ee cc 01 a6           [ 3 ]         LDD     #$01A6          ; SETUP TIMER 1 MODE
8821 f8f1 a7 01              [ 5 ]         STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
8822 f8f3 e7 84              [ 4 ]         STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
8823                               * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
8824 f8f5 6f 01              [ 7 ]         CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
8825                               * FALL INTO COMMAND PROCESSOR
8826                               
8827                               ***************************************************
8828                               *          COMMAND HANDLER
8829                               *  BREAKPOINTS ARE REMOVED AT THIS TIME.
8830                               *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
8831                               *  UNTIL A SEPARATOR ON THE STACK.
8832                               *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
8833                               *  CALL IT OR GIVE '?' RESPONSE.
8834                               *  DURING COMMAND SEARCH:
8835                               *      B=OFFSET TO NEXT ENTRY ON X
8836                               *      U=SAVED S
8837                               *      U-1=ENTRY SIZE+2
8838                               *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
8839                               *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
8840                               *      U-4=START OF COMMAND STORE
8841                               *      S+0=END OF COMMAND STORE
8842                               ***********************************************
8843                               
8844 f8f7 3f                 [19 ] CMD     SWI                     ; TO NEW LINE
8845 f8f8 06                               FCB     PCRLF           ; FUNCTION
8846                               * DISARM THE BREAKPOINTS
8847 f8f9 17 06 46           [ 9 ] CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
8848 f8fc 2a 0c              [ 3 ]         BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
8849 f8fe 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
8850 f8ff d7 a5              [ 4 ]         STB     <BKPTCT         ; FLAG AS DISARMED
8851 f901 5a                 [ 2 ] CMDDDL  DECB                    ; ? FINISHED
8852 f902 2b 06              [ 3 ]         BMI     CMDNOL          ; BRANCH IF SO
8853 f904 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
8854 f906 a7 b1              [10 ]         STA     [,Y++]          ; STORE BACK OVER "SWI"
8855 f908 20 f7              [ 3 ]         BRA     CMDDDL          ; LOOP UNTIL DONE
8856 f90a ae 6a              [ 6 ] CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
8857 f90c 9f 3e              [ 5 ]         STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
8858 f90e 86 3e              [ 2 ]         LDA     #PROMPT         ; LOAD PROMPT CHARACTER
8859 f910 3f                 [19 ]         SWI                     ; SEND TO OUTPUT HANDLER
8860 f911 01                               FCB     OUTCH           ; FUNCTION
8861 f912 33 e4              [ 4 ]         LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
8862 f914 df 40              [ 5 ]         STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
8863 f916 4f                 [ 2 ]         CLRA                    ; PREPARE ZERO
8864 f917 5f                 [ 2 ]         CLRB                    ; PREPARE ZERO
8865 f918 dd 46              [ 5 ]         STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
8866 f91a dd 3a              [ 5 ]         STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
8867 f91c dd 3c              [ 5 ]         STD     <TRACEC         ; CLEAR TRACE COUNT
8868 f91e c6 02              [ 2 ]         LDB     #2              ; SET D TO TWO
8869 f920 34 07              [ 8 ]         PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
8870                               * CHECK FOR "QUICK" COMMANDS.
8871 f922 17 04 54           [ 9 ]         LBSR    READC           ; OBTAIN FIRST CHARACTER
8872 f925 30 8d 05 81        [ 9 ]         LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
8873 f929 81 2e              [ 2 ]         CMPA    #'.             ; ? QUICK TRACE
8874 f92b 27 5a              [ 3 ]         BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
8875 f92d 30 8d 04 e9        [ 9 ]         LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
8876 f931 81 2f              [ 2 ]         CMPA    #'/             ; ? OPEN LAST USED MEMORY
8877 f933 27 52              [ 3 ]         BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
8878                               * PROCESS NEXT CHARACTER
8879 f935 81 20              [ 2 ] CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
8880 f937 23 14              [ 3 ]         BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
8881 f939 34 02              [ 6 ]         PSHS   A                ; BUILD ONTO STACK
8882 f93b 6c 5f              [ 7 ]         INC    -1,U             ; COUNT THIS CHARACTER
8883 f93d 81 2f              [ 2 ]         CMPA   #'/              ; ? MEMORY COMMAND
8884 f93f 27 4f              [ 3 ]         BEQ    CMDMEM           ; BRANCH IF SO
8885 f941 17 04 0b           [ 9 ]         LBSR   BLDHXC           ; TREAT AS HEX VALUE
8886 f944 27 02              [ 3 ]         BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
8887 f946 6a 5e              [ 7 ]         DEC    -2,U             ; FLAG AS INVALID NUMBER
8888 f948 17 04 2e           [ 9 ] CMD3    LBSR   READC            ; OBTAIN NEXT CHARACTER
8889 f94b 20 e8              [ 3 ]         BRA    CMD2             ; TEST NEXT CHARACTER
8890                               * GOT COMMAND, NOW SEARCH TABLES
8891 f94d 80 0d              [ 2 ] CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
8892 f94f a7 5d              [ 5 ]         STA    -3,U             ; SETUP FLAG
8893 f951 9e 6f              [ 5 ]         LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
8894 f953 e6 80              [ 6 ] CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
8895 f955 2a 10              [ 3 ]         BPL    CMDSME           ; BRANCH IF NOT LIST END
8896 f957 9e 99              [ 5 ]         LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
8897 f959 5c                 [ 2 ]         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
8898 f95a 27 f7              [ 3 ]         BEQ     CMDSCH          ; BRANCH IF SO
8899 f95c 10 de 40           [ 6 ] CMDBAD  LDS     <PSTACK         ; RESTORE STACK
8900 f95f 30 8d 01 5a        [ 9 ]         LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
8901 f963 3f                 [19 ]         SWI                     ; SEND OUT
8902 f964 02                               FCB     PDATA1          ; TO CONSOLE
8903 f965 20 90              [ 3 ]         BRA     CMD             ; AND TRY AGAIN
8904                               * SEARCH NEXT ENTRY
8905 f967 5a                 [ 2 ] CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
8906 f968 e1 5f              [ 5 ]         CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
8907 f96a 24 03              [ 3 ]         BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
8908 f96c 3a                 [ 3 ] CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
8909 f96d 20 e4              [ 3 ]         BRA     CMDSCH          ; AND TRY NEXT
8910 f96f 31 5d              [ 5 ] CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
8911 f971 a6 5f              [ 5 ]         LDA     -1,U            ; LOAD SIZE+2
8912 f973 80 02              [ 2 ]         SUBA    #2              ; TO ACTUAL SIZE ENTERED
8913 f975 a7 5e              [ 5 ]         STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
8914 f977 5a                 [ 2 ] CMDCMP  DECB                    ; DOWN ONE BYTE
8915 f978 a6 80              [ 6 ]         LDA     ,X+             ; NEXT COMMAND CHARACTER
8916 f97a a1 a2              [ 6 ]         CMPA    ,-Y             ; ? SAME AS THAT ENTERED
8917 f97c 26 ee              [ 3 ]         BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
8918 f97e 6a 5e              [ 7 ]         DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
8919 f980 26 f5              [ 3 ]         BNE     CMDCMP          ; BRANCH IF MORE TO TEST
8920 f982 3a                 [ 3 ]         ABX                     ; TO NEXT ENTRY
8921 f983 ec 1e              [ 6 ]         LDD     -2,X            ; LOAD OFFSET
8922 f985 30 8b              [ 8 ]         LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
8923 f987 6d 5d              [ 7 ] CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
8924 f989 32 c4              [ 4 ]         LEAS    ,U              ; DELETE STACK WORK AREA
8925 f98b ad 1e              [ 8 ]         JSR     -2,X            ; CALL COMMAND
8926 f98d 16 ff 7a           [ 5 ]         LBRA    CMDNOL          ; GO GET NEXT COMMAND
8927 f990 6d 5e              [ 7 ] CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
8928 f992 2b c8              [ 3 ]         BMI     CMDBAD          ; BRANCH ERROR IF NOT
8929 f994 30 88 ae           [ 5 ]         LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
8930 f997 dc 46              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER ENTERED
8931 f999 20 ec              [ 3 ]         BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
8932                               
8933                               ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
8934                               **    DPR->ASSIST09 DIRECT PAGE WORK AREA
8935                               **    Z=1 CARRIAGE RETURN ENTERED
8936                               **    Z=0 NON CARRIAGE RETURN DELIMITER
8937                               **    S=NORMAL RETURN ADDRESS
8938                               ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
8939                               ** AN ERROR FLAG (*).
8940                               **************************************************
8941                               *       ASSIST09 COMMAND TABLES
8942                               * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
8943                               * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
8944                               * THESE BY USING THE VECTOR SWAP FUNCTION.
8945                               *
8946                               * ENTRY FORMAT:
8947                               *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
8948                               *    +1...COMMAND STRING
8949                               *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
8950                               *
8951                               * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
8952                               * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
8953                               *        SECOND COMMAND TABLE.
8954                               * THE -2 TERMINATES COMMAND SEARCHES.
8955                               *****************************************************
8956                               
8957                               * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
8958                               * LIST ENTRY.
8959                               
8960 f99b 04                       CMDTB2  FCB     4               ; TABLE ENTRY LENGTH
8961 f99c 55                               FCC     'U'             ; 'UNASSEMBLE' COMMAND
8962 f99d ea 63                            FDB     CUNAS-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
8963 f99f 04                               FCB     4               ; TABLE ENTRY LENGTH
8964 f9a0 54                               FCC     'T'             ; 'TRACE' COMMAND
8965 f9a1 f6 5f                            FDB     TRACE-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
8966 f9a3 fe                               FCB     -2              ; -2 INDICATES END OF TABLE
8967                               
8968                               * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
8969                               * LIST ENTRY.
8970                               
8971 f9a4                          CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
8972 f9a4 04                               FCB     4
8973 f9a5 42                               FCC     /B/             ; 'BREAKPOINT' COMMAND
8974 f9a6 05 45                            FDB     CBKPT-*
8975 f9a8 04                               FCB     4
8976 f9a9 43                               FCC     /C/             ; 'CALL' COMMAND
8977 f9aa 04 0f                            FDB     CCALL-*
8978 f9ac 04                               FCB     4
8979 f9ad 44                               FCC     /D/             ; 'DISPLAY' COMMAND
8980 f9ae 04 95                            FDB     CDISP-*
8981 f9b0 04                               FCB     4
8982 f9b1 45                               FCC     /E/             ; 'ENCODE' COMMAND
8983 f9b2 05 97                            FDB     CENCDE-*
8984 f9b4 04                               FCB     4
8985 f9b5 47                               FCC     /G/             ; 'GO' COMMAND
8986 f9b6 03 ca                            FDB     CGO-*
8987 f9b8 04                               FCB     4
8988 f9b9 4c                               FCC     /L/             ; 'LOAD' COMMAND
8989 f9ba 04 d5                            FDB     CLOAD-*
8990 f9bc 04                               FCB     4
8991 f9bd 4d                               FCC     /M/             ; 'MEMORY' COMMAND
8992 f9be 04 05                            FDB     CMEM-*
8993 f9c0 04                               FCB     4
8994 f9c1 4e                               FCC     /N/             ; 'NULLS' COMMAND
8995 f9c2 04 f5                            FDB     CNULLS-*
8996 f9c4 04                               FCB     4
8997 f9c5 4f                               FCC     /O/             ; 'OFFSET' COMMAND
8998 f9c6 05 02                            FDB     COFFS-*
8999 f9c8 04                               FCB     4
9000 f9c9 50                               FCC     /P/             ; 'PUNCH' COMMAND
9001 f9ca 04 a7                            FDB     CPUNCH-*
9002 f9cc 04                               FCB     4
9003 f9cd 52                               FCC     /R/             ; 'REGISTERS' COMMAND
9004 f9ce 02 7c                            FDB     CREG-*
9005                               ;       FCB     4
9006                               ;       FCC     /S/             ; 'STLEVEL' COMMAND - NOT SUPPORTED IN THIS VERSION
9007                               ;       FDB     CSTLEV-*
9008                               ;       FCB     4
9009                               ;       FCC     /T/             ; 'TRACE' COMMAND - NOT SUPPORTED IN THIS VERSION
9010                               ;       FDB     CTRACE-*
9011 f9d0 04                               FCB     4
9012 f9d1 56                               FCC     /V/             ; 'VERIFY' COMMAND
9013 f9d2 04 cf                            FDB     CVER-*
9014 f9d4 04                               FCB     4
9015 f9d5 57                               FCC     /W/             ; 'WINDOW' COMMAND
9016 f9d6 04 68                            FDB     CWINDO-*
9017 f9d8 ff                               FCB     -1              ; END, CONTINUE WITH THE SECOND
9018                               
9019                               *************************************************
9020                               *             [SWI FUNCTIONS 4 AND 5]
9021                               *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
9022                               *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
9023                               * INPUT: X->BYTE OR WORD TO DECODE
9024                               * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
9025                               *         X->NEXT BYTE OR WORD
9026                               *************************************************
9027 f9d9 a6 80              [ 6 ] ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
9028 f9db 34 06              [ 7 ]         PSHS    D               ; SAVE - DO NOT REREAD
9029 f9dd c6 10              [ 2 ]         LDB     #16             ; SHIFT BY 4 BITS
9030 f9df 3d                 [11 ]         MUL                     ; WITH MULTIPLY
9031 f9e0 8d 04              [ 7 ]         BSR     ZOUTHX          ; SEND OUT AS HEX
9032 f9e2 35 06              [ 7 ]         PULS    D               ; RESTORE BYTES
9033 f9e4 84 0f              [ 2 ]         ANDA    #$0F            ; ISOLATE RIGHT HEX
9034 f9e6 8b 90              [ 2 ] ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
9035 f9e8 19                 [ 2 ]         DAA                     ; ADJUST
9036 f9e9 89 40              [ 2 ]         ADCA    #$40            ; PREPARE CHARACTER BITS
9037 f9eb 19                 [ 2 ]         DAA                     ; ADJUST
9038 f9ec 6e 9d 85 99        [11 ] SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
9039                               
9040 f9f0 8d e7              [ 7 ] ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
9041 f9f2 8d e5              [ 7 ] ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
9042 f9f4 af 64              [ 6 ]         STX     4,S             ; UPDATE USERS X REGISTER
9043                               * FALL INTO SPACE ROUTINE
9044                               
9045                               *************************************************
9046                               *            [SWI FUNCTION 7]
9047                               *         SPACE - SEND BLANK TO OUTPUT HANDLER
9048                               * INPUT: NONE
9049                               * OUTPUT: BLANK SEND TO CONSOLE HANDLER
9050                               *************************************************
9051 f9f6 86 20              [ 2 ] ZSPACE  LDA     #'              ; LOAD BLANK
9052 f9f8 20 3d              [ 3 ]         BRA     ZOTCH2          ; SEND AND RETURN
9053                               
9054                               ***********************************************
9055                               *             [SWI FUNCTION 9]
9056                               *          SWAP VECTOR TABLE ENTRY
9057                               * INPUT: A=VECTOR TABLE CODE (OFFSET)
9058                               * X=0 OR REPLACEMENT VALUE
9059                               * OUTPUT: X=PREVIOUS VALUE
9060                               ***********************************************
9061 f9fa a6 61              [ 5 ] ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
9062 f9fc 81 34              [ 2 ]         CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
9063 f9fe 22 39              [ 3 ]         BHI     ZOTCH3          ; IGNORE CALL IF SO
9064 fa00 10 9e 6d           [ 6 ]         LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
9065 fa03 ee a6              [ 6 ]         LDU     A,Y             ; U=OLD ENTRY
9066 fa05 ef 64              [ 6 ]         STU     4,S             ; RETURN OLD VALUE TO CALLERS X
9067 fa07 af 7e              [ 6 ]         STX     -2,S            ; ? X=0
9068 fa09 27 2e              [ 3 ]         BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
9069 fa0b af a6              [ 6 ]         STX     A,Y             ; REPLACE ENTRY
9070 fa0d 20 2a              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM SWI
9071                               *D
9072                               
9073                               ************************************************
9074                               *               [SWI FUNCTION 0]
9075                               *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
9076                               * NULLS AND RUBOUTS ARE IGNORED.
9077                               * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
9078                               * CARRIAGE RETURN.
9079                               * UNLESS WE ARE LOADING FROM TAPE.
9080                               ************************************************
9081 fa0f 8d 5d              [ 7 ] ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
9082 fa11 8d 5f              [ 7 ] ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
9083 fa13 24 fa              [ 3 ]         BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
9084 fa15 4d                 [ 2 ]         TSTA                    ; ? TEST FOR NULL
9085 fa16 27 f9              [ 3 ]         BEQ     ZINCH           ; IGNORE NULL
9086 fa18 81 7f              [ 2 ]         CMPA    #$7F            ; ? RUBOUT
9087 fa1a 27 f5              [ 3 ]         BEQ     ZINCH           ; BRANCH YES TO IGNORE
9088 fa1c a7 61              [ 5 ]         STA     1,S             ; STORE INTO CALLERS A
9089 fa1e 0d 3a              [ 6 ]         TST     <MISFLG         ; ? LOAD IN PROGRESS
9090 fa20 26 17              [ 3 ]         BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
9091 fa22 81 0d              [ 2 ]         CMPA    #CR             ; ? CARRIAGE RETURN
9092 fa24 26 04              [ 3 ]         BNE     ZIN2            ; NO, TEST ECHO BYTE
9093 fa26 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
9094 fa28 8d c2              [ 7 ]         BSR     SEND            ; ALWAYS ECHO LINE FEED
9095 fa2a 0d 9f              [ 6 ] ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
9096 fa2c 26 0b              [ 3 ]         BNE     ZOTCH3          ; NO, RETURN
9097                               * FALL THROUGH TO OUTCH
9098                               ************************************************
9099                               *            [SWI FUNCTION 1]
9100                               *        OUTCH - OUTPUT CHARACTER FROM A
9101                               * INPUT: NONE
9102                               * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
9103                               * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
9104                               ************************************************
9105 fa2e a6 61              [ 5 ] ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
9106 fa30 30 8c 09           [ 5 ]         LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
9107 fa33 81 0a              [ 2 ]         CMPA    #LF             ; ? LINE FEED
9108 fa35 27 0f              [ 3 ]         BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
9109 fa37 8d b3              [ 7 ] ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
9110 fa39 0c 3b              [ 6 ] ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
9111 fa3b 3b                 [15 ]         RTI                     ; RETURN FROM "SWI" FUNCTION
9112                               
9113                               **************************************************
9114                               * [SWI FUNCTION 6]
9115                               * PCRLF - SEND CR/LF TO CONSOLE HANDLER
9116                               * INPUT: NONE
9117                               * OUTPUT: CR AND LF SENT TO HANDLER
9118                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
9119                               **************************************************
9120 fa3c 04                       ZPCRLS  FCB     EOT             ; NULL STRING
9121 fa3d 30 8c fc           [ 5 ] ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
9122                               * FALL INTO CR/LF CODE
9123                               
9124                               **************************************************
9125                               * [SWI FUNCTION 3]
9126                               * PDATA - OUTPUT CR/LF AND STRING
9127                               * INPUT: X->STRING
9128                               * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
9129                               * HANDLER.
9130                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
9131                               * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
9132                               * PROPER PUNCH DATA.
9133                               **************************************************
9134                               
9135 fa40 86 0d              [ 2 ] ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
9136 fa42 8d a8              [ 7 ]         BSR     SEND            ; SEND IT
9137 fa44 86 0a              [ 2 ]         LDA     #LF             ; LOAD LINE FEED
9138                               * FALL INTO PDATA1
9139                               
9140                               *************************************************
9141                               * [SWI FUNCTION 2]
9142                               * PDATA1 - OUTPUT STRING TILL EOT ($04)
9143                               * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
9144                               * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
9145                               * SECOND IS RECEIVED.
9146                               * INPUT: X->STRING
9147                               * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
9148                               * C=0 NO CTL-X, C=1 CTL-X RECEIVED
9149                               *************************************************
9150                               
9151 fa46 8d a4              [ 7 ] ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
9152 fa48 a6 80              [ 6 ] ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
9153 fa4a 81 04              [ 2 ]         CMPA    #EOT            ; ? EOT
9154 fa4c 26 f8              [ 3 ]         BNE     ZPDTLP          ; LOOP IF NOT
9155                               * FALL INTO PAUSE CHECK FUNCTION
9156                               
9157                               ********************************************
9158                               * [SWI FUNCTION 12]
9159                               * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
9160                               * FOR FREEZE CONDITION OR CTL-X BREAK
9161                               * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
9162                               * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
9163                               * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
9164                               * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
9165                               * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
9166                               * HANDLER.
9167                               * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
9168                               ******************************************
9169                               
9170 fa4e 8d 1e              [ 7 ] ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
9171 fa50 8d 06              [ 7 ]         BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
9172 fa52 1f a9              [ 6 ]         TFR     CC,B            ; PREPARE TO REPLACE CC
9173 fa54 e7 e4              [ 4 ]         STB     ,S              ; OVERLAY OLD ONE ON STACK
9174 fa56 20 e1              [ 3 ]         BRA     ZOTCH3          ; RETURN FROM "SWI"
9175                               
9176                               * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
9177                               * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
9178                               * VOLATILE: U,X,D
9179 fa58 8d 18              [ 7 ] CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
9180 fa5a 24 05              [ 3 ]         BCC     CHKRTN          ; BRANCH NO TO RETURN
9181 fa5c 81 18              [ 2 ]         CMPA    #CAN            ; ? CTL-X FOR ABORT
9182 fa5e 26 02              [ 3 ]         BNE     CHKWT           ; BRANCH NO TO PAUSE
9183 fa60 53                 [ 2 ] CHKSEC  COMB                    ; SET CARRY
9184 fa61 39                 [ 5 ] CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
9185 fa62 8d 0a              [ 7 ] CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
9186 fa64 8d 0c              [ 7 ]         BSR     XQCIDT          ; ? KEY FOR START
9187 fa66 24 fa              [ 3 ]         BCC     CHKWT           ; LOOP UNTIL RECEIVED
9188 fa68 81 18              [ 2 ]         CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
9189 fa6a 27 f4              [ 3 ]         BEQ     CHKSEC          ; BRANCH YES
9190 fa6c 4f                 [ 2 ]         CLRA                    ; SET C=0 FOR NO ABORT
9191 fa6d 39                 [ 5 ]         RTS                     ; AND RETURN
9192                               
9193                               * SAVE MEMORY WITH JUMPS
9194 fa6e 6e 9d 85 23        [11 ] XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
9195 fa72 ad 9d 85 0d        [15 ] XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
9196 fa76 84 7f              [ 2 ]         ANDA  #$7F              ; STRIP PARITY
9197 fa78 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
9198                               
9199                               ********************************************
9200                               * NMI DEFAULT INTERRUPT HANDLER
9201                               * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
9202                               * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
9203                               * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
9204                               * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
9205                               * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
9206                               *********************************************
9207                               
9208 fa79 4f 50 2d 04              MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
9209                               
9210 fa7d 8d 42              [ 7 ] NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
9211 fa7f 0d 3a              [ 6 ]         TST     <MISFLG         ; ? THRU A BREAKPOINT
9212 fa81 26 34              [ 3 ]         BNE     NMICON          ; BRANCH IF SO TO CONTINUE
9213 fa83 0d 3b              [ 6 ]         TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
9214 fa85 2b 29              [ 3 ]         BMI     NMITRC          ; BRANCH YES
9215 fa87 30 6c              [ 5 ]         LEAX    12,S            ; OBTAIN USERS STACK POINTER
9216 fa89 9c a3              [ 6 ]         CMPX    <SLEVEL         ; ? TO TRACE HERE
9217 fa8b 25 23              [ 3 ]         BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
9218 fa8d 30 8c e9           [ 5 ]         LEAX    MSHOWP,PCR      ; LOAD OP PREP
9219 fa90 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
9220 fa91 02                               FCB     PDATA1          ; FUNCTION
9221 fa92 09 39              [ 6 ]         ROL     <DELIM          ; SAVE CARRY BIT
9222 fa94 30 8d 84 ac        [ 9 ]         LEAX    LASTOP,PCR      ; POINT TO LAST OP
9223 fa98 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
9224 fa99 05                               FCB     OUT4HS          ; FUNCTION
9225 fa9a 8d 17              [ 7 ]         BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
9226 fa9c 25 37              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
9227 fa9e 06 39              [ 6 ]         ROR     <DELIM          ; RESTORE CARRY BIT
9228 faa0 25 33              [ 3 ]         BCS     ZBKCMD          ; BRANCH IF "CANCEL"
9229 faa2 9e 3c              [ 5 ]         LDX     <TRACEC         ; LOAD TRACE COUNT
9230 faa4 27 2f              [ 3 ]         BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
9231 faa6 30 1f              [ 5 ]         LEAX    -1,X            ; MINUS ONE
9232 faa8 9f 3c              [ 5 ]         STX     <TRACEC         ; REFRESH
9233 faaa 27 29              [ 3 ]         BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
9234 faac 8d aa              [ 7 ]         BSR     CHKABT          ; ? ABORT THE TRACE
9235 faae 25 25              [ 3 ]         BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
9236 fab0 16 03 f7           [ 5 ] NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
9237                               
9238 fab3 17 01 b9           [ 9 ] REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
9239 fab6 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
9240                               
9241                               * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
9242                               
9243 fab7 0f 3a              [ 6 ] NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
9244 fab9 17 02 eb           [ 9 ]         LBSR    ARMBK2         ; ARM BREAKPOINTS
9245 fabc 3b                 [15 ] RTI     RTI                    ; AND CONTINUE USERS PROGRAM
9246                               
9247                               * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
9248                               * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
9249                               * HANDLER.
9250                               * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
9251                               * OUTPUT: DPR LOADED TO WORK PAGE
9252                               
9253 fabd 3f 07 20 04              ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
9254                               
9255 fac1 e6 8d 84 83        [ 9 ] LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
9256 fac5 1f 9b              [ 6 ]         TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
9257 fac7 a1 63              [ 5 ]         CMPA    3,S             ; ? IS STACK VALID
9258 fac9 27 25              [ 3 ]         BEQ     RTS             ; YES, RETURN
9259 facb 10 de 42           [ 6 ]         LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
9260 face 30 8c ec           [ 5 ] ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
9261 fad1 3f                 [19 ]         SWI                     ; SEND OUT BEFORE REGISTERS
9262 fad2 03                               FCB     PDATA           ; ON NEXT LINE
9263                               * FALL INTO BREAKPOINT HANDLER
9264                               
9265                               **********************************************
9266                               * [SWI FUNCTION 10]
9267                               * BREAKPOINT PROGRAM FUNCTION
9268                               * PRINT REGISTERS AND GO TO COMMAND HANLER
9269                               ***********************************************
9270                               
9271 fad3 8d de              [ 7 ] ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
9272 fad5 16 fe 21           [ 5 ] ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
9273                               
9274                               ********************************************
9275                               * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
9276                               * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
9277                               ********************************************
9278 fad8                          SWI2R   EQU     *               ; SWI2 ENTRY
9279 fad8                          SWI3R   EQU     *               ; SWI3 ENTRY
9280 fad8                          IRQR    EQU     *               ; IRQ ENTRY
9281 fad8 8d e7              [ 7 ] RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
9282 fada 20 f7              [ 3 ]         BRA     ZBKPNT          ; FORCE A BREAKPOINT
9283                               
9284                               ******************************************
9285                               * FIRQ HANDLER
9286                               * JUST RETURN FOR THE FIRQ INTERRUPT
9287                               ******************************************
9288 fabc                          FIRQR   EQU     RTI             ; IMMEDIATE RETURN
9289                               
9290                               **************************************************
9291                               * DEFAULT I/O DRIVERS
9292                               **************************************************
9293                               * CIDTA - RETURN CONSOLE INPUT CHARACTER
9294                               * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
9295                               * U VOLATILE
9296                               
9297 fadc de 9b              [ 5 ] CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
9298 fade a6 c4              [ 4 ]         LDA     ,U              ; LOAD STATUS REGISTER
9299 fae0 44                 [ 2 ]         LSRA                    ; TEST RECEIVER REGISTER FLAG
9300 fae1 24 02              [ 3 ]         BCC     CIRTN           ; RETURN IF NOTHING
9301 fae3 a6 41              [ 5 ]         LDA     1,U             ; LOAD DATA BYTE
9302 fae5 39                 [ 5 ] CIRTN   RTS                     ; RETURN TO CALLER
9303                               
9304                               * CION - INPUT CONSOLE INITIALIZATION
9305                               * COON - OUTPUT CONSOLE INITIALIZATION
9306                               * A,X VOLATILE
9307 fae6                          CION   EQU      *
9308 fae6 86 13              [ 2 ] COON   LDA      #$13            ; RESET ACIA CODE
9309 fae8 9e 9b              [ 5 ]        LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
9310 faea a7 84              [ 4 ]        STA      ,X              ; STORE INTO STATUS REGISTER
9311 faec 86 15              [ 2 ]        LDA      #$15            ; SET CONTROL
9312 faee a7 84              [ 4 ]        STA      ,X              ; REGISTER UP
9313 faf0 39                 [ 5 ] RTS    RTS                      ; RETURN TO CALLER
9314                               
9315                               * THE FOLLOWING HAVE NO DUTIES TO PERFORM
9316 faf0                          CIOFF EQU       RTS             ; CONSOLE INPUT OFF
9317 faf0                          COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
9318                               
9319                               * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
9320                               * INPUT: A=CHARACTER TO SEND
9321                               * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
9322                               * ALL REGISTERS TRANSPARENT
9323                               
9324 faf1 34 47              [10 ] CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
9325 faf3 de 9b              [ 5 ]         LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
9326 faf5 8d 1b              [ 7 ]         BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
9327 faf7 81 10              [ 2 ]         CMPA    #DLE            ; ? DATA LINE ESCAPE
9328 faf9 27 12              [ 3 ]         BEQ     CODTRT          ; YES, RETURN
9329 fafb d6 9d              [ 4 ]         LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
9330 fafd 81 0d              [ 2 ]         CMPA    #CR             ; ? CR
9331 faff 26 02              [ 3 ]         BNE     CODTPD          ; BRANCH NO
9332 fb01 d6 9e              [ 4 ]         LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
9333 fb03 4f                 [ 2 ] CODTPD  CLRA                    ; CREATE NULL
9334 fb04 e7 e4              [ 4 ]         STB     ,S              ; SAVE COUNT
9335 fb06 8c                               FCB     SKIP2           ; ENTER LOOP
9336 fb07 8d 09              [ 7 ] CODTLP  BSR     CODTAO          ; SEND NULL
9337 fb09 6a e4              [ 6 ]         DEC     ,S              ; ? FINISHED
9338 fb0b 2a fa              [ 3 ]         BPL     CODTLP          ; NO, CONTINUE WITH MORE
9339 fb0d 35 c7              [12 ] CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
9340                               
9341 fb0f 17 ff 5c           [ 9 ] CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
9342 fb12 e6 c4              [ 4 ] CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
9343 fb14 c5 02              [ 2 ]         BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
9344 fb16 27 f7              [ 3 ]         BEQ     CODTAD          ; RELEASE CONTROL IF NOT
9345 fb18 a7 41              [ 5 ]         STA     1,U             ; STORE INTO DATA REGISTER
9346 fb1a 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
9347                               *E
9348                               
9349                               * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
9350                               * A IS VOLATILE
9351                               
9352 fb1b 86 11              [ 2 ] BSON    LDA     #$11            ; SET READ CODE
9353 fb1d 6d 66              [ 7 ]         TST     6,S             ; ? READ OR VERIFY
9354 fb1f 26 01              [ 3 ]         BNE     BSON2           ; BRANCH YES
9355 fb21 4c                 [ 2 ]         INCA                    ; SET TO WRITE
9356 fb22 3f                 [19 ] BSON2   SWI                     ; PERFORM OUTPUT
9357 fb23 01                               FCB     OUTCH           ; FUNCTION
9358 fb24 0c 3a              [ 6 ]         INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
9359 fb26 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
9360                               
9361                               * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
9362                               * A,X VOLATILE
9363                               
9364 fb27 86 14              [ 2 ] BSOFF   LDA     #$14            ; TO DC4 - STOP
9365 fb29 3f                 [19 ]         SWI                     ; SEND OUT
9366 fb2a 01                               FCB     OUTCH           ; FUNCTION
9367 fb2b 4a                 [ 2 ]         DECA                    ; CHANGE TO DC3 (X-OFF)
9368 fb2c 3f                 [19 ]         SWI                     ; SEND OUT
9369 fb2d 01                               FCB     OUTCH           ; FUNCTION
9370 fb2e 0a 3a              [ 6 ]         DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
9371 fb30 8e 61 a8           [ 3 ]         LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
9372 fb33 30 1f              [ 5 ] BSOFLP  LEAX    -1,X            ; COUNT DOWN
9373 fb35 26 fc              [ 3 ]         BNE     BSOFLP          ; LOOP TILL DONE
9374 fb37 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
9375                               
9376                               * BSDTA - READ/VERIFY/PUNCH HANDLER
9377                               * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
9378                               * S+4=START ADDRESS
9379                               * S+2=STOP ADDRESS
9380                               * S+0=RETURN ADDRESS
9381                               * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
9382                               * REGISTERS ARE VOLATILE
9383 fb38 ee 62              [ 6 ] BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
9384 fb3a 6d 66              [ 7 ]         TST     6,S             ; ? PUNCH
9385 fb3c 27 54              [ 3 ]         BEQ     BSDPUN          ; BRANCH YES
9386                               
9387                               * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
9388                               * S+1=BYTE COUNTER
9389                               * S+0=CHECKSUM
9390                               * U HOLDS OFFSET
9391 fb3e 32 7d              [ 5 ]         LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
9392 fb40 3f                 [19 ] BSDLD1  SWI                     ; GET NEXT CHARACTER
9393 fb41 00                               FCB     INCHNP          ; FUNCTION
9394 fb42 81 53              [ 2 ] BSDLD2  CMPA    #'S             ; ? START OF S1/S9
9395 fb44 26 fa              [ 3 ]         BNE     BSDLD1          ; BRANCH NOT
9396 fb46 3f                 [19 ]         SWI                     ; GET NEXT CHARACTER
9397 fb47 00                               FCB     INCHNP          ; FUNCTION
9398 fb48 81 39              [ 2 ]         CMPA    #'9             ; ? HAVE S9
9399 fb4a 27 22              [ 3 ]         BEQ     BSDSRT          ; YES, RETURN GOOD CODE
9400 fb4c 81 31              [ 2 ]         CMPA    #'1             ; ? HAVE NEW RECORD
9401 fb4e 26 f2              [ 3 ]         BNE     BSDLD2          ; BRANCH IF NOT
9402 fb50 6f e4              [ 6 ]         CLR     ,S              ; CLEAR CHECKSUM
9403 fb52 8d 21              [ 7 ]         BSR     BYTE            ; OBTAIN BYTE COUNT
9404 fb54 e7 61              [ 5 ]         STB     1,S             ; SAVE FOR DECREMENT
9405                               
9406                               * READ ADDRESS
9407 fb56 8d 1d              [ 7 ]         BSR     BYTE            ; OBTAIN HIGH VALUE
9408 fb58 e7 62              [ 5 ]         STB     2,S             ; SAVE IT
9409 fb5a 8d 19              [ 7 ]         BSR     BYTE            ; OBTAIN LOW VALUE
9410 fb5c a6 62              [ 5 ]         LDA     2,S             ; MAKE D=VALUE
9411 fb5e 31 cb              [ 8 ]         LEAY    D,U             ; Y=ADDRESS+OFFSET
9412                               * STORE TEXT
9413 fb60 8d 13              [ 7 ] BSDNXT  BSR     BYTE            ; NEXT BYTE
9414 fb62 27 0c              [ 3 ]         BEQ     BSDEOL          ; BRANCH IF CHECKSUM
9415 fb64 6d 69              [ 7 ]         TST     9,S             ; ? VERIFY ONLY
9416 fb66 2b 02              [ 3 ]         BMI     BSDCMP          ; YES, ONLY COMPARE
9417 fb68 e7 a4              [ 4 ]         STB     ,Y              ; STORE INTO MEMORY
9418 fb6a e1 a0              [ 6 ] BSDCMP  CMPB    ,Y+             ; ? VALID RAM
9419 fb6c 27 f2              [ 3 ]         BEQ     BSDNXT          ; YES, CONTINUE READING
9420 fb6e 35 92              [10 ] BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
9421 fb70 4c                 [ 2 ] BSDEOL  INCA                    ; ? VALID CHECKSUM
9422 fb71 27 cd              [ 3 ]         BEQ     BSDLD1          ; BRANCH YES
9423 fb73 20 f9              [ 3 ]         BRA     BSDSRT          ; RETURN Z=0 INVALID
9424                               
9425                               * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
9426 fb75 8d 12              [ 7 ] BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
9427 fb77 c6 10              [ 2 ]         LDB     #16            ; PREPARE SHIFT
9428 fb79 3d                 [11 ]         MUL                    ; OVER TO A
9429 fb7a 8d 0d              [ 7 ]         BSR     BYTHEX         ; OBTAIN SECOND HEX
9430 fb7c 34 04              [ 6 ]         PSHS    B              ; SAVE HIGH HEX
9431 fb7e ab e0              [ 6 ]         ADDA    ,S+            ; COMBINE BOTH SIDES
9432 fb80 1f 89              [ 6 ]         TFR     A,B            ; SEND BACK IN B
9433 fb82 ab 62              [ 5 ]         ADDA    2,S            ; COMPUTE NEW CHECKSUM
9434 fb84 a7 62              [ 5 ]         STA     2,S            ; STORE BACK
9435 fb86 6a 63              [ 7 ]         DEC     3,S            ; DECREMENT BYTE COUNT
9436 fb88 39                 [ 5 ] BYTRTS  RTS                    ; RETURN TO CALLER
9437                               
9438 fb89 3f                 [19 ] BYTHEX  SWI                    ; GET NEXT HEX
9439 fb8a 00                               FCB     INCHNP         ; CHARACTER
9440 fb8b 17 01 d4           [ 9 ]         LBSR    CNVHEX         ; CONVERT TO HEX
9441 fb8e 27 f8              [ 3 ]         BEQ     BYTRTS         ; RETURN IF VALID HEX
9442 fb90 35 f2              [14 ]         PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
9443                               
9444                               * PUNCH STACK USE: S+8=TO ADDRESS
9445                               *                  S+6=RETURN ADDRESS
9446                               *                  S+4=SAVED PADDING VALUES
9447                               *                  S+2 FROM ADDRESS
9448                               *                  S+1=FRAME COUNT/CHECKSUM
9449                               *                  S+0=BYTE COUNT
9450                               
9451 fb92 de 9d              [ 5 ] BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
9452 fb94 ae 64              [ 6 ]         LDX     4,S             ; X=FROM ADDRESS
9453 fb96 34 56              [11 ]         PSHS    U,X,D           ; CREATE STACK WORK AREA
9454 fb98 cc 00 18           [ 3 ]         LDD     #24             ; SET A=0, B=24
9455 fb9b d7 9d              [ 4 ]         STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
9456 fb9d 3f                 [19 ]         SWI                     ; SEND NULLS OUT
9457 fb9e 01                               FCB     OUTCH           ; FUNCTION
9458 fb9f c6 04              [ 2 ]         LDB     #4              ; SETUP NEW LINE PAD TO 4
9459 fba1 dd 9d              [ 5 ]         STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
9460                               * CALCULATE SIZE
9461 fba3 ec 68              [ 6 ] BSPGO   LDD     8,S             ; LOAD TO
9462 fba5 a3 62              [ 7 ]         SUBD    2,S             ; MINUS FROM=LENGTH
9463 fba7 10 83 00 18        [ 5 ]         CMPD    #24             ; ? MORE THAN 23
9464 fbab 25 02              [ 3 ]         BLO     BSPOK           ; NO, OK
9465 fbad c6 17              [ 2 ]         LDB     #23             ; FORCE TO 23 MAX
9466 fbaf 5c                 [ 2 ] BSPOK   INCB                    ; PREPARE COUNTER
9467 fbb0 e7 e4              [ 4 ]         STB     ,S              ; STORE BYTE COUNT
9468 fbb2 cb 03              [ 2 ]         ADDB    #3              ; ADJUST TO FRAME COUNT
9469 fbb4 e7 61              [ 5 ]         STB     1,S             ; SAVE
9470                               
9471                               *PUNCH CR,LF,NULS,S,1
9472 fbb6 30 8c 33           [ 5 ]        LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
9473 fbb9 3f                 [19 ]        SWI                      ; SEND OUT
9474 fbba 03                              FCB      PDATA           ; FUNCTION
9475                               * SEND FRAME COUNT
9476 fbbb 5f                 [ 2 ]        CLRB                     ; INITIALIZE CHECKSUM
9477 fbbc 30 61              [ 5 ]        LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
9478 fbbe 8d 27              [ 7 ]        BSR      BSPUN2          ; SEND FRAME COUNT
9479                               *DATA ADDRESS
9480 fbc0 8d 25              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS HI
9481 fbc2 8d 23              [ 7 ]       BSR       BSPUN2          ; SEND ADDRESS LOW
9482                               *PUNCH DATA
9483 fbc4 ae 62              [ 6 ]        LDX      2,S             ; LOAD START DATA ADDRESS
9484 fbc6 8d 1f              [ 7 ] BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
9485 fbc8 6a e4              [ 6 ]        DEC      ,S              ; ? FINAL BYTE
9486 fbca 26 fa              [ 3 ]        BNE      BSPMRE          ; LOOP IF NOT DONE
9487 fbcc af 62              [ 6 ]        STX      2,S             ; UPDATE FROM ADDRESS VALUE
9488                               *PUNCH CHECKSUM
9489 fbce 53                 [ 2 ]        COMB                     ; COMPLEMENT
9490 fbcf e7 61              [ 5 ]        STB      1,S             ; STORE FOR SENDOUT
9491 fbd1 30 61              [ 5 ]        LEAX     1,S             ; POINT TO IT
9492 fbd3 8d 14              [ 7 ]        BSR      BSPUNC          ; SEND OUT AS HEX
9493 fbd5 ae 68              [ 6 ]        LDX      8,S             ; LOAD TOP ADDRESS
9494 fbd7 ac 62              [ 7 ]        CMPX     2,S             ; ? DONE
9495 fbd9 24 c8              [ 3 ]        BHS      BSPGO           ; BRANCH NOT
9496 fbdb 30 8c 11           [ 5 ]        LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
9497 fbde 3f                 [19 ]        SWI                      ; SEND OUT STRING
9498 fbdf 03                              FCB      PDATA           ; FUNCTION
9499 fbe0 ec 64              [ 6 ]        LDD      4,S             ; RECOVER PAD COUNTS
9500 fbe2 dd 9d              [ 5 ]        STD      <VECTAB+.PAD    ; RESTORE
9501 fbe4 4f                 [ 2 ]        CLRA                     ; SET Z=1 FOR OK RETURN
9502 fbe5 35 d6              [13 ]        PULS     PC,U,X,D        ; RETURN WITH OK CODE
9503 fbe7 eb 84              [ 4 ] BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
9504 fbe9 16 fd ed           [ 5 ] BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
9505                               
9506 fbec 53 31 04                 BSPSTR FCB      'S,'1,EOT       ; CR,LF,NULLS,S,1
9507 fbef 53 39 30 33 30 30        BSPEOF FCC      /S9030000FC/    ; EOF STRING
     30 30 46 43
9508 fbf9 0d 0a 04                        FCB      CR,LF,EOT
9509                               
9510                               * HSDTA - HIGH SPEED PRINT MEMORY
9511                               * INPUT: S+4=START ADDRESS
9512                               * S+2=STOP ADDRESS
9513                               * S+0=RETURN ADDRESS
9514                               * X,D VOLATILE
9515                               
9516                               * SEND TITLE
9517                               
9518 fbfc 3f                 [19 ] HSDTA   SWI                     ; SEND NEW LINE
9519 fbfd 06                               FCB     PCRLF           ; FUNCTION
9520 fbfe c6 06              [ 2 ]         LDB     #6              ; PREPARE 6 SPACES
9521 fc00 3f                 [19 ] HSBLNK  SWI                     ; SEND BLANK
9522 fc01 07                               FCB     SPACEF          ; FUNCTION
9523 fc02 5a                 [ 2 ]         DECB                    ; COUNT DOWN
9524 fc03 26 fb              [ 3 ]         BNE     HSBLNK          ; LOOP IF MORE
9525 fc05 5f                 [ 2 ]         CLRB                    ; SETUP BYTE COUNT
9526 fc06 1f 98              [ 6 ] HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
9527 fc08 17 fd db           [ 9 ]         LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
9528 fc0b 3f                 [19 ]         SWI                     ; SEND BLANK
9529 fc0c 07                               FCB     SPACEF          ; FUNCTION
9530 fc0d 3f                 [19 ]         SWI                     ; SEND ANOTHER
9531 fc0e 07                               FCB     SPACEF          ; BLANK
9532 fc0f 5c                 [ 2 ]         INCB                    ; UP ANOTHER
9533 fc10 c1 10              [ 2 ]         CMPB    #$10            ; ? PAST 'F'
9534 fc12 25 f2              [ 3 ]         BLO     HSHTTL          ; LOOP UNTIL SO
9535 fc14 3f                 [19 ] HSHLNE  SWI                     ; TO NEXT LINE
9536 fc15 06                               FCB     PCRLF           ; FUNCTION
9537 fc16 25 2f              [ 3 ]         BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
9538 fc18 30 64              [ 5 ]         LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
9539 fc1a 3f                 [19 ]         SWI                     ; PRINT OUT ADDRESS
9540 fc1b 05                               FCB     OUT4HS          ; FUNCTION
9541 fc1c ae 64              [ 6 ]         LDX     4,S             ; LOAD ADDRESS PROPER
9542 fc1e c6 10              [ 2 ]         LDB     #16             ; NEXT SIXTEEN
9543 fc20 3f                 [19 ] HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
9544 fc21 04                               FCB     OUT2HS          ; FUNCTION
9545 fc22 5a                 [ 2 ]         DECB                    ; COUNT DOWN
9546 fc23 26 fb              [ 3 ]         BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
9547 fc25 3f                 [19 ]         SWI                     ; SEND BLANK
9548 fc26 07                               FCB     SPACEF          ; FUNCTION
9549 fc27 ae 64              [ 6 ]         LDX     4,S             ; RELOAD FROM ADDRESS
9550 fc29 c6 10              [ 2 ]         LDB     #16             ; COUNT
9551 fc2b a6 80              [ 6 ] HSHCHR  LDA     ,X+             ; NEXT BYTE
9552 fc2d 2b 04              [ 3 ]         BMI     HSHDOT          ; TOO LARGE, TO A DOT
9553 fc2f 81 20              [ 2 ]         CMPA    #'              ; ? LOWER THAN A BLANK
9554 fc31 24 02              [ 3 ]         BHS     HSHCOK          ; NO, BRANCH OK
9555 fc33 86 2e              [ 2 ] HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
9556 fc35 3f                 [19 ] HSHCOK  SWI                     ; SEND CHARACTER
9557 fc36 01                               FCB     OUTCH           ; FUNCTION
9558 fc37 5a                 [ 2 ]         DECB                    ; ? DONE
9559 fc38 26 f1              [ 3 ]         BNE     HSHCHR          ; BRANCH NO
9560 fc3a ac 62              [ 7 ]         CPX     2,S             ; ? PAST LAST ADDRESS
9561 fc3c 24 09              [ 3 ]         BHS     HSDRTN          ; QUIT IF SO
9562 fc3e af 64              [ 6 ]         STX     4,S             ; UPDATE FROM ADDRESS
9563 fc40 a6 65              [ 5 ]         LDA     5,S             ; LOAD LOW BYTE ADDRESS
9564 fc42 48                 [ 2 ]         ASLA                    ; ? TO SECTION BOUNDARY
9565 fc43 26 cf              [ 3 ]         BNE     HSHLNE          ; BRANCH IF NOT
9566 fc45 20 b5              [ 3 ]         BRA     HSDTA           ; BRANCH IF SO
9567 fc47 3f                 [19 ] HSDRTN  SWI                     ; SEND NEW LINE
9568 fc48 06                               FCB     PCRLF           ; FUNCTION
9569 fc49 39                 [ 5 ]         RTS                     ; RETURN TO CALLER
9570                               *F
9571                               
9572                               ***********************************************
9573                               *     A S S I S T 0 9    C O M M A N D S
9574                               ***********************************************
9575                               
9576                               *************REGISTERS - DISPLAY AND CHANGE REGISTERS
9577 fc4a 8d 23              [ 7 ] CREG    BSR     REGPRT          ; PRINT REGISTERS
9578 fc4c 4c                 [ 2 ]         INCA                    ; SET FOR CHANGE FUNCTION
9579 fc4d 8d 21              [ 7 ]         BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
9580 fc4f 39                 [ 5 ]         RTS                     ; RETURN TO COMMAND PROCESSOR
9581                               
9582                               ********************************************
9583                               * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
9584                               * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
9585                               * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
9586                               * DONE.
9587                               
9588                               * REGISTER MASK LIST CONSISTS OF:
9589                               * A) CHARACTERS DENOTING REGISTER
9590                               * B) ZERO FOR ONE BYTE, -1 FOR TWO
9591                               * C) OFFSET ON STACK TO REGISTER POSITION
9592                               * INPUT: SP+4=STACKED REGISTERS
9593                               * A=0 PRINT, A#0 PRINT AND CHANGE
9594                               * OUTPUT: (ONLY FOR REGISTER DISPLAY)
9595                               * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
9596                               * VOLATILE: D,X (CHANGE)
9597                               * B,X (DISPLAY)
9598                               *******************************************
9599                               
9600 fc50 50 43 ff 13              REGMSK  FCB     'P,'C,-1,19     ; PC REG
9601 fc54 41 00 0a                         FCB     'A,0,10         ; A REG
9602 fc57 42 00 0b                         FCB     'B,0,11         ; B REG
9603 fc5a 58 ff 0d                         FCB     'X,-1,13        ; X REG
9604 fc5d 59 ff 0f                         FCB     'Y,-1,15        ; Y REG
9605 fc60 55 ff 11                         FCB     'U,-1,17        ; U REG
9606 fc63 53 ff 01                         FCB     'S,-1,1         ; S REG
9607 fc66 43 43 00 09                      FCB     'C,'C,0,9       ; CC REG
9608 fc6a 44 50 00 0c                      FCB     'D,'P,0,12      ; DP REG
9609 fc6e 00                               FCB     0               ; END OF LIST
9610                               
9611 fc6f 4f                 [ 2 ] REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
9612 fc70 30 e8 10           [ 5 ] REGCHG  LEAX    4+12,S          ; READY STACK VALUE
9613 fc73 34 32              [10 ]         PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
9614 fc75 31 8c d8           [ 5 ]         LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
9615 fc78 ec a0              [ 7 ] REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
9616 fc7a 4d                 [ 2 ]         TSTA                    ; ? END OF CHARACTERS
9617 fc7b 2f 04              [ 3 ]         BLE     REGP2           ; BRANCH NOT CHARACTER
9618 fc7d 3f                 [19 ]         SWI                     ; SEND TO CONSOLE
9619 fc7e 01                               FCB     OUTCH           ; FUNCTION BYTE
9620 fc7f 20 f7              [ 3 ]         BRA     REGP1           ; CHECK NEXT
9621 fc81 86 2d              [ 2 ] REGP2   LDA     #'-             ; READY '-'
9622 fc83 3f                 [19 ]         SWI                     ; SEND OUT
9623 fc84 01                               FCB     OUTCH           ; WITH OUTCH
9624 fc85 30 e5              [ 5 ]         LEAX    B,S             ; X->REGISTER TO PRINT
9625 fc87 6d e4              [ 6 ]         TST     ,S              ; ? CHANGE OPTION
9626 fc89 26 12              [ 3 ]         BNE     REGCNG          ; BRANCH YES
9627 fc8b 6d 3f              [ 7 ]         TST     -1,Y            ; ? ONE OR TWO BYTES
9628 fc8d 27 03              [ 3 ]         BEQ     REGP3           ; BRANCH ZERO MEANS ONE
9629 fc8f 3f                 [19 ]         SWI                     ; PERFORM WORD HEX
9630 fc90 05                               FCB     OUT4HS          ; FUNCTION
9631 fc91 8c                               FCB     SKIP2           ; SKIP BYTE PRINT
9632 fc92 3f                 [19 ] REGP3   SWI                     ; PERFORM BYTE HEX
9633 fc93 04                               FCB     OUT2HS          ; FUNCTION
9634 fc94 ec a0              [ 7 ] REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
9635 fc96 5d                 [ 2 ]         TSTB                    ; ? END OF ENTRIES
9636 fc97 26 df              [ 3 ]         BNE     REGP1           ; LOOP IF MORE
9637 fc99 3f                 [19 ]         SWI                     ; FORCE NEW LINE
9638 fc9a 06                               FCB     PCRLF           ; FUNCTION
9639 fc9b 35 b2              [12 ] REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
9640                               
9641 fc9d 8d 40              [ 7 ] REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
9642 fc9f 27 10              [ 3 ]         BEQ     REGNXC          ; IF CHANGE THEN JUMP
9643 fca1 81 0d              [ 2 ]         CMPA    #CR             ; ? NO MORE DESIRED
9644 fca3 27 1e              [ 3 ]         BEQ     REGAGN          ; BRANCH NOPE
9645 fca5 e6 3f              [ 5 ]         LDB     -1,Y            ; LOAD SIZE FLAG
9646 fca7 5a                 [ 2 ]         DECB                    ; MINUS ONE
9647 fca8 50                 [ 2 ]         NEGB                    ; MAKE POSITIVE
9648 fca9 58                 [ 2 ]         ASLB                    ; TIMES TWO (=2 OR =4)
9649 fcaa 3f                 [19 ] REGSKP  SWI                     ; PERFORM SPACES
9650 fcab 07                               FCB     SPACEF          ; FUNCTION
9651 fcac 5a                 [ 2 ]         DECB
9652 fcad 26 fb              [ 3 ]         BNE     REGSKP          ; LOOP IF MORE
9653 fcaf 20 e3              [ 3 ]         BRA     REG4            ; CONTINUE WITH NEXT REGISTER
9654 fcb1 a7 e4              [ 4 ] REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
9655                               *                               ; (ALWAYS > 0)
9656 fcb3 dc 46              [ 5 ]         LDD     <NUMBER         ; OBTAIN BINARY RESULT
9657 fcb5 6d 3f              [ 7 ]         TST     -1,Y            ; ? TWO BYTES WORTH
9658 fcb7 26 02              [ 3 ]         BNE     REGTWO          ; BRANCH YES
9659 fcb9 a6 82              [ 6 ]         LDA     ,-X             ; SETUP FOR TWO
9660 fcbb ed 84              [ 5 ] REGTWO  STD     ,X              ; STORE IN NEW VALUE
9661 fcbd a6 e4              [ 4 ]         LDA     ,S              ; RECOVER DELIMITER
9662 fcbf 81 0d              [ 2 ]         CMPA    #CR             ; ? END OF CHANGES
9663 fcc1 26 d1              [ 3 ]         BNE     REG4            ; NO, KEEP ON TRUCK'N
9664                               * MOVE STACKED DATA TO NEW STACK IN CASE STACK
9665                               * POINTER HAS CHANGED
9666 fcc3 30 8d 82 35        [ 9 ] REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
9667 fcc7 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT
9668 fcc9 35 02              [ 6 ] REGTF1  PULS    A               ; NEXT BYTE
9669 fccb a7 80              [ 6 ]         STA     ,X+             ; STORE INTO TEMP
9670 fccd 5a                 [ 2 ]         DECB                    ; COUNT DOWN
9671 fcce 26 f9              [ 3 ]         BNE     REGTF1          ; LOOP IF MORE
9672 fcd0 10 ee 88 ec        [ 7 ]         LDS     -20,X           ; LOAD NEW STACK POINTER
9673 fcd4 c6 15              [ 2 ]         LDB     #21             ; LOAD COUNT AGAIN
9674 fcd6 a6 82              [ 6 ] REGTF2 LDA      ,-X             ; NEXT TO STORE
9675 fcd8 34 02              [ 6 ]        PSHS     A               ; BACK ONTO NEW STACK
9676 fcda 5a                 [ 2 ]        DECB                     ; COUNT DOWN
9677 fcdb 26 f9              [ 3 ]        BNE      REGTF2          ; LOOP IF MORE
9678 fcdd 20 bc              [ 3 ]        BRA      REGRTN          ; GO RESTART COMMAND
9679                               
9680                               *********************************************
9681                               * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
9682                               * THE ACTIVE EXPRESSION HANDLER IS USED.
9683                               * INPUT: S=RETURN ADDRESS
9684                               * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
9685                               * (IF DELM NOT ZERO)
9686                               * "NUMBER"=WORD BINARY RESULT
9687                               * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
9688                               * REGISTERS ARE TRANSPARENT
9689                               **********************************************
9690                               * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
9691                               *
9692                               * THE FLAG "DELIM" IS USED AS FOLLOWS:
9693                               * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
9694                               * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
9695 fcdf 4f                 [ 2 ] BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
9696 fce0 8c                               FCB     SKIP2           ; SKIP NEXT INSTRUCTION
9697                               * BUILD WITH LEADING BLANKS
9698 fce1 86 20              [ 2 ] BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
9699 fce3 97 39              [ 4 ]         STA     <DELIM          ; STORE AS DELIMITER
9700 fce5 6e 9d 82 ae        [11 ]         JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
9701                               * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
9702                               * 1) HEX INPUT
9703                               * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
9704                               * 3) 'P' FOR PROGRAM COUNTER ADDRESS
9705                               * 4) 'W' FOR WINDOW VALUE
9706                               * 5) '@' FOR INDIRECT VALUE
9707                               
9708 fce9 34 14              [ 8 ] EXP1    PSHS    X,B             ; SAVE REGISTERS
9709 fceb 8d 5c              [ 7 ] EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
9710 fced 27 18              [ 3 ]         BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
9711                               * SKIP BLANKS IF DESIRED
9712 fcef 91 39              [ 4 ]         CMPA    <DELIM          ; ? CORRECT DELIMITER
9713 fcf1 27 f8              [ 3 ]         BEQ     EXPDLM          ; YES, IGNORE IT
9714                               * TEST FOR M OR P
9715 fcf3 9e 49              [ 5 ]         LDX     <ADDR           ; DEFAULT FOR 'M'
9716 fcf5 81 4d              [ 2 ]         CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
9717 fcf7 27 16              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
9718 fcf9 9e 3e              [ 5 ]         LDX     <PCNTER         ; DEFAULT FOR 'P'
9719 fcfb 81 50              [ 2 ]         CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
9720 fcfd 27 10              [ 3 ]         BEQ     EXPTDL          ; BRANCH IF SO
9721 fcff 9e 4b              [ 5 ]         LDX     <WINDOW         ; DEFAULT TO WINDOW
9722 fd01 81 57              [ 2 ]         CMPA    #'W             ; ? WINDOW WANTED
9723 fd03 27 0a              [ 3 ]         BEQ     EXPTDL
9724                               
9725 fd05 35 94              [10 ] EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
9726                               * GOT HEX, NOW CONTINUE BUILDING
9727 fd07 8d 44              [ 7 ] EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
9728 fd09 27 fc              [ 3 ]         BEQ     EXP2            ; CONTINUE IF MORE
9729 fd0b 20 0a              [ 3 ]         BRA     EXPCDL          ; SEARCH FOR +/-
9730                               * STORE VALUE AND CHECK IF NEED DELIMITER
9731 fd0d ae 84              [ 5 ] EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
9732 fd0f 9f 46              [ 5 ] EXPTDL  STX     <NUMBER         ; STORE RESULT
9733 fd11 0d 39              [ 6 ]         TST     <DELIM          ; ? TO FORCE A DELIMITER
9734 fd13 27 f0              [ 3 ]         BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
9735 fd15 8d 62              [ 7 ]         BSR     READC           ; OBTAIN NEXT CHARACTER
9736                               * TEST FOR + OR -
9737 fd17 9e 46              [ 5 ] EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
9738 fd19 81 2b              [ 2 ]         CMPA    #'+             ; ? ADD OPERATOR
9739 fd1b 26 0e              [ 3 ]         BNE     EXPCHM          ; BRANCH NOT
9740 fd1d 8d 23              [ 7 ]         BSR     EXPTRM          ; COMPUTE NEXT TERM
9741 fd1f 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
9742 fd21 dc 46              [ 5 ]         LDD     <NUMBER         ; LOAD NEW TERM
9743 fd23 30 8b              [ 8 ] EXPADD  LEAX    D,X             ; ADD TO X
9744 fd25 9f 46              [ 5 ]         STX     <NUMBER         ; STORE AS NEW RESULT
9745 fd27 35 02              [ 6 ]         PULS    A               ; RESTORE DELIMITER
9746 fd29 20 ec              [ 3 ]         BRA     EXPCDL          ; NOW TEST IT
9747 fd2b 81 2d              [ 2 ] EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
9748 fd2d 27 07              [ 3 ]         BEQ     EXPSUB          ; BRANCH IF SO
9749 fd2f 81 40              [ 2 ]         CMPA    #'@             ; ? INDIRECTION DESIRED
9750 fd31 27 da              [ 3 ]         BEQ     EXPTDI          ; BRANCH IF SO
9751 fd33 5f                 [ 2 ]         CLRB                    ; SET DELIMITER RETURN
9752 fd34 20 cf              [ 3 ]         BRA     EXPRTN          ; AND RETURN TO CALLER
9753 fd36 8d 0a              [ 7 ] EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
9754 fd38 34 02              [ 6 ]         PSHS    A               ; SAVE DELIMITER
9755 fd3a dc 46              [ 5 ]         LDD     <NUMBER         ; LOAD UP NEXT TERM
9756 fd3c 40                 [ 2 ]         NEGA                    ; NEGATE A
9757 fd3d 50                 [ 2 ]         NEGB                    ; NEGATE B
9758 fd3e 82 00              [ 2 ]         SBCA    #0              ; CORRECT FOR A
9759 fd40 20 e1              [ 3 ]         BRA     EXPADD          ; GO ADD TO EXPRESSION
9760                               * COMPUTE NEXT EXPRESSION TERM
9761                               * OUTPUT: X=OLD VALUE
9762                               * 'NUMBER'=NEXT TERM
9763 fd42 8d 9d              [ 7 ] EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
9764 fd44 27 32              [ 3 ]         BEQ     CNVRTS          ; RETURN IF VALID NUMBER
9765 fd46 16 fc 13           [ 5 ] BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
9766                               
9767                               *********************************************
9768                               * BUILD BINARY VALUE USING INPUT CHARACTERS.
9769                               * INPUT: A=ASCII HEX VALUE OR DELIMITER
9770                               * SP+0=RETURN ADDRESS
9771                               * SP+2=16 BIT RESULT AREA
9772                               * OUTPUT: Z=1 A=BINARY VALUE
9773                               * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
9774                               * VOLATILE: D
9775                               ****************************************
9776 fd49 0f 46              [ 6 ] BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
9777 fd4b 0f 47              [ 6 ]         CLR     <NUMBER+1       ; CLEAR NUMBER
9778 fd4d 8d 2a              [ 7 ] BLDHEX  BSR     READC           ; GET INPUT CHARACTER
9779 fd4f 8d 11              [ 7 ] BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
9780 fd51 26 25              [ 3 ]         BNE     CNVRTS          ; RETURN IF NOT A NUMBER
9781 fd53 c6 10              [ 2 ]         LDB     #16             ; PREPARE SHIFT
9782 fd55 3d                 [11 ]         MUL                     ; BY FOUR PLACES
9783 fd56 86 04              [ 2 ]         LDA     #4              ; ROTATE BINARY INTO VALUE
9784 fd58 58                 [ 2 ] BLDSHF  ASLB                    ; OBTAIN NEXT BIT
9785 fd59 09 47              [ 6 ]         ROL     <NUMBER+1       ; INTO LOW BYTE
9786 fd5b 09 46              [ 6 ]         ROL     <NUMBER         ; INTO HI BYTE
9787 fd5d 4a                 [ 2 ]         DECA                    ; COUNT DOWN
9788 fd5e 26 f8              [ 3 ]         BNE     BLDSHF          ; BRANCH IF MORE TO DO
9789 fd60 20 14              [ 3 ]         BRA     CNVOK           ; SET GOOD RETURN CODE
9790                               
9791                               ****************************************
9792                               * CONVERT ASCII CHARACTER TO BINARY BYTE
9793                               * INPUT: A=ASCII
9794                               * OUTPUT: Z=1 A=BINARY VALUE
9795                               * Z=0 IF INVALID
9796                               * ALL REGISTERS TRANSPARENT
9797                               * (A UNALTERED IF INVALID HEX)
9798                               **************************************
9799 fd62 81 30              [ 2 ] CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
9800 fd64 25 12              [ 3 ]         BLO     CNVRTS          ; BRANCH NOT VALUE
9801 fd66 81 39              [ 2 ]         CMPA    #'9             ; ? POSSIBLE A-F
9802 fd68 2f 0a              [ 3 ]         BLE     CNVGOT          ; BRANCH NO TO ACCEPT
9803 fd6a 81 41              [ 2 ]         CMPA    #'A             ; ? LESS THEN TEN
9804 fd6c 25 0a              [ 3 ]         BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
9805 fd6e 81 46              [ 2 ]         CMPA    #'F             ; ? NOT TOO LARGE
9806 fd70 22 06              [ 3 ]         BHI     CNVRTS          ; NO, RETURN TOO LARGE
9807 fd72 80 07              [ 2 ]         SUBA    #7              ; DOWN TO BINARY
9808 fd74 84 0f              [ 2 ] CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
9809 fd76 1a 04              [ 3 ] CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
9810 fd78 39                 [ 5 ] CNVRTS  RTS                     ; RETURN TO CALLER
9811                               
9812                               * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
9813 fd79 3f                 [19 ] READC    SWI                    ; GET NEXT CHARACTER
9814 fd7a 00                                FCB    INCHNP          ; FUNCTION
9815 fd7b 81 18              [ 2 ]          CMPA   #CAN            ; ? ABORT COMMAND
9816 fd7d 27 c7              [ 3 ]          BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
9817 fd7f 39                 [ 5 ]          RTS                    ; RETURN TO CALLER
9818                               *G
9819                               
9820                               ***************GO - START PROGRAM EXECUTION
9821 fd80 8d 01              [ 7 ] CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
9822 fd82 3b                 [15 ]          RTI                    ; START EXECUTING
9823                               
9824                               * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
9825                               * BREAKPOINTS.
9826 fd83 35 30              [ 9 ] GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
9827 fd85 34 10              [ 7 ]          PSHS   X               ; STORE RETURN BACK
9828 fd87 26 19              [ 3 ]          BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
9829                               
9830                               * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
9831                               * IMMEDIATE BREAKPOINT.
9832 fd89 17 01 b6           [ 9 ]          LBSR   CBKLDR          ; SEARCH BREAKPOINTS
9833 fd8c ae 6c              [ 6 ]          LDX    12,S            ; LOAD PROGRAM COUNTER
9834 fd8e 5a                 [ 2 ] ARMBLP  DECB                    ; COUNT DOWN
9835 fd8f 2b 16              [ 3 ]         BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
9836 fd91 a6 30              [ 5 ]         LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
9837 fd93 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
9838 fd95 26 f7              [ 3 ]         BNE     ARMBLP          ; LOOP IF NOT
9839 fd97 81 3f              [ 2 ]         CMPA    #$3F            ; ? SWI BREAKPOINTED
9840 fd99 26 02              [ 3 ]         BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
9841 fd9b 97 a6              [ 4 ]         STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
9842 fd9d 0c 3a              [ 6 ] ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
9843 fd9f 16 01 06           [ 5 ]         LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
9844                               
9845                               * OBTAIN NEW PROGRAM COUNTER
9846 fda2 17 00 bb           [ 9 ] GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
9847 fda5 ed 6c              [ 6 ]         STD     12,S            ; STORE INTO STACK
9848 fda7 17 01 98           [ 9 ] ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
9849 fdaa 00 a5              [ 6 ]         NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
9850 fdac 5a                 [ 2 ] ARMLOP  DECB                    ; ? DONE
9851 fdad 2b c9              [ 3 ]         BMI     CNVRTS          ; RETURN WHEN DONE
9852 fdaf a6 b4              [ 7 ]         LDA     [,Y]            ; LOAD OPCODE
9853 fdb1 a7 30              [ 5 ]         STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
9854 fdb3 86 3f              [ 2 ]         LDA     #$3F            ; READY "SWI" OPCODE
9855 fdb5 a7 b1              [10 ]         STA     [,Y++]          ; STORE AND MOVE UP TABLE
9856 fdb7 20 f3              [ 3 ]         BRA     ARMLOP          ; AND CONTINUE
9857                               
9858                               *******************CALL - CALL ADDRESS AS SUBROUTINE
9859 fdb9 8d c8              [ 7 ] CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
9860 fdbb 35 7f              [15 ]         PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
9861 fdbd ad f1              [13 ]         JSR     [,S++]          ; CALL USER SUBROUTINE
9862 fdbf 3f                 [19 ] CGOBRK  SWI                     ; PERFORM BREAKPOINT
9863 fdc0 0a                               FCB     BRKPT           ; FUNCTION
9864 fdc1 20 fc              [ 3 ]         BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
9865                               
9866                               ****************MEMORY - DISPLAY/CHANGE MEMORY
9867                               * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
9868                               * THE COMMAND HANDLER FOR QUICK COMMANDS
9869 fdc3 17 00 9a           [ 9 ] CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
9870 fdc6 dd 49              [ 5 ] CMEMN   STD     <ADDR           ; STORE DEFAULT
9871 fdc8 9e 49              [ 5 ] CMEM2   LDX     <ADDR           ; LOAD POINTER
9872 fdca 17 fc 0c           [ 9 ]         LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
9873 fdcd 86 2d              [ 2 ]         LDA     #'-             ; LOAD DELIMITER
9874 fdcf 3f                 [19 ]         SWI                     ; SEND OUT
9875 fdd0 01                               FCB     OUTCH           ; FUNCTION
9876 fdd1 17 ff 0b           [ 9 ] CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
9877 fdd4 27 0a              [ 3 ]         BEQ     CMENUM          ; BRANCH IF NUMBER
9878                               * COMA - SKIP BYTE
9879 fdd6 81 2c              [ 2 ]         CMPA    #',             ; ? COMMA
9880 fdd8 26 0e              [ 3 ]         BNE     CMNOTC          ; BRANCH NOT
9881 fdda 9f 49              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
9882 fddc 30 01              [ 5 ]         LEAX    1,X             ; TO NEXT BYTE
9883 fdde 20 f1              [ 3 ]         BRA     CMEM4           ; AND INPUT IT
9884 fde0 d6 47              [ 4 ] CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
9885 fde2 8d 47              [ 7 ]         BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
9886 fde4 81 2c              [ 2 ]         CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
9887 fde6 27 e9              [ 3 ]         BEQ     CMEM4           ; BRANCH YES
9888                               * QUOTED STRING
9889 fde8 81 27              [ 2 ] CMNOTC  CMPA    #$27            ; ? QUOTED STRING
9890 fdea 26 0c              [ 3 ]         BNE     CMNOTQ          ; BRANCH NO
9891 fdec 8d 8b              [ 7 ] CMESTR  BSR     READC           ; OBTAIN NEXT CHARACTER
9892 fdee 81 27              [ 2 ]         CMPA    #$27            ; ? END OF QUOTED STRING
9893 fdf0 27 0c              [ 3 ]         BEQ     CMSPCE          ; YES, QUIT STRING MODE
9894 fdf2 1f 89              [ 6 ]         TFR     A,B             ; TO B FOR SUBROUTINE
9895 fdf4 8d 35              [ 7 ]         BSR     MUPDAT          ; GO UPDATE BYTE
9896 fdf6 20 f4              [ 3 ]         BRA     CMESTR          ; GET NEXT CHARACTER
9897                               * BLANK - NEXT BYTE
9898 fdf8 81 20              [ 2 ] CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
9899 fdfa 26 06              [ 3 ]         BNE     CMNOTB          ; BRANCH NOT
9900 fdfc 9f 49              [ 5 ]         STX     <ADDR           ; UPDATE POINTER
9901 fdfe 3f                 [19 ] CMSPCE  SWI                     ; GIVE SPACE
9902 fdff 07                               FCB     SPACEF          ; FUNCTION
9903 fe00 20 c6              [ 3 ]         BRA     CMEM2           ; NOW PROMPT FOR NEXT
9904                               
9905                               * LINE FEED - NEXT BYTE WITH ADDRESS
9906 fe02 81 0a              [ 2 ] CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
9907 fe04 26 08              [ 3 ]         BNE     CMNOTL          ; BRANCH NO
9908 fe06 86 0d              [ 2 ]         LDA     #CR             ; GIVE CARRIAGE RETURN
9909 fe08 3f                 [19 ]         SWI                     ; TO CONSOLE
9910 fe09 01                               FCB     OUTCH           ; HANDLER
9911 fe0a 9f 49              [ 5 ]         STX     <ADDR           ; STORE NEXT ADDRESS
9912 fe0c 20 0a              [ 3 ]         BRA     CMPADP          ; BRANCH TO SHOW
9913                               
9914                               * UP ARROW - PREVIOUS BYTE AND ADDRESS
9915 fe0e 81 5e              [ 2 ] CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
9916 fe10 26 0a              [ 3 ]         BNE     CMNOTU          ; BRANCH NOT
9917 fe12 30 1e              [ 5 ]         LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
9918 fe14 9f 49              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER
9919 fe16 3f                 [19 ] CMPADS  SWI                     ; FORCE NEW LINE
9920 fe17 06                               FCB     PCRLF           ; FUNCTION
9921 fe18 8d 07              [ 7 ] CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
9922 fe1a 20 ac              [ 3 ]         BRA     CMEM2           ; THEN PROMPT FOR INPUT
9923                               
9924                               * SLASH - NEXT BYTE WITH ADDRESS
9925 fe1c 81 2f              [ 2 ] CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
9926 fe1e 27 f6              [ 3 ]         BEQ     CMPADS          ; YES, SEND ADDRESS
9927 fe20 39                 [ 5 ]         RTS                     ; RETURN FROM COMMAND
9928                               
9929                               * PRINT CURRENT ADDRESS
9930 fe21 9e 49              [ 5 ] PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
9931 fe23 34 10              [ 7 ]         PSHS    X               ; SAVE X ON STACK
9932 fe25 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT FOR DISPLAY
9933 fe27 3f                 [19 ]         SWI                     ; DISPLAY POINTER IN HEX
9934 fe28 05                               FCB     OUT4HS          ; FUNCTION
9935 fe29 35 90              [ 9 ]         PULS    PC,X            ; RECOVER POINTER AND RETURN
9936                               
9937                               * UPDATE BYTE
9938 fe2b 9e 49              [ 5 ] MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
9939 fe2d e7 80              [ 6 ]         STB     ,X+             ; STORE AND INCREMENT X
9940 fe2f e1 1f              [ 5 ]         CMPB    -1,X            ; ? SUCCESFULL STORE
9941 fe31 26 03              [ 3 ]         BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
9942 fe33 9f 49              [ 5 ]         STX     <ADDR           ; STORE NEW POINTER VALUE
9943 fe35 39                 [ 5 ]         RTS                     ; BACK TO CALLER
9944 fe36 34 02              [ 6 ] MUPBAD  PSHS    A               ; SAVE A REGISTER
9945 fe38 86 3f              [ 2 ]         LDA     #'?             ; SHOW INVALID
9946 fe3a 3f                 [19 ]         SWI                     ; SEND OUT
9947 fe3b 01                               FCB     OUTCH           ; FUNCTION
9948 fe3c 35 82              [ 8 ]         PULS    PC,A            ; RETURN TO CALLER
9949                               
9950                               ********************WINDOW - SET WINDOW VALUE
9951 fe3e 8d 20              [ 7 ] CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
9952 fe40 dd 4b              [ 5 ]         STD     <WINDOW         ; STORE IT IN
9953 fe42 39                 [ 5 ]         RTS                     ; END COMMAND
9954                               
9955                               ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
9956 fe43 8d 1b              [ 7 ] CDISP   BSR     CDNUM           ; FETCH ADDRESS
9957 fe45 c4 f0              [ 2 ]         ANDB    #$F0            ; FORCE TO 16 BOUNDARY
9958 fe47 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
9959 fe49 30 2f              [ 5 ]         LEAX    15,Y            ; DEFAULT LENGTH
9960 fe4b 25 04              [ 3 ]         BCS     CDISPS          ; BRANCH IF END OF INPUT
9961 fe4d 8d 11              [ 7 ]         BSR     CDNUM           ; OBTAIN COUNT
9962 fe4f 30 ab              [ 8 ]         LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
9963 fe51 34 30              [ 9 ] CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
9964 fe53 10 a3 62           [ 8 ]         CMPD    2,S             ; ? WAS IT COUNT
9965 fe56 23 02              [ 3 ]         BLS     CDCNT           ; BRANCH YES
9966 fe58 ed e4              [ 5 ]         STD     ,S              ; STORE HIGH ADDRESS
9967 fe5a ad 9d 81 2f        [15 ] CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
9968 fe5e 35 e0              [11 ]         PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
9969                               
9970                               * OBTAIN NUMBER - ABORT IF NONE
9971                               * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
9972                               * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
9973                               * ELSE C=0
9974 fe60 17 fe 7e           [ 9 ] CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
9975 fe63 26 09              [ 3 ]         BNE     CDBADN          ; BRANCH IF INVALID
9976 fe65 81 2f              [ 2 ]         CMPA    #'/             ; ? VALID DELIMITER
9977 fe67 22 05              [ 3 ]         BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
9978 fe69 81 0e              [ 2 ]         CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
9979 fe6b dc 46              [ 5 ]         LDD     <NUMBER         ; LOAD NUMBER
9980 fe6d 39                 [ 5 ]         RTS                     ; RETURN WITH COMPARE
9981 fe6e 16 fa eb           [ 5 ] CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
9982                               
9983                               *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
9984 fe71 8d ed              [ 7 ] CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
9985 fe73 1f 02              [ 6 ]         TFR     D,Y             ; SAVE IN Y
9986 fe75 8d e9              [ 7 ]         BSR     CDNUM           ; OBTAIN END ADDRESS
9987 fe77 6f e2              [ 8 ]         CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
9988 fe79 34 26              [ 9 ]         PSHS    Y,D             ; STORE VALUES ON STACK
9989 fe7b ad 9d 81 10        [15 ] CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
9990 fe7f ad 9d 81 0e        [15 ]         JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
9991 fe83 34 01              [ 6 ]         PSHS    CC              ; SAVE RETURN CODE
9992 fe85 ad 9d 81 0a        [15 ]         JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
9993 fe89 35 01              [ 6 ]         PULS    CC              ; OBTAIN CONDITION CODE SAVED
9994 fe8b 26 e1              [ 3 ]         BNE     CDBADN          ; BRANCH IF ERROR
9995 fe8d 35 b2              [12 ]         PULS    PC,Y,X,A        ; RETURN FROM COMMAND
9996                               
9997                               *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
9998 fe8f 8d 01              [ 7 ] CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
9999 fe91 01                               FCB     1               ; LOAD FUNCTION CODE FOR PACKET
10000                               
10001 fe92 33 f1              [10 ] CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
10002 fe94 33 d4              [ 7 ]         LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
10003 fe96 27 03              [ 3 ]         BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
10004 fe98 8d c6              [ 7 ]         BSR     CDNUM           ; OBTAIN OFFSET
10005 fe9a 8c                               FCB     SKIP2           ; SKIP DEFAULT OFFSET
10006 fe9b 4f                 [ 2 ] CLVDFT  CLRA                    ; CREATE ZERO OFFSET
10007 fe9c 5f                 [ 2 ]         CLRB                    ; AS DEFAULT
10008 fe9d 34 4e              [10 ]         PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
10009 fe9f 20 da              [ 3 ]         BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
10010                               
10011                               ******************VERIFY - COMPARE MEMORY WITH FILES
10012 fea1 8d ef              [ 7 ] CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
10013 fea3 ff                               FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
10014                               
10015                               *******************TRACE - TRACE INSTRUCTIONS
10016                               ******************* . - SINGLE STEP TRACE
10017 fea4 8d ba              [ 7 ] CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
10018 fea6 dd 3c              [ 5 ]         STD     <TRACEC         ; STORE COUNT
10019 fea8 32 62              [ 5 ] CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
10020 feaa ee f8 0a           [ 9 ] CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
10021 fead df 44              [ 5 ]         STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
10022 feaf de a1              [ 5 ]         LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
10023 feb1 cc 07 01           [ 3 ]         LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
10024 feb4 ed 42              [ 6 ]         STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
10025 feb6 3b                 [15 ]         RTI                     ; RETURN FOR ONE INSTRUCTION
10026                               
10027                               *************NULLS  -  SET NEW LINE AND CHAR PADDING
10028 feb7 8d a7              [ 7 ] CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
10029 feb9 dd 9d              [ 5 ]         STD     <VECTAB+.PAD    ; RESET VALUES
10030 febb 39                 [ 5 ]         RTS                     ; END COMMAND
10031                               
10032                               ******************STLEVEL - SET STACK TRACE LEVEL
10033 febc 27 05              [ 3 ] CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
10034 febe 8d a0              [ 7 ]         BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
10035 fec0 dd a3              [ 5 ]         STD     <SLEVEL         ; STORE NEW ENTRY
10036 fec2 39                 [ 5 ]         RTS                     ; TO COMMAND HANDLER
10037 fec3 30 6e              [ 5 ] STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
10038 fec5 9f a3              [ 5 ]         STX     <SLEVEL         ; AND STORE IT
10039 fec7 39                 [ 5 ]         RTS                     ; END COMMAND
10040                               
10041                               ******************OFFSET - COMPUTE SHORT AND LONG
10042                               ******************                  BRANCH OFFSETS
10043 fec8 8d 96              [ 7 ] COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
10044 feca 1f 01              [ 6 ]         TFR     D,X             ; USE AS FROM ADDRESS
10045 fecc 8d 92              [ 7 ]         BSR     CDNUM           ; OBTAIN TO ADDRESS
10046                               * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
10047 fece 30 01              [ 5 ]         LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
10048 fed0 34 30              [ 9 ]         PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
10049 fed2 a3 e4              [ 6 ]         SUBD    ,S              ; FIND OFFSET
10050 fed4 ed e4              [ 5 ]         STD     ,S              ; SAVE OVER STACK
10051 fed6 30 61              [ 5 ]         LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
10052 fed8 1d                 [ 2 ]         SEX                     ; SIGN EXTEND LOW BYTE
10053 fed9 a1 e4              [ 4 ]         CMPA    ,S              ; ? VALID ONE BYTE OFFSET
10054 fedb 26 02              [ 3 ]         BNE     COFNO1          ; BRANCH IF NOT
10055 fedd 3f                 [19 ]         SWI                     ; SHOW ONE BYTE OFFSET
10056 fede 04                               FCB     OUT2HS          ; FUNCTION
10057 fedf ee e4              [ 5 ] COFNO1  LDU     ,S              ; RELOAD OFFSET
10058 fee1 33 5f              [ 5 ]         LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
10059 fee3 ef 84              [ 5 ]         STU     ,X              ; STORE BACK WHERE X POINTS NOW
10060 fee5 3f                 [19 ]         SWI                     ; SHOW TWO BYTE OFFSET
10061 fee6 05                               FCB     OUT4HS          ; FUNCTION
10062 fee7 3f                 [19 ]         SWI                     ; FORCE NEW LINE
10063 fee8 06                               FCB     PCRLF           ; FUNCTION
10064 fee9 35 96              [11 ]         PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
10065                               *H
10066                               
10067                               *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
10068                               *************             BREAKPOINTS
10069 feeb 27 23              [ 3 ] CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
10070 feed 17 fd f1           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
10071 fef0 27 2c              [ 3 ]         BEQ     CBKADD          ; BRANCH TO ADD IF SO
10072 fef2 81 2d              [ 2 ]         CMPA    #'-             ; ? CORRECT DELIMITER
10073 fef4 26 3f              [ 3 ]         BNE     CBKERR          ; NO, BRANCH FOR ERROR
10074 fef6 17 fd e8           [ 9 ]         LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
10075 fef9 27 03              [ 3 ]         BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
10076 fefb 0f a5              [ 6 ]         CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
10077 fefd 39                 [ 5 ] CBKRTS  RTS                     ; END COMMAND
10078                               * DELETE THE ENTRY
10079 fefe 8d 40              [ 7 ] CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
10080 ff00 5a                 [ 2 ] CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
10081 ff01 2b 32              [ 3 ]         BMI     CBKERR          ; BRANCH NO, ERROR
10082 ff03 ac a1              [ 9 ]         CMPX    ,Y++            ; ? IS THIS THE ENTRY
10083 ff05 26 f9              [ 3 ]         BNE     CBKDLP          ; NO, TRY NEXT
10084                               * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
10085 ff07 ae a1              [ 8 ] CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
10086 ff09 af 3c              [ 6 ]         STX     -4,Y            ; MOVE DOWN BY ONE
10087 ff0b 5a                 [ 2 ]         DECB                    ; ? DONE
10088 ff0c 2a f9              [ 3 ]         BPL     CBKDLM          ; NO, CONTINUE MOVE
10089 ff0e 0a a5              [ 6 ]         DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
10090 ff10 8d 2e              [ 7 ] CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
10091 ff12 27 e9              [ 3 ]         BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
10092 ff14 30 a1              [ 7 ] CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
10093 ff16 3f                 [19 ]         SWI                     ; DISPLAY IN HEX
10094 ff17 05                               FCB     OUT4HS          ; FUNCTION
10095 ff18 5a                 [ 2 ]         DECB                    ; COUNT DOWN
10096 ff19 26 f9              [ 3 ]         BNE     CBKDSL          ; LOOP IF NGABLE RAM
10097 ff1b 3f                 [19 ]         SWI                     ; SKIP TO NEW LINK
10098 ff1c 06                               FCB     PCRLF           ; FUNCTIONRTS
10099 ff1d 39                 [ 5 ]         RTS
10100                               
10101                               * ADD NEW ENTRY
10102 ff1e 8d 20              [ 7 ] CBKADD  BSR     CBKSET          ; SETUP REGISTERS
10103 ff20 c1 08              [ 2 ]         CMPB    #NUMBKP         ; ? ALREADY FULL
10104 ff22 27 11              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
10105 ff24 a6 84              [ 4 ]         LDA     ,X              ; LOAD BYTE TO TRAP
10106 ff26 e7 84              [ 4 ]         STB     ,X              ; TRY TO CHANGE
10107 ff28 e1 84              [ 4 ]         CMPB    ,X              ; ? CHANGEABLE RAM
10108 ff2a 26 09              [ 3 ]         BNE     CBKERR          ; BRANCH ERROR IF NOT
10109 ff2c a7 84              [ 4 ]         STA ,X                  ; RESTORE BYTE
10110 ff2e 5a                 [ 2 ] CBKADL  DECB                    ; COUNT DOWN
10111 ff2f 2b 07              [ 3 ]         BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
10112 ff31 ac a1              [ 9 ]         CMPX    ,Y++            ; ? ENTRY ALREADY HERE
10113 ff33 26 f9              [ 3 ]         BNE     CBKADL          ; LOOP IF NOT
10114 ff35 16 fa 24           [ 5 ] CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
10115 ff38 af a4              [ 5 ] CBKADT  STX ,Y                  ; ADD THIS ENTRY
10116 ff3a 6f 31              [ 7 ]         CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
10117 ff3c 0c a5              [ 6 ]         INC     <BKPTCT         ; ADD ONE TO COUNT
10118 ff3e 20 d0              [ 3 ]         BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
10119                               * SETUP REGISTERS FOR SCAN
10120 ff40 9e 46              [ 5 ] CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
10121 ff42 31 8d 80 17        [ 9 ] CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
10122 ff46 d6 a5              [ 4 ]         LDB     <BKPTCT         ; LOAD ENTRY COUNT
10123 ff48 39                 [ 5 ]         RTS                     ; RETURN
10124                               
10125                               *****************ENCODE  -  ENCODE A POSTBYTE
10126 ff49 6f e2              [ 8 ] CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
10127 ff4b 5f                 [ 2 ]         CLRB                    ; ZERO POSTBYTE VALUE
10128 ff4c 30 8c 3f           [ 5 ]         LEAX    <CONV1,PCR      ; START TABLE SEARCH
10129 ff4f 3f                 [19 ]         SWI                     ; OBTAIN FIRST CHARACTER
10130 ff50 00                               FCB     INCHNP          ; FUNCTION
10131 ff51 81 5b              [ 2 ]         CMPA    #'[             ; ? INDIRECT HERE
10132 ff53 26 06              [ 3 ]         BNE     CEN2            ; BRANCH IF NOT
10133 ff55 86 10              [ 2 ]         LDA     #$10            ; SET INDIRECT BIT ON
10134 ff57 a7 e4              [ 4 ]         STA     ,S              ; SAVE FOR LATER
10135 ff59 3f                 [19 ] CENGET  SWI                     ; OBTAIN NEXT CHARACTER
10136 ff5a 00                               FCB     INCHNP          ; FUNCTION
10137 ff5b 81 0d              [ 2 ] CEN2    CMPA    #CR             ; ? END OF ENTRY
10138 ff5d 27 0c              [ 3 ]         BEQ     CEND1           ; BRANCH YES
10139 ff5f 6d 84              [ 6 ] CENLP1  TST     ,X              ; ? END OF TABLE
10140 ff61 2b d2              [ 3 ]         BMI     CBKERR          ; BRANCH ERROR IF SO
10141 ff63 a1 81              [ 7 ]         CMPA    ,X++            ; ? THIS THE CHARACTER
10142 ff65 26 f8              [ 3 ]         BNE     CENLP1          ; BRANCH IF NOT
10143 ff67 eb 1f              [ 5 ]         ADDB    -1,X            ; ADD THIS VALUE
10144 ff69 20 ee              [ 3 ]         BRA     CENGET          ; GET NEXT INPUT
10145 ff6b 30 8c 49           [ 5 ] CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
10146 ff6e 1f 98              [ 6 ]         TFR     B,A             ; SAVE COPY IN A
10147 ff70 84 60              [ 2 ]         ANDA    #$60            ; ISOLATE REGISTER MASK
10148 ff72 aa e4              [ 4 ]         ORA     ,S              ; ADD IN INDIRECTION BIT
10149 ff74 a7 e4              [ 4 ]         STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
10150 ff76 c4 9f              [ 2 ]         ANDB    #$9F            ; CLEAR REGISTER BITS
10151 ff78 6d 84              [ 6 ] CENLP2  TST     ,X              ; ? END OF TABLE
10152 ff7a 27 b9              [ 3 ]         BEQ     CBKERR          ; BRANCH ERROR IF SO
10153 ff7c e1 81              [ 7 ]         CMPB    ,X++            ; ? SAME VALUE
10154 ff7e 26 f8              [ 3 ]         BNE     CENLP2          ; LOOP IF NOT
10155 ff80 e6 1f              [ 5 ]         LDB     -1,X            ; LOAD RESULT VALUE
10156 ff82 ea e4              [ 4 ]         ORB     ,S              ; ADD TO BASE SKELETON
10157 ff84 e7 e4              [ 4 ]         STB     ,S              ; SAVE POSTBYTE ON STACK
10158 ff86 30 e4              [ 4 ]         LEAX    ,S              ; POINT TO IT
10159 ff88 3f                 [19 ]         SWI                     ; SEND OUT AS HEX
10160 ff89 04                               FCB     OUT2HS          ; FUNCTION
10161 ff8a 3f                 [19 ]         SWI                     ; TO NEXT LINE
10162 ff8b 06                               FCB     PCRLF           ; FUNCTION
10163 ff8c 35 84              [ 8 ]         PULS    PC,B            ; END OF COMMAND
10164                               
10165                               * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
10166                               CONV1
10167 ff8e 41 04 42 05 44 06                FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
10168 ff96 48 01 48 01 48 00                FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
10169 ff9e 2d 09 2d 01 53 70                FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
10170 ffa6 55 50 58 10 2b 07                FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
10171 ffae 50 80 43 00 52 00                FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
10172 ffb6 ff                               FCB     $FF             ; END OF TABLE
10173                               
10174                               * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
10175                               * BIT SKELETON.
10176                               CONV2
10177 ffb7 10 84 11 00                      FDB     $1084,$1100     ; R,      H,R
10178 ffbb 12 88 13 89                      FDB     $1288,$1389     ; HH,R    HHHH,R
10179 ffbf 14 86 15 85                      FDB     $1486,$1585     ; A,R     B,R
10180 ffc3 16 8b 17 80                      FDB     $168B,$1780     ; D,R     ,R+
10181 ffc7 18 81 19 82                      FDB     $1881,$1982     ; ,R++    ,-R
10182 ffcb 1a 83 82 8c                      FDB     $1A83,$828C     ; ,--R    HH,PCR
10183 ffcf 83 8d 03 9f                      FDB     $838D,$039F     ; HHHH,PCR [HHHH]
10184 ffd3 00                               FCB     0               ; END OF TABLE
10185                               
10186                               ****************************************************
10187                               *            DEFAULT INTERRUPT TRANSFERS           *
10188                               ****************************************************
10189 ffd4 6e 9d 7f 99        [11 ] RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
10190 ffd8 6e 9d 7f 97        [11 ] SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
10191 ffdc 6e 9d 7f 95        [11 ] SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
10192 ffe0 6e 9d 7f 93        [11 ] FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
10193 ffe4 6e 9d 7f 91        [11 ] IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
10194 ffe8 6e 9d 7f 8f        [11 ] SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
10195 ffec 6e 9d 7f 8d        [11 ] NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
10196                               
10197                               ******************************************************
10198                               *            ASSIST09 HARDWARE VECTOR TABLE
10199                               * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
10200                               * THE MC6809 HARDWARE VECTORS.
10201                               ******************************************************
10202 fff0                                  ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
10203 fff0 ff d4                            FDB     RSRVD           ; RESERVED SLOT
10204 fff2 ff d8                            FDB     SWI3            ; SOFTWARE INTERRUPT 3
10205 fff4 ff dc                            FDB     SWI2            ; SOFTWARE INTERRUPT 2
10206 fff6 ff e0                            FDB     FIRQ            ; FAST INTERRUPT REQUEST
10207 fff8 ff e4                            FDB     IRQ             ; INTERRUPT REQUEST
10208 fffa ff e8                            FDB     SWI             ; SOFTWARE INTERRUPT
10209 fffc ff ec                            FDB     NMI             ; NON-MASKABLE INTERRUPT
10210 fffe f8 37                            FDB     RESET           ; RESTART
